id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2309,Availability,toler,tolerance,2309,"ssnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quie",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2401,Availability,error,error,2401," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6352,Availability,error,error,6352,")""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expecte",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6727,Availability,error,error,6727,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9090,Availability,error,errors,9090,"; xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; erro",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9394,Availability,error,errors,9394,"- xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k]",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9559,Availability,error,errors,9559,"on=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, co",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9694,Availability,error,errors,9694,"; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; error",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9842,Availability,error,errors,9842,"ssage = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, m",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:10069,Availability,error,errors,10069,"refix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:10163,Availability,error,errors,10163,"e + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not compute",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:10297,Availability,error,errors,10297,":; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive c",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:10629,Availability,error,errors,10629,"puted):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive:",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:11028,Availability,error,errors,11028,"_len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is comp",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:11145,Availability,error,errors,11145,"ormat(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formul",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:11201,Availability,error,errors,11201,""".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:11303,Availability,error,errors,11303,"s.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive;",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12092,Availability,toler,tolerance,12092,"d, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if retu",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12152,Availability,error,error,12152," errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12219,Availability,toler,tolerance,12219,"ype {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12392,Availability,failure,failure,12392,"ected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_er",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12650,Availability,toler,tolerance,12650,": bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(erro",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12742,Availability,error,error,12742,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13153,Availability,error,errors,13153," function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13227,Availability,error,errors,13227,"orgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13465,Availability,error,errors,13465,"e computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13612,Availability,error,errors,13612,"uted` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13739,Availability,error,errors,13739,"ssed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:13922,Availability,error,errors,13922," 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; #",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14015,Availability,error,errors,14015,"*-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14290,Availability,error,errors,14290,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:15217,Availability,error,errors,15217,"0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['molecular_multiplicity']); # if 'fragment_multiplicities' in dicary:; # dicary['fragment_multiplicities'] = [(m if m is None else int(m)); # for m in dicary['fragment_multiplicities']]; if ""fragment_separators"" in dicary:; dicary[""fragment_separators""] = [(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed befo",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:17485,Deployability,update,updated,17485,"rs""] = [(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed before the; # recursive dict comparison.; from .molutil.align import B787. cgeom = np.array(cptd[""geom""]).reshape((-1, 3)); rgeom = np.array(xptd[""geom""]).reshape((-1, 3)); rmsd, mill = B787(; rgeom=rgeom,; cgeom=cgeom,; runiq=None,; cuniq=None,; atoms_map=True,; mols_align=True,; run_mirror=False,; verbose=0,; ); if cptd[""fix_com""]:; return compare(; True,; np.allclose(np.zeros((3)), mill.shift, atol=atol),; ""null shift"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); if cptd[""fix_orientation""]:; return compare(; True,; np.allclose(np.identity(3), mill.rotation, atol=atol),; ""null rotation"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); ageom = mill.align_coordinates(cgeom); cptd[""geom""] = ageom.reshape((-1)). return compare_recursive(; xptd,; cptd,; atol=atol,; rtol=rtol,; label=label,; forgive=forgive,; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:556,Integrability,message,message,556,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:805,Integrability,message,message,805,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:859,Integrability,message,message,859,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:1790,Integrability,message,messages,1790,"}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed typ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2153,Integrability,message,message,2153,"array],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2338,Integrability,message,message,2338," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2407,Integrability,message,message,2407," = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.ar",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:4190,Integrability,message,message,4190,"d is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_handler(; False, label, f""""""\t{label}: inputs not cast-able to ndarray of {dtype}."""""", return_message, quiet; ). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). digits1 = abs(int(np.log10(atol))) + 2; digits_str = f""to atol={atol}""; if rtol > 1.0e-12:; digits_str += f"", rtol={rtol}"". isclose = np.isclose(cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(isclose)). if not allclose and equal_phase and hasattr(cptd, ""__neg__""):; n_isclose = np.isclose(-cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(n_isclose)). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{float(xptd):.{digits1}f}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); di",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:4744,Integrability,message,message,4744,"nt(np.log10(atol))) + 2; digits_str = f""to atol={atol}""; if rtol > 1.0e-12:; digits_str += f"", rtol={rtol}"". isclose = np.isclose(cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(isclose)). if not allclose and equal_phase and hasattr(cptd, ""__neg__""):; n_isclose = np.isclose(-cptd, xptd, rtol=rtol, atol=atol, equal_nan=equal_nan); allclose = bool(np.all(n_isclose)). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{float(xptd):.{digits1}f}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; com",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:5348,Integrability,message,message,5348,"True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{float(cptd):.{digits1}f}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Def",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:5585,Integrability,message,message,5585,"ss_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). diff = cptd - xptd; if xptd.shape == ():; diff_str = f""{float(diff):.{digits1}f}""; message = """"""\t{}: computed value ({}) does not match ({}) {} by difference ({})."""""".format(; label, cptd_str, xptd_str, digits_str, diff_str; ); else:; diff[isclose] = 0.0; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()); with np.errstate(divide=""ignore"", invalid=""ignore""):; diffrel = np.divide(diff, xptd); np.nan_to_num(diffrel, copy=False); diffraw = cptd - xptd; digits_str += f"" (o-e: RMS {_rms(diffraw):.1e}, MAX {np.amax(np.absolute(diffraw)):.1e}, RMAX {np.amax(np.absolute(diffrel)):.1e})""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allcl",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6358,Integrability,message,messages,6358,")""; message = """"""\t{}: computed value does not match {}.\n Expected:\n{}\n Observed:\n{}\n Difference (passed elements are zeroed):\n{}\n"""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expecte",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6496,Integrability,message,message,6496,""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6664,Integrability,message,message,6664,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6733,Integrability,message,message,6733,"]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xp",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:7906,Integrability,message,message,7906,"tems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:8635,Integrability,message,message,8635," quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expecte",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:8773,Integrability,message,message,8773,"ual_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.all()). if allclose:; message = pass_message. else:; if xptd.shape == ():; xptd_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:8966,Integrability,message,message,8966,"d_str = f""{xptd}""; else:; xptd_str = np.array_str(xptd, max_line_width=120, precision=12, suppress_small=True); xptd_str = ""\n"".join("" "" + ln for ln in xptd_str.splitlines()). if cptd.shape == ():; cptd_str = f""{cptd}""; else:; cptd_str = np.array_str(cptd, max_line_width=120, precision=12, suppress_small=True); cptd_str = ""\n"".join("" "" + ln for ln in cptd_str.splitlines()). try:; diff = cptd - xptd; except TypeError:; diff_str = ""(n/a)""; else:; if xptd.shape == ():; diff_str = f""{diff}""; else:; diff_str = np.array_str(diff, max_line_width=120, precision=12, suppress_small=False); diff_str = ""\n"".join("" "" + ln for ln in diff_str.splitlines()). if xptd.shape == ():; message = """"""\t{}: computed value ({}) does not match ({}) by difference ({})."""""".format(; label, cptd_str, xptd_str, diff_str; ); else:; message = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = compu",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12158,Integrability,message,messages,12158," errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; computed: Union[Dict, BaseModel, ""ProtoModel""], # type: ignore; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12494,Integrability,message,message,12494,"r = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys());",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12679,Integrability,message,message,12679,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12748,Integrability,message,message,12748,"uple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; ph",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14260,Integrability,message,message,14260,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14300,Integrability,message,message,14300,"xpected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecul",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14322,Integrability,message,message,14322,"tol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['mol",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:14374,Integrability,message,message,14374,"al_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys()); else:; equal_phase = [(ep if ep.startswith(""root."") else ""root."" + ep) for ep in equal_phase]; phased = []. for nomatch in sorted(errors):; for ep in equal_phase or []:; if nomatch[0].startswith(ep):; if nomatch[0] not in n_errors:; phased.append(nomatch); errors.remove(nomatch). if forgive is None:; forgive = []; else:; forgive = [(fg if fg.startswith(""root."") else ""root."" + fg) for fg in forgive]; forgiven = []. for nomatch in sorted(errors):; for fg in forgive or []:; if nomatch[0].startswith(fg):; forgiven.append(nomatch); errors.remove(nomatch). ## print if verbose >= 2 if these functions had that knob; # forgiven_message = []; # for e in sorted(forgiven):; # forgiven_message.append(e[0]); # forgiven_message.append(""forgiven "" + e[1]); # pprint.pprint(forgiven). message = []; for e in sorted(errors):; message.append(e[0]); message.append("" "" + e[1]). ret_msg_str = ""\n"".join(message). return return_handler(len(ret_msg_str) == 0, label, ret_msg_str, return_message, quiet). [docs]; def compare_molrecs(; expected,; computed,; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive=None,; verbose: int = 1,; relative_geoms=""exact"",; return_message: bool = False,; return_handler: Callable = None,; ) -> bool:; """"""Function to compare Molecule dictionaries.""""""; # Need to manipulate the dictionaries a bit, so hold values; xptd = copy.deepcopy(expected); cptd = copy.deepcopy(computed). def massage_dicts(dicary):; # if 'fix_symmetry' in dicary:; # dicary['fix_symmetry'] = str(dicary['fix_symmetry']); # if 'units' in dicary:; # dicary['units'] = str(dicary['units']); if ""fragment_files"" in dicary:; dicary[""fragment_files""] = [str(f) for f in dicary[""fragment_files""]]; # and about int vs long errors; # if 'molecular_multiplicity' in dicary:; # dicary['molecular_multiplicity'] = int(dicary['molecular_multiplicity']); # if 'fragment_multiplicities' in",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:9701,Modifiability,extend,extend,9701,"ssage = """"""\t{}: computed value does not match.\n Expected:\n{}\n Observed:\n{}\n Difference:\n{}\n"""""".format(; label, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _compare_recursive(expected, computed, atol, rtol, _prefix=False, equal_phase=False):; errors = []; name = _prefix or ""root""; prefix = name + ""."". # Initial conversions if required; if isinstance(expected, BaseModel):; expected = expected.dict(). if isinstance(computed, BaseModel):; computed = computed.dict(). if isinstance(expected, (str, int, bool, complex)):; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, m",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:10304,Modifiability,extend,extend,10304,":; if expected != computed:; errors.append((name, ""Value {} did not match {}."".format(expected, computed))). elif isinstance(expected, (list, tuple)):; try:; if len(expected) != len(computed):; errors.append((name, ""Iterable lengths did not match"")); else:; for i, item1, item2 in zip(range(len(expected)), expected, computed):; errors.extend(; _compare_recursive(; item1, item2, _prefix=prefix + str(i), atol=atol, rtol=rtol, equal_phase=equal_phase; ); ); except TypeError:; errors.append((name, ""Expected computed to have a __len__()"")). elif isinstance(expected, dict):; expected_extra = computed.keys() - expected.keys(); computed_extra = expected.keys() - computed.keys(); if len(expected_extra):; errors.append((name, ""Found extra keys {}"".format(expected_extra))); if len(computed_extra):; errors.append((name, ""Missing keys {}"".format(computed_extra))). for k in expected.keys() & computed.keys():; name = prefix + str(k); errors.extend(; _compare_recursive(; expected[k], computed[k], _prefix=name, atol=atol, rtol=rtol, equal_phase=equal_phase; ); ). elif isinstance(expected, (float, np.number)):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, np.ndarray):; if np.issubdtype(expected.dtype, np.floating):; passfail, msg = compare_values(; expected, computed, atol=atol, rtol=rtol, equal_phase=equal_phase, return_message=True, quiet=True; ); else:; passfail, msg = compare(expected, computed, equal_phase=equal_phase, return_message=True, quiet=True); if not passfail:; errors.append((name, ""Arrays differ."" + msg)). elif isinstance(expected, type(None)):; if expected is not computed:; errors.append((name, ""'None' does not match."")). else:; errors.append((name, f""Type {type(expected)} not understood -- stopping recursive compare."")). return errors. [docs]; def compare_recursive(; expected: Union[Dict, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:15,Testability,test,testing,15,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:109,Testability,test,testing,109,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:146,Testability,test,testing,146,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:175,Testability,log,logging,175,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:665,Testability,log,log,665,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:703,Testability,log,logging,703,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:748,Testability,log,logging,748,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:787,Testability,log,logging,787,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:972,Testability,test,test,972,". qcelemental.testing. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2138,Testability,log,log,2138,"array],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2498,Testability,log,logging,2498," element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_han",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:2573,Testability,test,testing,2573,"t array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.allclose`.; * For scalar float-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; float-comparable types. For mixed types, use :py:func:`compare_recursive`.; * Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. if passnone:; if expected is None and computed is None:; return return_handler(True, label, pass_message, return_message, quiet). if np.iscomplexobj(expected):; dtype = np.complex; else:; dtype = float. try:; xptd, cptd = np.array(expected, dtype=dtype), np.array(computed, dtype=dtype); except Exception:; return return_handler(; False, label, f""""""\t{label}: inputs not cast-able to ndarray of {dtype}."""""", ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6481,Testability,log,log,6481,""""".format(; label, digits_str, xptd_str, cptd_str, diff_str; ). return return_handler(allclose, label, message, return_message, quiet). def _rms(arr: np.ndarray) -> float:; return np.sqrt(np.mean(np.square(arr))). [docs]; def compare(; expected: Union[int, bool, str, List[int], np.ndarray],; computed: Union[int, bool, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6824,Testability,log,logging,6824,"ol, str, List[int], np.ndarray],; label: str = None,; *,; equal_phase: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:6899,Testability,test,testing,6899,"uiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two integers, strings, booleans, or integer arrays are element-wise equal. Parameters; ----------; expected; int, bool, str or array-like of same.; Reference value against which `computed` is compared.; computed; int, bool, str or array-like of same.; Input value to compare against `expected`.; label; Label for passed and error messages. Defaults to calling function name.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal; False otherwise.; message : str; When return_message=True, also return passed or error message. Other Parameters; ----------------; return_handler; Function to control printing, logging, raising, and returning.; Specialized interception for interfacing testing systems. Notes; -----; * Akin to :func:`numpy.array_equal`.; * For scalar exactly-comparable types and for arbitrary-dimension, np.ndarray-castable, uniform-type,; exactly-comparable types. For mixed types, use :py:func:`compare_recursive`. """"""; label = label or sys._getframe().f_back.f_code.co_name; pass_message = f""\t{label:.<66}PASSED""; if return_handler is None:; return_handler = _handle_return. try:; xptd, cptd = np.array(expected), np.array(computed); except Exception:; return return_handler(False, label, f""""""\t{label}: inputs not cast-able to ndarray."""""", return_message, quiet). if xptd.shape != cptd.shape:; return return_handler(; False,; label,; f""""""\t{label}: computed shape ({cptd.shape}) does not match ({xptd.shape})."""""",; return_message,; quiet,; ). isclose = np.asarray(xptd == cptd); allclose = bool(isclose.all()). if not allclose and equal_phase:; try:; n_isclose = np.asarray(xptd == -cptd); except TypeError:; pass; else:; allclose = bool(n_isclose.al",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:12479,Testability,log,log,12479,"r = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; forgive: List[str] = None,; equal_phase: Union[bool, List] = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""; Recursively compares nested structures such as dictionaries and lists. Parameters; ----------; expected; Reference value against which `computed` is compared.; Dict may be of any depth but should contain Plain Old Data.; computed; Input value to compare against `expected`.; Dict may be of any depth but should contain Plain Old Data.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; equal_phase; Compare computed *or its opposite* as equal.; quiet; Whether to log the return message.; return_message; Whether to return tuple. See below. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise.; message : str; When return_message=True, also return passed or error message. Notes; -----. .. code-block:: python. absolute(computed - expected) <= (atol + rtol * absolute(expected)). """"""; label = label or sys._getframe().f_back.f_code.co_name; if atol >= 1:; raise ValueError(; ""Prior to v0.4.0, ``compare_recursive`` used to 10**-atol any atol >=1. That has ceased, so please express your atol literally.""; ); if return_handler is None:; return_handler = _handle_return. errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol). if errors and equal_phase:; n_errors = _compare_recursive(expected, computed, atol=atol, rtol=rtol, equal_phase=True); n_errors = dict(n_errors). if equal_phase is False:; equal_phase = []; elif equal_phase is True:; equal_phase = list(dict(errors).keys());",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:17429,Testability,test,testing,17429,"rs""] = [(s if s is None else int(s)) for s in dicary[""fragment_separators""]]; # forgive generator version changes; if ""provenance"" in dicary:; dicary[""provenance""].pop(""version""); # regularize connectivity ordering; if ""connectivity"" in dicary:; conn = [(min(at1, at2), max(at1, at2), bo) for (at1, at2, bo) in dicary[""connectivity""]]; conn.sort(key=lambda tup: tup[0]); dicary[""connectivity""] = conn. return dicary. xptd = massage_dicts(xptd); cptd = massage_dicts(cptd). if relative_geoms == ""exact"":; pass; elif relative_geoms == ""align"":; # can't just expect geometries to match, so we'll align them, check that; # they overlap and that the translation/rotation arrays jibe with; # fix_com/orientation, then attach the oriented geom to computed before the; # recursive dict comparison.; from .molutil.align import B787. cgeom = np.array(cptd[""geom""]).reshape((-1, 3)); rgeom = np.array(xptd[""geom""]).reshape((-1, 3)); rmsd, mill = B787(; rgeom=rgeom,; cgeom=cgeom,; runiq=None,; cuniq=None,; atoms_map=True,; mols_align=True,; run_mirror=False,; verbose=0,; ); if cptd[""fix_com""]:; return compare(; True,; np.allclose(np.zeros((3)), mill.shift, atol=atol),; ""null shift"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); if cptd[""fix_orientation""]:; return compare(; True,; np.allclose(np.identity(3), mill.rotation, atol=atol),; ""null rotation"",; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ); ageom = mill.align_coordinates(cgeom); cptd[""geom""] = ageom.reshape((-1)). return compare_recursive(; xptd,; cptd,; atol=atol,; rtol=rtol,; label=label,; forgive=forgive,; quiet=(verbose == 0),; return_message=return_message,; return_handler=return_handler,; ). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; qcelemental.testing.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/qcelemental/testing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1560,Deployability,integrat,integrated,1560,"License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:8129,Deployability,update,updated,8129,"needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta2 = { # CCSD(T) - CCSD; 'wfn': kwargs.pop('delta2_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta2_wfn_lesser', 'ccsd'),; 'basis': kwargs.pop('delta2_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta2_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta3 = { # CCSDT - CCSD(T); 'wfn': kwargs.pop('delta3_wfn', 'ccsdt'),; 'wfn_lesser': kwargs.pop('delta3_wfn_lesser', 'ccsd(t)'),; 'basis': kwargs.pop('delta3_basis', 'cc-pVTZ'),; 'scheme': kwargs.pop('delta3_scheme', 'xtpl_highest_1'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta4 = { # CCSDT(Q) - CCSDT; 'wfn': kwargs.pop('delta4_wfn', 'ccsdt(q)'),; 'wfn_lesser': kwargs.pop('delta4_wfn_lesser', 'ccsdt'),; 'basis': kwargs.pop('delta4_basis', 'cc-pVDZ'),; 'scheme': kwargs.pop('delta4_scheme', 'xtpl_highest_1'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }. return [scf, corl, delta, delta2, delta3, delta4]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.aliases.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1583,Energy Efficiency,energy,energy,1583,"License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:2948,Energy Efficiency,energy,energy,2948,"aram filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3275,Energy Efficiency,energy,energy,3275,"open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3312,Energy Efficiency,energy,energy,3312,"open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:5447,Energy Efficiency,energy,energy,5447,"etadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:5484,Energy Efficiency,energy,energy,5484,"etadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:5536,Energy Efficiency,energy,energy,5536,"1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""q",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:5590,Energy Efficiency,energy,energy,5590,"1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""q",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1138,Integrability,wrap,wrappers,1138,"code for psi4.driver.aliases; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>>",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1560,Integrability,integrat,integrated,1560,"License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in rang",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1598,Integrability,rout,routines,1598,"uted in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:2858,Integrability,wrap,wrapper,2858,". .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis':",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:4609,Integrability,wrap,wrapper,4609,"sis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:4959,Integrability,wrap,wrapper,4959,"ions': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:5895,Integrability,interface,interface,5895,"s. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; del",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:2956,Performance,perform,performed,2956,"aram filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3383,Performance,optimiz,optimization,3383,"olecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3401,Performance,optimiz,optimize,3401,"olecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3474,Performance,optimiz,optimization,3474,"n range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3553,Performance,optimiz,optimize,3553,"n range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:4828,Performance,perform,performed,4828," {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which do",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:6063,Safety,safe,safe,6063,"s. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; del",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:6179,Testability,log,logic,6179,"xt{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'ccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; 'options': {""qc_module"": ""mrcc""},; 'options_lo': {""qc_module"": ""mrcc""},; }; delta2 = { # CCSD(T) - CCSD; 'wfn': kwargs.pop('delta2_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta2_wfn_lesser', 'ccsd'),; 'basis': kwargs.pop('delta2_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta2_scheme', 'corl_xtpl_helgaker_2'),;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1247,Usability,simpl,simple,1247,"tware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:3407,Availability,avail,available,3407,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:7299,Deployability,install,installed,7299,"MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:10302,Deployability,update,updated,10302,"xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.einsum('xd,d', xpows, dvals). # Make / display the plot; plt.plot(xpts, fit2, 'b', linewidth=2.5, label='Harmonic (quadratic) fit'); plt.plot(xpts, fit4, 'g', linewidth=2.5, label='Anharmonic (quartic) fit'); plt.plot([re, re], [minE, maxE], 'b--', linewidth=0.5); plt.plot([r0, r0], [minE, maxE], 'g--', linewidth=0.5); plt.scatter(rvals, energies, c='Black', linewidth=3, label='Input Data'); plt.legend(). plt.xlabel('Bond length (Angstroms)'); plt.ylabel('Energy (Eh)'); plt.xlim(minR, maxR); plt.ylim(minE, maxE); if plot_fit == 'screen':; plt.show(); else:; plt.savefig(plot_fit); core.print_out(""\n\tPES fit saved to %s.\n\n"" % plot_fit). core.print_out(""\nre = %10.6f A check: %10.6f\n"" % (re, recheck)); core.print_out(""r0 = %10.6f A\n"" % r0); core.print_out(""E at re = %17.10f Eh\n"" % e); core.print_out(""we = %10.4f cm-1\n"" % we); core.print_out(""wexe = %10.4f cm-1\n"" % wexe); core.print_out(""nu = %10.4f cm-1\n"" % nu); core.print_out(""ZPVE(we) = %10.4f cm-1\n"" % zpve_we); core.print_out(""ZPVE(nu) = %10.4f cm-1\n"" % zpve_nu); core.print_out(""Be = %10.4f cm-1\n"" % B); core.print_out(""B0 = %10.4f cm-1\n"" % B0); core.print_out(""ae = %10.4f cm-1\n"" % ae); core.print_out(""De = %10.7f cm-1\n"" % de); results = {; ""re"" : re,; ""r0"" : r0,; ""we"" : we,; ""wexe"" : wexe,; ""nu"" : nu,; ""E(re)"" : e,; ""ZPVE(harmonic)"" : zpve_we,; ""ZPVE(anharmonic)"" : zpve_nu,; ""Be"" : B,; ""B0"" : B0,; ""ae"" : ae,; ""De"" : de; }; return results. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.diatomic.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:2406,Energy Efficiency,energy,energy,2406,"float,; no_factorials: bool = True,; weighted: bool = True,; polynomial_order: int = 4,; ):; """"""Performs an unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:2544,Energy Efficiency,energy,energy,2544,"ed order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:3374,Energy Efficiency,energy,energy,3374,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:5658,Energy Efficiency,energy,energy,5658,"ule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:5788,Energy Efficiency,energy,energy,5788,"ergies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (pl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:7563,Energy Efficiency,energy,energy,7563,"meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:7691,Energy Efficiency,energy,energy,7691,"((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:5508,Performance,optimiz,optimization,5508,"t_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:38951,Availability,avail,available,38951,"-- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:39919,Availability,checkpoint,checkpoint,39919," if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:56572,Availability,avail,available,56572," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an op",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63376,Availability,avail,available,63376,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63837,Availability,avail,available,63837,"p_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-----------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:74893,Availability,error,error,74893,"np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:75427,Availability,failure,failure,75427,"ng to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84644,Availability,avail,available,84644,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84705,Availability,avail,available,84705,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:85173,Availability,avail,available,85173,"ates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:85289,Availability,avail,availability,85289,"gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:86002,Availability,avail,available,86002,"``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:87100,Availability,avail,available,87100,"printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perfo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:93621,Availability,checkpoint,checkpoint,93621,"den_normal_modes""; with open(filename, 'w') as handle:; handle.write(qcdb.vib.print_molden_vibs(vibinfo, symbols, geom, standalone=True)). return vibinfo. [docs]; def gdma(wfn, datafile=""""):; """"""Function to use wavefunction information in *wfn* and, if specified,; additional commands in *filename* to run GDMA analysis. .. versionadded:: 0.6. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate DMA analysis. :type datafile: str; :param datafile: optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by :term:`WRITER_FILE_LABEL <WRITER_FILE_LABEL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.wri",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:21222,Deployability,configurat,configuration,21222,"les :ref:`[manual] <sec:cc>` :ref:`[details] <dd_bccd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+--------------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:22507,Deployability,configurat,configuration,22507,"ISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_fci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | gaussian-2, g2 | Gaussian-2 composite method :ref:`[manual] <sec:fnogn>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:49834,Deployability,configurat,configurational,49834,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53693,Deployability,install,installing,53693," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53715,Deployability,install,install,53715," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53757,Deployability,install,install,53757," driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:72105,Deployability,update,update,72105,"; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:74425,Deployability,update,update,74425,"local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, fai",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:90766,Deployability,update,update,90766,"g to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:91507,Deployability,update,update,91507,"ss(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, ind",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:104085,Deployability,update,updated,104085,"; >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:2990,Energy Efficiency,energy,energy,2990,"ger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3067,Energy Efficiency,energy,energy,3067,"ger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3117,Energy Efficiency,energy,energy,3117,"):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3167,Energy Efficiency,energy,energy,3167,"rn whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn con",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3239,Energy Efficiency,energy,energy,3239," coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3985,Energy Efficiency,energy,energy,3985,"ced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless |PSIfour| is called with `-m` flag. :type restart_file: str; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+============================================================================",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:25358,Energy Efficiency,adapt,adapted,25358,-----------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-scf | (with CheMPS2) density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | (with CheMPS2) density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-ci | (with CheMPS2) density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sf-sapt | 0th-order spin-flip SAPT :ref:`[manual] <sec:sfsapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt(dft) | 0th-order SAPT upo,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:29920,Energy Efficiency,charge,charge,29920,-------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(ccd)dmp2 | SAPT2+ with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(3)(ccd)dmp2 | SAPT2+(3) with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+3(ccd)dmp2 | SAPT2+3 with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0-ct | 0th-order SAPT plus charge transfer (CT) calculation :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2-ct | SAPT2 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+-ct | SAPT2+ plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+(3)-ct | SAPT2+(3) plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt2+3-ct | SAPT2+3 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+--,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:35193,Energy Efficiency,energy,energy,35193,"---------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:35425,Energy Efficiency,energy,energy,35425,"---------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:35492,Energy Efficiency,energy,energy,35492,"CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:35809,Energy Efficiency,energy,energy,35809,"--------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nSc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:35927,Energy Efficiency,energy,energy,35927,"om-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.po",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36119,Energy Efficiency,energy,energy,36119,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36156,Energy Efficiency,energy,energy,36156,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36264,Energy Efficiency,energy,energy,36264," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _fil",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36512,Energy Efficiency,energy,energy,36512,">> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we plannin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:37260,Energy Efficiency,energy,energy,37260,"s; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:37547,Energy Efficiency,energy,energy,37547,", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:38116,Energy Efficiency,energy,energy,38116,"-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:38192,Energy Efficiency,energy,energy,38192,"l.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40364,Energy Efficiency,energy,energy,40364,"int_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40662,Energy Efficiency,energy,energy,40662," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40744,Energy Efficiency,energy,energy,40744,"ot item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.drive",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40818,Energy Efficiency,energy,energy,40818,"lenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :re",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40974,Energy Efficiency,energy,energy,40974,"ct(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40996,Energy Efficiency,energy,energy,40996," psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44341,Energy Efficiency,energy,energy,44341," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53870,Energy Efficiency,energy,energy,53870,"ption('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:54802,Energy Efficiency,energy,energy,54802," class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60520,Energy Efficiency,energy,energy,60520,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61041,Energy Efficiency,energy,energy,61041,"tep_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61148,Energy Efficiency,energy,energy,61148,"mizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61660,Energy Efficiency,energy,energy,61660,"d return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the Ge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62038,Energy Efficiency,energy,energy,62038,"oat* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62902,Energy Efficiency,energy,energy,62902,"rn_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in th",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63041,Energy Efficiency,energy,energy,63041,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63334,Energy Efficiency,energy,energy,63334,"ype engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63924,Energy Efficiency,energy,energy,63924,"dicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-------------------------+-------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69392,Energy Efficiency,energy,energy,69392,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69454,Energy Efficiency,energy,energy,69454,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:73607,Energy Efficiency,energy,energy,73607," are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Pr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:76156,Energy Efficiency,energy,energy,76156,"_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('O",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:80725,Energy Efficiency,energy,energy,80725,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82170,Energy Efficiency,energy,energy,82170,"on_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibratio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82369,Energy Efficiency,energy,energy,82369,"ranslations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82825,Energy Efficiency,energy,energy,82825,"'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82937,Energy Efficiency,energy,energy,82937,"ormat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:83272,Energy Efficiency,energy,energy,83272,"(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:83356,Energy Efficiency,energy,energy,83356,"rgy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nest",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:83954,Energy Efficiency,energy,energy,83954,"GY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrd",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84142,Energy Efficiency,energy,energy,84142,"ef frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84281,Energy Efficiency,energy,energy,84281,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84602,Energy Efficiency,energy,energy,84602,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=====",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:91490,Energy Efficiency,energy,energy,91490,".asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:96202,Energy Efficiency,energy,energy,96202,"hk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFM",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:97967,Energy Efficiency,energy,energy,97967,"currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! met",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:98326,Energy Efficiency,energy,energy,98326,"fn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:98520,Energy Efficiency,reduce,reduced,98520,"efwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:99461,Energy Efficiency,energy,energy,99461,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:99929,Energy Efficiency,energy,energy,99929,":; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbital",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:100916,Energy Efficiency,energy,energy,100916,"n addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:101491,Energy Efficiency,energy,energy,101491,"nsity_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_V",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:101864,Energy Efficiency,energy,energy,101864,"DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:1966,Integrability,wrap,wrappers,1966,"ee Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'."")",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36665,Integrability,interface,interface,36665,"ci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:42787,Integrability,wrap,wrapper,42787,"psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44285,Integrability,depend,dependent,44285," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:56609,Integrability,interface,interface,56609," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an op",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:72671,Integrability,depend,dependent,72671,"t_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_da",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:73083,Integrability,depend,dependent,73083,"v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.he",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:78742,Integrability,wrap,wrapper,78742,"atrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; ## First half of this fn -- entry means user wants a 2nd derivative by any means. kwargs = p4util.kwargs_lower(kwargs); basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowernam",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:80669,Integrability,depend,dependent,80669,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3299,Modifiability,variab,variables,3299,"adient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Tur",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:21222,Modifiability,config,configuration,21222,"les :ref:`[manual] <sec:cc>` :ref:`[details] <dd_bccd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+--------------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:22507,Modifiability,config,configuration,22507,"ISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_fci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | gaussian-2, g2 | Gaussian-2 composite method :ref:`[manual] <sec:fnogn>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:25358,Modifiability,adapt,adapted,25358,-----------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-scf | (with CheMPS2) density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | (with CheMPS2) density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | dmrg-ci | (with CheMPS2) density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sf-sapt | 0th-order spin-flip SAPT :ref:`[manual] <sec:sfsapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sapt(dft) | 0th-order SAPT upo,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:32567,Modifiability,extend,extended,32567,"plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC), deprecated :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(1) | (with ADCC) 1st-order algebraic diagrammatic construction (ADC) :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2) | (with ADCC) 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2)-x | (with ADCC) extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(3) | (with ADCC) 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(1) | (with ADCC) core-valence separation (CVS) 1st-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2) | (with ADCC) CVS 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2)-x | (with ADCC) CVS extended 2nd-order A",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:33552,Modifiability,extend,extended,33552,with ADCC) extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(3) | (with ADCC) 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(1) | (with ADCC) core-valence separation (CVS) 1st-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2) | (with ADCC) CVS 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2)-x | (with ADCC) CVS extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(3) | (with ADCC) CVS 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ep2 | 2nd-order electron propagator theory |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+-------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40760,Modifiability,variab,variable,40760,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:41574,Modifiability,variab,variable,41574,"EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:41627,Modifiability,variab,variable,41627,")); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the m",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:45240,Modifiability,variab,variable,45240," derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:49834,Modifiability,config,configurational,49834,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53266,Modifiability,variab,variable,53266,"turn plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.b",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53368,Modifiability,variab,variable,53368,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53421,Modifiability,variab,variable,53421,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:54765,Modifiability,variab,variable,54765," class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61367,Modifiability,variab,variables,61367,"'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:73805,Modifiability,variab,variable,73805,"ption(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); exce",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:75946,Modifiability,variab,variables,75946,"= 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Op",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:87808,Modifiability,variab,variable,87808,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull inform",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:87861,Modifiability,variab,variable,87861,"= kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:88288,Modifiability,variab,variables,88288,"otations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhes",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:89338,Modifiability,variab,variables,89338,". Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impost",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:91447,Modifiability,variab,variable,91447,"y()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:97928,Modifiability,variab,variable,97928,"currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! met",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:1203,Performance,optimiz,optimizations,1203,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and syst",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:11508,Performance,optimiz,optimized,11508,--------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order |MollerPlesset| (MP) perturbation theory :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+------------------------------------------------------------------------------------------------------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:12268,Performance,optimiz,optimized,12268,tails] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:13029,Performance,optimiz,optimized,13029,"in-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccsd, cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_lccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccsd, fno-cepa(0) | CEPA(0) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_cepa_pr1_pr>` |; +-------------------------+--------------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:16767,Performance,optimiz,optimized,16767,-----------+---------------------------------------------------------------------------------------------------------------------------------------+; | qcisd | quadratic CI singles doubles (QCISD) :ref:`[manual] <sec:fnocc>` :ref:`[details] <dd_qcisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-qcisd | QCISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | remp2 | 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_remp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc2 | approxi,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:17517,Performance,optimiz,optimized,17517,ef:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_remp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_ccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+--------------------------------------------------------------------------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36217,Performance,perform,perform,36217," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _fil",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:36319,Performance,perform,perform,36319,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_glob",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:41747,Performance,optimiz,optimize,41747," {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); mole",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44734,Performance,perform,perform,44734,"rname, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:47733,Performance,optimiz,optimized,47733,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:48067,Performance,optimiz,optimized,48067,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:48402,Performance,optimiz,optimized,48402,"----------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+--------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:48696,Performance,optimiz,optimized,48696,"--------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+---",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57521,Performance,optimiz,optimizer,57521,"lueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57558,Performance,optimiz,optimize,57558,"e not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Conver",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57600,Performance,optimiz,optimizer,57600,"Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Conver",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57622,Performance,optimiz,optimize,57622,", CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.C",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57748,Performance,optimiz,optimizer,57748,"em; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n -----------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57777,Performance,optimiz,optimizer,57777,"('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n ------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:57820,Performance,optimiz,optimizer,57820," {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). cor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:58828,Performance,optimiz,optimizer,58828,"mizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:58853,Performance,optimiz,optimizer,58853,"_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:58976,Performance,optimiz,optimizer,58976,"ms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59005,Performance,optimiz,optimize,59005,"in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59100,Performance,optimiz,optimizer,59100,"rked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59129,Performance,optimiz,optimize,59129," ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.appe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59225,Performance,optimiz,optimizer,59225,"---------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59243,Performance,optimiz,optimizer,59243,"------------ ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Ma",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59272,Performance,optimiz,optimizer,59272,"print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimize",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59311,Performance,optimiz,optimizer,59311,"lta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_g",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59360,Performance,optimiz,optimize,59360,"(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59384,Performance,optimiz,optimizer,59384,"--------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Ene",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59397,Performance,optimiz,optimizer,59397,"-------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59443,Performance,optimiz,optimizer,59443,"---------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59457,Performance,optimiz,optimizer,59457,"-- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59774,Performance,optimiz,optimizer,59774,"------------------------------ ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59799,Performance,optimiz,optimizer,59799,"---- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59824,Performance,optimiz,optimizer,59824,"\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not retur",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:59836,Performance,optimiz,optimizer,59836,"eration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60025,Performance,optimiz,optimizer,60025,"NVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Tot",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60086,Performance,optimiz,optimizer,60086,"); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60160,Performance,optimiz,optimizer,60160,"re.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60209,Performance,optimiz,optimizer,60209,"erge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :ra",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60260,Performance,optimiz,optimizer,60260,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceEr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60906,Performance,optimiz,optimize,60906,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60949,Performance,perform,perform,60949,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60968,Performance,optimiz,optimization,60968,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61051,Performance,optimiz,optimized,61051,"tep_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62280,Performance,optimiz,optimization,62280,"iver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62386,Performance,optimiz,optimization,62386," :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62457,Performance,optimiz,optimizer,62457," :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62601,Performance,optimiz,optimizers,62601,"he computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational metho",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62672,Performance,optimiz,optimizer,62672,"`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62700,Performance,optimiz,optimization,62700,"`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:62963,Performance,perform,performed,62963,"`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63069,Performance,perform,performs,63069,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63409,Performance,optimiz,optimization,63409,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63431,Performance,perform,performed,63431,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63568,Performance,perform,perform,63568,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63618,Performance,optimiz,optimization,63618,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:64316,Performance,optimiz,optimizations,64316,r all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_b3lyp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_hf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dct | density cumulant (functional) theory :ref:`[manual] <sec:dct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+-------------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:65956,Performance,optimiz,optimized,65956,------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+-------------------------------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:66219,Performance,optimiz,optimized,66219,------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+-------------------------------------------,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:66483,Performance,optimiz,optimized,66483,on theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` :r,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:66720,Performance,optimiz,optimized,66720,,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:67179,Performance,optimiz,optimized,67179,,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:68739,Performance,optimiz,optimization,68739,"d>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:68757,Performance,optimiz,optimize,68757,"d>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:68805,Performance,optimiz,optimization,68805,"----------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.po",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:68966,Performance,perform,perform,68966,"sd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69013,Performance,optimiz,optimize,69013,"sd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69074,Performance,perform,perform,69074,"------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__ca",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69267,Performance,optimiz,optimize,69267,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', Fals",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69420,Performance,optimiz,optimization,69420,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69504,Performance,optimiz,optimization,69504,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69591,Performance,optimiz,optimization,69591,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:69625,Performance,optimiz,optimize,69625,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:70602,Performance,optimiz,optimize,70602,"ion step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well teste",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:71556,Performance,optimiz,optimization,71556,"('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmet",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:71772,Performance,load,load,71772," 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slight",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:71855,Performance,optimiz,optimization,71855,"vided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERAN",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:73336,Performance,optimiz,optimize,73336,"ore.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_wi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:74505,Performance,optimiz,optimizing,74505,"he gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:75727,Performance,optimiz,optimized,75727,"s molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:75923,Performance,optimiz,optimized,75923,"= 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Op",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:76023,Performance,optimiz,optimize,76023,"ing resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.updat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:76411,Performance,optimiz,optimize,76411,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:77342,Performance,optimiz,optimization,77342,"story.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]; def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:77530,Performance,optimiz,optimization,77530,"RITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]; def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; ## First half of this fn -- entry means user wants a 2nd derivative by any means. kwargs = p4util.kwargs_lower(kwargs); basisstash = p4util.OptionsS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82006,Performance,perform,perform,82006,"ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84203,Performance,perform,performed,84203,". :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and U",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84309,Performance,perform,performs,84309,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84759,Performance,perform,performed,84759,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:86629,Performance,optimiz,optimize,86629,"========================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:88134,Performance,perform,perform,88134,"ally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dicti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:96038,Performance,optimiz,optimized,96038,"on in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:97730,Performance,optimiz,optimized,97730," This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:103839,Performance,optimiz,optimize,103839,"; >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40981,Safety,safe,safer,40981,"ct(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:99452,Safety,detect,detected,99452,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63011,Security,access,accesses,63011,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:76395,Security,validat,validated,76395,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84020,Security,access,accessed,84020,"write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:84251,Security,access,accesses,84251,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:1358,Testability,log,logging,1358,"uded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pull",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:1416,Testability,log,logging,1416,"uded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pull",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:2002,Testability,log,logger,2002," Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:2011,Testability,log,logging,2011," Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:34962,Testability,test,tested,34962,"-------------------------------------------------+; | ep2 | 2nd-order electron propagator theory |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc2 | equation of motion (EOM) CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-ccsd | EOM-CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment custom-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:37588,Testability,log,logger,37588,", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:37617,Testability,log,logger,37617,"il.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restar",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40342,Testability,log,logger,40342,"'SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wave",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40557,Testability,log,logger,40557,"i_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavef",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40723,Testability,log,logger,40723," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:43766,Testability,log,logger,43766,"ule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:43797,Testability,log,logger,43797,"rapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44321,Testability,test,test,44321," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44816,Testability,log,logger,44816,"er.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:45033,Testability,log,logger,45033,"esults(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +========",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:45201,Testability,log,logger,45201,"_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===========================================================",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:45271,Testability,log,logger,45271," derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:52043,Testability,log,logger,52043,":examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(args[0]). _filter_renamed_methods(""properties"", lowername). props = kwargs.get('properties', ['dipole', 'quadrupole']); if len(args) > 1:; props += args[1:]; kwargs['properties'] = p4util.drop_duplicates(props). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else mo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:52076,Testability,log,logger,52076,"n; >>> properties('cc2', properties=['rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(args[0]). _filter_renamed_methods(""properties"", lowername). props = kwargs.get('properties', ['dipole', 'quadrupole']); if len(args) > 1:; props += args[1:]; kwargs['properties'] = p4util.drop_duplicates(props). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:52836,Testability,log,logger,52836,"get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""properties"", lowername, molecule, **kwargs); logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.En",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53055,Testability,log,logger,53055,"logger.debug('PROPERTIES PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53225,Testability,log,logger,53225,"rn plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).ca",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:71595,Testability,test,tested,71595,"('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmet",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:79985,Testability,log,logger,79985,"ption(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradien",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:80015,Testability,log,logger,80015,"size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwar",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:80705,Testability,test,test,80705,"chem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername},",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:81670,Testability,log,logger,81670,"endent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util.negotiate_convergence_criterion((2, 2), lowername, return_optstash=True). # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:81886,Testability,log,logger,81886,"ary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; tmpkwargs = copy.deepcopy(kwargs); tmpkwargs.pop('dertype', None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82133,Testability,log,logger,82133,", None); G0 = gradient(lowername, molecule=molecule, **tmpkwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82183,Testability,log,logger,82183,"on_sound, rotations_projection_sound = _energy_is_invariant(G0.rms()); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # We have the desired method. Do it.; logger.info(f""Compute hessian(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibratio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:63599,Usability,guid,guide,63599,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:3017,Availability,redundant,redundant,3017,"rmat (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:4234,Availability,avail,available,4234,"D/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:4460,Availability,avail,available,4460,"---; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.drive",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:10217,Availability,avail,available,10217,"pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List[str]) -> str:; """"""Function to re-form a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; str; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in othe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:27193,Availability,avail,available,27193,"s``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :para",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:27236,Availability,avail,available,27236,"orl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:32924,Availability,avail,available,32924,"lied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_sc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:44586,Availability,redundant,redundant,44586,"tadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], delta[""alpha""], NEED, -1,; 0.0, None, None, None, None; ]))). # MODELCHEM is unordered, possibly redundant list of single result *entries* needed to satisfy full CBS; # JOBS is subset of MODELCHEM with minimal list of single result *jobs* needed to satisfy full CBS; # TROVE is superset of JOBS with maximal list of single result *entries* resulting from JOBS; # ""entry"" here is a mtd-bas-opt spec that can support E/G/H data; # ""job"" here is an entry on which to sic Psi4 that, through VARH, may fill in multiple entries. MODELCHEM = []; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; MODELCHEM.append(lvl). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:16129,Deployability,update,update,16129,"bccd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['cisd'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisd': 'CISD TOTAL ENERGY'}; VARH['cisdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdt': 'CISDT TOTAL ENERGY'}; VARH['cisdtq'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdtq': 'CISDTQ TOTAL ENERGY'}; VARH['fci'] = {; 'hf': 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['ccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY'}; VARH['ccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY',; 'ccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]; def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:40675,Deployability,update,updated,40675,"c: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we ar",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:49090,Deployability,update,update,49090," == job['f_wfn']) or (lvl['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl['f_basis'] == job['f_basis']) and (lvl['f_options'] == job['f_options'])):; lvl['f_energy'] = job['f_energy']; lvl['f_gradient'] = job['f_gradient']; lvl['f_hessian'] = job['f_hessian']; lvl['f_dipole'] = job['f_dipole']; lvl['f_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is not None for lmh in stage['d_need'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if fina",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:49387,Deployability,update,update,49387,"_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is not None for lmh in stage['d_need'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:49699,Deployability,update,update,49699,"eed'].values()]); hess_available = all([lmh['f_hessian'] is not None for lmh in stage['d_need'].values()]); dipole_available = all([lmh['f_dipole'] is not None for lmh in stage['d_need'].values()]); dipder_available = all([lmh['f_dipder'] is not None for lmh in stage['d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:49970,Deployability,update,update,49970,"d_need'].values()]). hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient' or grad_available:; if finalgradient is None:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tabl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:50246,Deployability,update,update,50246,"one:; finalgradient = np.zeros((nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalgradient += stage['d_gradient'] * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:62511,Deployability,update,updated,62511,"esults['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:1354,Energy Efficiency,energy,energy,1354,"ponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain composite method, basis, & options treatments. ========; CBS Flow; ========; Bullet points are major actions; Lines of dashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:2657,Energy Efficiency,energy,energy,2657,"ing into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:4589,Energy Efficiency,energy,energy,4589,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrou",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5966,Energy Efficiency,energy,energy,5966,"r; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:16480,Energy Efficiency,energy,energy,16480,": 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['ccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY'}; VARH['ccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY',; 'ccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]; def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_meta",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22060,Energy Efficiency,energy,energy,22060," sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a fiel",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22283,Energy Efficiency,energy,energy,22283,":; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22791,Energy Efficiency,energy,energy,22791,"""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22923,Energy Efficiency,energy,energy,22923,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22947,Energy Efficiency,energy,energy,22947,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22994,Energy Efficiency,energy,energy,22994,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:23399,Energy Efficiency,energy,energy,23399,"ariables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn key",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:23615,Energy Efficiency,energy,energy,23615," - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24196,Energy Efficiency,energy,energy,24196,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24420,Energy Efficiency,energy,energy,24420,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24458,Energy Efficiency,energy,energy,24458,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24744,Energy Efficiency,energy,energy,24744,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24784,Energy Efficiency,energy,energy,24784,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25001,Energy Efficiency,energy,energy,25001,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25064,Energy Efficiency,energy,energy,25064,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25211,Energy Efficiency,energy,energy,25211,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25274,Energy Efficiency,energy,energy,25274,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25403,Energy Efficiency,energy,energy,25403," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25473,Energy Efficiency,energy,energy,25473," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25627,Energy Efficiency,energy,energy,25627," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:25697,Energy Efficiency,energy,energy,25697," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:26066,Energy Efficiency,energy,energy,26066,"ection; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:26371,Energy Efficiency,energy,energy,26371," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:26616,Energy Efficiency,energy,energy,26616," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.drive",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:26870,Energy Efficiency,energy,energy,26870,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:26912,Energy Efficiency,energy,energy,26912,"|| ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:27441,Energy Efficiency,energy,energy,27441,"sis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:28318,Energy Efficiency,energy,energy,28318,"am scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :pa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:28894,Energy Efficiency,energy,energy,28894,_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type ,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:29480,Energy Efficiency,energy,energy,29480,"resent in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type scf_alpha: float; :param scf_alpha: |dl| ``1.63`` |dr|. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:31551,Energy Efficiency,energy,energy,31551,"driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33584,Energy Efficiency,energy,energy,33584,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33603,Energy Efficiency,energy,energy,33603,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33750,Energy Efficiency,energy,energy,33750,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33769,Energy Efficiency,energy,energy,33769,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33870,Energy Efficiency,energy,energy,33870,"of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33882,Energy Efficiency,energy,energy,33882,"of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34018,Energy Efficiency,energy,energy,34018,"od from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34054,Energy Efficiency,energy,energy,34054,"od from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34250,Energy Efficiency,energy,energy,34250,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34304,Energy Efficiency,energy,energy,34304,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34419,Energy Efficiency,energy,energy,34419,"e <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34737,Energy Efficiency,energy,energy,34737,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. #",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:34773,Energy Efficiency,energy,energy,34773,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. #",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:35179,Energy Efficiency,energy,energy,35179,"TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:40984,Energy Efficiency,energy,energy,40984,"list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:41407,Energy Efficiency,energy,energy,41407,"p/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:43262,Energy Efficiency,energy,energy,43262,"['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; stage['scheme'] = kwargs.pop('delta_scheme'); stage['stage'] = ""delta1""; stage['treatment'] = ""corl""; metadata.append(stage). cbs_kwargs[""cbs_metadata""] = metadata. return cbs_kwargs. def _build_cbs_compute(metameta: Dict[str, Any], metadata: CBSMetadata):; label = metameta['label']; ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n"". # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_alpha', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_dipole', 'd_dipder'; ]; GRAND_NEED = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], metadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:46065,Energy Efficiency,energy,energy,46065," JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if ((VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]); and (mc['f_basis'] == job['f_basis']); and not (mc['f_wfn'] == job['f_wfn']); and (mc['f_options'] == job['f_options'])):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Expand listings to all that will be obtained; TROVE = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; TROVE.append(dict(zip(_f_fields, [wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:50462,Energy Efficiency,energy,energy,50462," * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:50551,Energy Efficiency,energy,energy,50551," * stage['d_coef']. if ptype == 'hessian' or hess_available:; if finalhessian is None:; finalhessian = np.zeros((3 * nat, 3 * nat)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finalhessian += stage['d_hessian'] * stage['d_coef']. if dipole_available:; if finaldipole is None:; finaldipole = np.zeros((3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipole')); stage['d_dipole'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipole += stage['d_dipole'] * stage['d_coef']. if dipder_available:; if finaldipder is None:; finaldipder = np.zeros((3 * nat, 3)); hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_dipder')); stage['d_dipder'] = xtpl_procedures[stage['d_scheme']](**hiloargs); finaldipder += stage['d_dipder'] * stage['d_coef']. cbs_results = {; 'ret_ptype': {; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; }[ptype],; 'energy': finalenergy,; 'gradient': finalgradient,; 'hessian': finalhessian,; 'dipole': finaldipole,; 'dipole gradient': finaldipder,; }. return cbs_results, GRAND_NEED. def _summary_table(metadata, TROVE, GRAND_NEED) -> str:; """"""Build string of results table"""""". delimit = ' ' + '-' * 105 + '\n'; blckfmt = """"""\n ==> {} <==\n\n""""""; headfmt = """""" {:>6} {:>20} {:1} {:26} {:>3} {:>16} {}\n""""""; linefmt = """""" {:>6} {:>20} {:1} {:27} {:2} {:16.8f} {}\n"""""". tables = ''; tables += blckfmt.format('Components'); tables += delimit. required = []; finalenergy = 0.0; for stage in GRAND_NEED:; finalenergy += stage['d_energy'] * stage['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:56231,Energy Efficiency,energy,energy,56231,": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:56850,Energy Efficiency,energy,energy,56850,"s); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:57557,Energy Efficiency,energy,energy,57557,"; modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58818,Energy Efficiency,energy,energy,58818,"y data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:61524,Energy Efficiency,energy,energy,61524,"deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:31223,Integrability,interface,interface,31223,"_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculatin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:31400,Integrability,interface,interface,31400,"r| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:36416,Integrability,depend,dependent,36416,"z"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). try:; scheme.split(); except AttributeError:; raise UpgradeHelper(scheme, repr(scheme.__name__), 1.6, ' Replace extrapolation function with funct",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:39359,Integrability,wrap,wrapper,39359,"len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. def _parse_cbs_gufunc_string(method_name: str):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:41708,Integrability,wrap,wrapper,41708,"None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; sta",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:61004,Integrability,interface,interface,61004,"essian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22308,Modifiability,variab,variables,22308," stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:24237,Performance,perform,performed,24237,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:31029,Performance,perform,performed,31029,"bs_helper.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:35653,Performance,optimiz,optimize,35653," atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:35674,Performance,optimiz,optimize,35674," atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:36183,Performance,optimiz,optimize,36183,"all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszet",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:56636,Performance,load,load,56636,"= self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); an",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58830,Performance,load,load,58830,"(mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CB",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:3017,Safety,redund,redundant,3017,"rmat (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:41326,Safety,detect,detected,41326,"and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis']",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:44586,Safety,redund,redundant,44586,"tadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], delta[""alpha""], NEED, -1,; 0.0, None, None, None, None; ]))). # MODELCHEM is unordered, possibly redundant list of single result *entries* needed to satisfy full CBS; # JOBS is subset of MODELCHEM with minimal list of single result *jobs* needed to satisfy full CBS; # TROVE is superset of JOBS with maximal list of single result *entries* resulting from JOBS; # ""entry"" here is a mtd-bas-opt spec that can support E/G/H data; # ""job"" here is an entry on which to sic Psi4 that, through VARH, may fill in multiple entries. MODELCHEM = []; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; MODELCHEM.append(lvl). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:56378,Safety,avoid,avoid,56378,"elf, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:2293,Security,validat,validate,2293,"ashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5064,Security,validat,validator,5064,"s(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5124,Security,validat,validator,5124,"s(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:6775,Security,validat,validate,6775,"portal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` format. """"""; BSET = []; ZSET = []; legit_compo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17297,Security,validat,validates,17297,"ine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17672,Security,validat,validation,17672,"pl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:20024,Security,validat,validation,20024,"e[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:20230,Security,validat,validation,20230," stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:20384,Security,validat,validate,20384,"n(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:53721,Security,validat,validator,53721,"t.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]; class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:4998,Testability,log,logging,4998,"bs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy':",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5766,Testability,log,logger,5766," """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5775,Testability,log,logging,5775," """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:47157,Testability,log,logger,47157," enumerate(JOBS):; if ((VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]); and (mc['f_basis'] == job['f_basis']); and not (mc['f_wfn'] == job['f_wfn']); and (mc['f_options'] == job['f_options'])):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Expand listings to all that will be obtained; TROVE = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; TROVE.append(dict(zip(_f_fields, [wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). return GRAND_NEED, JOBS, TROVE. def _assemble_cbs_components(metameta, TROVE, GRAND_NEED):; """"""Absorb job E/G/H results from `TROVE` into `GRAND_NEED`. Process; those into stage E/G/H in `GRAND_NEED`, returning the latter.; Accumulate into final E/G/H quantities, returning them in dict. """"""; label = metameta['label']; nat = metameta['molecule'].natom(); ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions); logger.info(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; for job in TROVE:; # Don't ask; if (((lvl['f_wfn'] == job['f_wfn']) or; ((lvl['f_wfn'][3:] == job['f_wfn']) and lvl['f_wfn'].startswith('c4-')) or; ((lvl['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:47772,Testability,log,logger,47772,"wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). return GRAND_NEED, JOBS, TROVE. def _assemble_cbs_components(metameta, TROVE, GRAND_NEED):; """"""Absorb job E/G/H results from `TROVE` into `GRAND_NEED`. Process; those into stage E/G/H in `GRAND_NEED`, returning the latter.; Accumulate into final E/G/H quantities, returning them in dict. """"""; label = metameta['label']; nat = metameta['molecule'].natom(); ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions); logger.info(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].values():; for job in TROVE:; # Don't ask; if (((lvl['f_wfn'] == job['f_wfn']) or; ((lvl['f_wfn'][3:] == job['f_wfn']) and lvl['f_wfn'].startswith('c4-')) or; ((lvl['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4-')) or; (('c4-' + lvl['f_wfn']) == job['f_wfn']) or (lvl['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl['f_basis'] == job['f_basis']) and (lvl['f_options'] == job['f_options'])):; lvl['f_energy'] = job['f_energy']; lvl['f_gradient'] = job['f_gradient']; lvl['f_hessian'] = job['f_hessian']; lvl['f_dipole'] = job['f_dipole']; lvl['f_dipder'] = job['f_dipder']. # Make xtpl() call; finalenergy = 0.0; finalgradient = None; finalhessian = None; finaldipole = None; finaldipder = None. for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha'], 'verbose': verbose}. grad_available = all([lmh['f_gradient'] is no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:54134,Testability,log,logger,54134,"nstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:55380,Testability,log,logger,55380,"%; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:55833,Testability,log,logger,55833,"o""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; res",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58153,Testability,log,logger,58153,"ENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CB",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58386,Testability,log,logger,58386,"POLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58415,Testability,log,logger,58415,"; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58474,Testability,log,logger,58474,"T DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:60634,Testability,log,logger,60634,"""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:1717,Usability,simpl,simple,1717,"thout even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain composite method, basis, & options treatments. ========; CBS Flow; ========; Bullet points are major actions; Lines of dashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _con",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33530,Usability,simpl,simple,33530,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:33688,Usability,simpl,simple,33688,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:40272,Usability,simpl,simple,40272,"onError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:61300,Usability,simpl,simple,61300," 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].ite",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:22401,Deployability,configurat,configuration,22401," Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:22776,Deployability,update,updated,22776," Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:2530,Energy Efficiency,energy,energy,2530,"_). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:4561,Energy Efficiency,energy,energy,4561,"ing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.uppe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:6879,Energy Efficiency,power,power,6879," % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; --",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:8417,Energy Efficiency,power,power,8417,"larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:9279,Energy Efficiency,power,power,9279,"alueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:10100,Energy Efficiency,power,power,10100,"n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. Refe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:11866,Energy Efficiency,power,power,11866,"s; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_karton_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 6.30. # prior to April 2022, this wrong expression was used; # beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_division = 1 / (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cb",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:12727,Energy Efficiency,power,power,12727,"valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CB",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:14849,Energy Efficiency,energy,energy,14849,"the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" B",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:16741,Energy Efficiency,power,power,16741,"scheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:18898,Energy Efficiency,energy,energy,18898,"ionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:19912,Energy Efficiency,energy,energy-only,19912,"l_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:17331,Integrability,rout,routines,17331,"ay):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; ext",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:22449,Integrability,wrap,wrapper,22449," Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:22401,Modifiability,config,configuration,22401," Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_cbs_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:1422,Safety,safe,safe,1422," corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; from functools import partial; from typing import Callable, Optional, Union; import logging. import numpy as np. from psi4 import core; from psi4.driver.p4util.exceptions import ValidationError; nppp = partial(np.array_str, max_line_width=120, precision=8, suppress_small=True) # when safe, ""from psi4.driver import nppp""; from psi4.driver.aliases import sherrill_gold_standard, allen_focal_point. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:1221,Testability,log,logging,1221,"_helper; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; from functools import partial; from typing import Callable, Optional, Union; import logging. import numpy as np. from psi4 import core; from psi4.driver.p4util.exceptions import ValidationError; nppp = partial(np.array_str, max_line_width=120, precision=8, suppress_small=True) # when safe, ""from psi4.driver import nppp""; from psi4.driver.aliases import sherrill_gold_standard, allen_focal_point. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:1535,Testability,log,logger,1535,"e GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; from functools import partial; from typing import Callable, Optional, Union; import logging. import numpy as np. from psi4 import core; from psi4.driver.p4util.exceptions import ValidationError; nppp = partial(np.array_str, max_line_width=120, precision=8, suppress_small=True) # when safe, ""from psi4.driver import nppp""; from psi4.driver.aliases import sherrill_gold_standard, allen_focal_point. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs',",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:1544,Testability,log,logging,1544,"e GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; from functools import partial; from typing import Callable, Optional, Union; import logging. import numpy as np. from psi4 import core; from psi4.driver.p4util.exceptions import ValidationError; nppp = partial(np.array_str, max_line_width=120, precision=8, suppress_small=True) # when safe, ""from psi4.driver import nppp""; from psi4.driver.aliases import sherrill_gold_standard, allen_focal_point. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs',",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:2875,Testability,log,logger,2875,"th a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:3130,Testability,log,logger,3130,"alueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Epo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:5840,Testability,log,logger,5840,"pha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Ex",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:6519,Testability,log,logger,6519,"a (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :mat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:9065,Testability,log,logger,9065,"I)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolata",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:9737,Testability,log,logger,9737,""""""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:12514,Testability,log,logger,12514,"/ (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Opt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:13185,Testability,log,logger,13185," """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:15258,Testability,log,log,15258," in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:16256,Testability,log,logger,16256,"-1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:16492,Testability,log,log,16492,"Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationEr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:17278,Testability,log,logger,17278,"bsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:20269,Testability,log,logger,20269,"zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_tr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:21008,Testability,log,logger,21008,"""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:3268,Availability,avail,available,3268," geometry by linear combination. * ... and collect geometry into a field of findifrec[""displacements""].<label>; * for (2, 0) also collect off-diagonal displacements; * also collect undisplaced geometry into field reference; * return findifrec. * form AtomicComputers for each displacement, particularly changing mol and driver, and possibly relaxing disp symm; * form dict task_list with keys findifrec labels and vals AtomicComputers. --------------------------------------; FiniteDifferenceComputer.build_tasks(); --------------------------------------; * pass. ----------------------------------; FiniteDifferenceComputer.compute(); ----------------------------------; * compute() for each job in task list. ------------------------------------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:3856,Availability,avail,available,3856,"te(); ----------------------------------; * compute() for each job in task list. ------------------------------------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:3970,Availability,avail,available,3970,"-----------------; FiniteDifferenceComputer.get_psi_results(); ------------------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries. assemble_hessian_from_energies(); --------------------------------; assemble_hessian_from_gradients(); ---------------------------------. _process_hessian_symmetry_block(); ---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base impo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:6227,Availability,error,error,6227,"def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in i_m:; # * Python error if iterate through `salc_list`; for i in range(len(salc_list[salc_index])):; component = salc_list[salc_index][i]; disp_geom[component.atom, component.xyz] += disp_steps * step_size * component.coef / np.sqrt(mass[component.atom]); label.append(f""{salc_index}: {disp_steps}""). # salc_index is in descending order. We want the label in ascending order, so...; # ...add the new label part from the left of the string, not the right.; label = ', '.join(reversed(label)); return disp_geom, label. def _initialize_findif(mol: Union[""qcdb.Molecule"", core.Molecule],; freq_irrep_only: int,; mode: str,; stencil_size: int,; step_size: float,; initialize_string: Callable,; t_project: bool,; r_project: bool,; initialize: bool,; verbose: int = 0) -> Dict:; """"""Perform initialization tasks needed by all primary functions. Parameters; ----------; mol; The molecule to displace; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps.; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the derivative level d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:10389,Availability,error,error,10389,"ements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:13720,Availability,avail,available,13720," instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be pro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:13823,Availability,avail,available,13823,"ies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; htt",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:21999,Availability,error,error,21999,"ations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:23993,Availability,error,errors,23993,"-----\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:49604,Availability,error,error,49604,"ec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacement] labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:12157,Deployability,update,update,12157,"ep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:45766,Deployability,update,update,45766,"ts""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:55142,Deployability,update,updated,55142,", wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_findif.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:1342,Energy Efficiency,energy,energy,1342,"he copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives. ===========; FINDIF Flow; ===========; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. -----------------------------------; FiniteDifferenceComputer.__init__(); -----------------------------------; * collect findif_stencil_size, findif_step_size from initializer kwargs; * BaseComputer.__init__(); * negotiate safety and user wishes on translation and rotation projection. gradient_from_energies_geometries(); -----------------------------------; hessian_from_gradients_geometries(); -----------------------------------; hessian_from_energies_geometries(); ----------------------------------. _geom_generator(); -----------------. _initialize_findif(); --------------------; * initialize CdSalcs, partition them per irrep, apply user irreps. * start the governing dict findifrec with parameters, size, mol; * for each irrep, for each relevant salc ... _displace_cart(); ----------------; * form new geometry by linear combination. * ... and collect geometry into a field of findifrec[""d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:15587,Energy Efficiency,energy,energy,15587," to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:15629,Energy Efficiency,energy,energy,15629," to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:15719,Energy Efficiency,energy,energy,15719,"ed out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will be {data[""step_size""]:6.2e}.\n"""""". # Genuine support for qcdb molecules would be nice. But that requires ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:20744,Energy Efficiency,energy,energy,20744,"r a gradient by finite difference of energies."" + _der_from_lesser_docstring; hessian_from_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # P",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:20838,Energy Efficiency,adapt,adapted,20838,"rom_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:21624,Energy Efficiency,energy,energy,21624,"eturn f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:21709,Energy Efficiency,energy,energy,21709,"eturn f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:24157,Energy Efficiency,adapt,adapted,24157,"darray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cart",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:30503,Energy Efficiency,adapt,adapted,30503,"dot(dipder_q.T, B); dipder_cart = dipder_cart.T.reshape(data[""n_atom""], 9). massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); dipder_cart = (dipder_cart.T * massweighter).T. dipder_cart = dipder_cart.reshape(3 * data[""n_atom""], 3); return dipder_cart. def assemble_hessian_from_gradients(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of gradients. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]. def init_string(data):; return ("" Computing second-derivative from gradients using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} gradients passed in, including the reference geometry.\n"".format(len(displacements) + 1)). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). # For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.; # Good News: By taking advantage of that, we (potentially) ran less computations.; # Bad News: We need to find the - displacements from the + computations now.; # The next ~80 lines of code are dedicated to that task.; if data[""print_lvl""]:; core.print_out("" Generating complete list of displacements from unique ones.\n\n""). pg = mol.point_group(); ct = pg.char_table(); order = pg.order(). # Determine what atoms map to what other atoms under the point group operations.; # The py-side compute_atom_map will work whether mol is a ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:36877,Energy Efficiency,energy,energy,36877,"* grads_adapted[1::4] + 8 * grads_adapted[2::4] -; grads_adapted[3::4]) / (12.0 * findifrec[""step""][""size""]). H_pi[-1] = _process_hessian_symmetry_block(H_pi[-1], B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""]). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). def assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irre",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:37132,Energy Efficiency,energy,energy,37132,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:37228,Energy Efficiency,adapt,adapted,37228,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:38350,Energy Efficiency,energy,energy,38350,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:38421,Energy Efficiency,energy,energy,38421,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:38443,Energy Efficiency,energy,energy,38443,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:38591,Energy Efficiency,energy,energy,38591,"frec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:38722,Energy Efficiency,energy,energy,38722,"frec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:39401,Energy Efficiency,energy,energy,39401,"disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_en = lambda index: displacements[""{l}: {}, {k}: {}"".format(; k=salc, l=salc2, *data[""disps""][""off""][index])][""energy""]; if findifrec[""stencil_size""] == 3:; fc = (+offdiag_en(0) + offdiag_en(1) + 2 * ref_energy - E[i][0] - E[i][1] - E[j][0] -; E[j][1]) / (2 * findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1],",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:39731,Energy Efficiency,energy,energy,39731,"s = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_en = lambda index: displacements[""{l}: {}, {k}: {}"".format(; k=salc, l=salc2, *data[""disps""][""off""][index])][""energy""]; if findifrec[""stencil_size""] == 3:; fc = (+offdiag_en(0) + offdiag_en(1) + 2 * ref_energy - E[i][0] - E[i][1] - E[j][0] -; E[j][1]) / (2 * findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:40878,Energy Efficiency,energy,energy,40878,"difrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.ge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:43288,Energy Efficiency,energy,energy,43288,"ions_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:43891,Energy Efficiency,energy,energy,43891,"in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:46052,Energy Efficiency,energy,energy,46052,"s on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47098,Energy Efficiency,energy,energy,47098,"bitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hes",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47119,Energy Efficiency,energy,energy,47119,"bitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hes",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47218,Energy Efficiency,energy,energy,47218,"nently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENER",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47346,Energy Efficiency,energy,energy,47346,"[docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if '",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47883,Energy Efficiency,energy,energy,47883,"ference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47907,Energy Efficiency,energy,energy,47907,"ference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:48012,Energy Efficiency,energy,energy,48012," response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:48146,Energy Efficiency,energy,energy,48146,"'energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:49541,Energy Efficiency,energy,energy-or-gradient,49541,"ormulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacement] labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:50591,Energy Efficiency,energy,energy,50591,"ot sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn an",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:51533,Energy Efficiency,energy,energy,51533,"ndifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ---------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:53521,Energy Efficiency,energy,energy,53521," in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:54714,Energy Efficiency,energy,energy,54714,", wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_findif.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:54725,Energy Efficiency,energy,energy,54725,", wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_findif.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:7635,Integrability,depend,dependent,7635,"e string, not the right.; label = ', '.join(reversed(label)); return disp_geom, label. def _initialize_findif(mol: Union[""qcdb.Molecule"", core.Molecule],; freq_irrep_only: int,; mode: str,; stencil_size: int,; step_size: float,; initialize_string: Callable,; t_project: bool,; r_project: bool,; initialize: bool,; verbose: int = 0) -> Dict:; """"""Perform initialization tasks needed by all primary functions. Parameters; ----------; mol; The molecule to displace; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps.; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the derivative level determined from; displacements, and the second number is the level determined at.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:52519,Integrability,interface,interface,52519,"TAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:5139,Modifiability,variab,variable,5139,"--------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:5202,Modifiability,variab,variable,5202,"le (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:20838,Modifiability,adapt,adapted,20838,"rom_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessian_from_energies_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of energies."" + _der_from_lesser_docstring. def assemble_gradient_from_energies(findifrec: Dict) -> np.ndarray:; """"""Compute the gradient by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring. Returns; -------; gradient; (nat, 3) Cartesian gradient [Eh/a0].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). def init_string(data):; return f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:24157,Modifiability,adapt,adapted,24157,"darray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cart",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:30503,Modifiability,adapt,adapted,30503,"dot(dipder_q.T, B); dipder_cart = dipder_cart.T.reshape(data[""n_atom""], 9). massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); dipder_cart = (dipder_cart.T * massweighter).T. dipder_cart = dipder_cart.reshape(3 * data[""n_atom""], 3); return dipder_cart. def assemble_hessian_from_gradients(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of gradients. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]. def init_string(data):; return ("" Computing second-derivative from gradients using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} gradients passed in, including the reference geometry.\n"".format(len(displacements) + 1)). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). # For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.; # Good News: By taking advantage of that, we (potentially) ran less computations.; # Bad News: We need to find the - displacements from the + computations now.; # The next ~80 lines of code are dedicated to that task.; if data[""print_lvl""]:; core.print_out("" Generating complete list of displacements from unique ones.\n\n""). pg = mol.point_group(); ct = pg.char_table(); order = pg.order(). # Determine what atoms map to what other atoms under the point group operations.; # The py-side compute_atom_map will work whether mol is a ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:37228,Modifiability,adapt,adapted,37228,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:44301,Modifiability,variab,variables,44301,"_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:12925,Performance,perform,perform,12925,"ements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the targeted derivative level. The; second number is the compute derivative level. E.g., ""2_0""; is hessian from energies.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec; Dictionary of finite difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:14517,Performance,perform,performed,14517,"e difference data, specified below.; The dictionary makes findifrec _extensible_. If you need a new field; in the record, just add it.; All fields should be present at all times, with two exceptions:; 1. Fields for computed quantities will not be available until; after they are computed.; 2. Displacement specific overrides for globals will not be; available unless the user specified the overrides.; (Such overrides are not implemented at time of writing. An example; is giving a displacement its own step dict.). step : dict; A descriptor for the finite difference step.; In future, this can be overriden by step fields for individual displacements. units : {'Bohr'}; The units for the displacement. The code currently assumes ""bohr,"" per MolSSI standards.; size : float; The step size for the displacement. stencil_size : {3, 5}; Number of points to evaluate at for each displacement basis vector. Count; includes the central reference point. displacement_space : {'CdSalc'}; A string specifying the vector space in which displacements are performed.; Currently, only CdSalc is supported. project_translations : bool; Whether translations are to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:18974,Performance,perform,perform,18974,"ogger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mode=""2_0""). gradient_from_energies_geometries.__doc__ = ""Generate geometries for a gradient by finite difference of energies."" + _der_from_lesser_docstring; hessian_from_gradients_geometries.__doc__ = ""Generate geometries for a Hessian by finite difference of gradients."" + _der_from_lesser_docstring; hessi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:25644,Performance,perform,perform,25644,"_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cartesians.; Each is (nsalc_in_irrep, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; print_lvl; The level of printing information requested by the user. Returns; -------; Hx; The Hessian in non-mass weighted cartesians.; """""". # Handle empty case (atom); if not H_blocks and not B_blocks:; nat3 = massweighter.size; return np.zeros((nat3, nat3), dtype=np.float64). # We have the Hessian in each irrep! The final task is to perform coordinate transforms.; H = p4util.block_diagonal_array(*H_blocks); B = np.vstack(B_blocks). if print_lvl >= 3:; core.print_out(""\n Force constant matrix for all computed irreps in mass-weighted SALCS.\n""); core.print_out(""\n{}\n"".format(nppp10(H))). # Transform the massweighted Hessian from the CdSalc basis to Cartesians.; # The Hessian is the matrix not of a linear transformation, but of a (symmetric) bilinear form; # As such, the change of basis is formula A' = Xt A X, no inverses!; # More conceptually, it's A'_kl = A_ij X_ik X_jl; Each index transforms linearly.; Hx = np.dot(np.dot(B.T, H), B); if print_lvl >= 3:; core.print_out(""\n Force constants in mass-weighted Cartesian coordinates.\n""); core.print_out(""\n{}\n"".format(nppp10(Hx))). # Un-massweight the Hessian.; Hx = np.transpose(Hx / massweighter) / massweighter. if print_lvl >= 3:; core.print_out(""\n Force constants in Cartesian coordinates.\n""); core.print_out(""\n{}\n"".format(nppp10(Hx))). if print_lvl:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:46854,Performance,load,load,46854,"st[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47677,Performance,load,load,47677," Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:48469,Performance,load,load,48469,".extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacemen",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:50457,Performance,load,load,50457,"labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:1637,Safety,safe,safety,1637,"the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives. ===========; FINDIF Flow; ===========; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. -----------------------------------; FiniteDifferenceComputer.__init__(); -----------------------------------; * collect findif_stencil_size, findif_step_size from initializer kwargs; * BaseComputer.__init__(); * negotiate safety and user wishes on translation and rotation projection. gradient_from_energies_geometries(); -----------------------------------; hessian_from_gradients_geometries(); -----------------------------------; hessian_from_energies_geometries(); ----------------------------------. _geom_generator(); -----------------. _initialize_findif(); --------------------; * initialize CdSalcs, partition them per irrep, apply user irreps. * start the governing dict findifrec with parameters, size, mol; * for each irrep, for each relevant salc ... _displace_cart(); ----------------; * form new geometry by linear combination. * ... and collect geometry into a field of findifrec[""displacements""].<label>; * for (2, 0) also collect off-diagonal displacements; * also collect undisplaced geometry into field reference; * return findifrec. * form AtomicComputers for each displacement, particularly changing mol and driver, and possibly relaxing disp symm; * form dict task_list with keys findifrec labels and vals AtomicComput",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:11551,Safety,safe,safe,11551,"n(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Unio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:42270,Safety,safe,safe,42270,"ude; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary point.""""""); stationary_criterion = 1.e-2 # pulled out of a hat; stationary_point = _rms(data['ref_gradient']) < stationary_criterion; else:; stationary_point = False # unknown, so F to be safe; rotations_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4635,Security,validat,validator,4635,"ergies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian disp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4695,Security,validat,validator,4695,"ergies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian disp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:40819,Security,validat,validator,40819,"difrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.ge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:41059,Security,validat,validator,41059,"ag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4443,Testability,log,logging,4443,"---------------------------------; * resymmetrize each H block. _process_hessian(); ------------------; * transform H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; -",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:5062,Testability,log,logger,5062,"result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.cop",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:5071,Testability,log,logging,5071,"result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.cop",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:8265,Testability,log,logger,8265,"ative level determined from; displacements, and the second number is the level determined at.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Repla",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:8488,Testability,log,logger,8488,"step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generation, and not; during the derivative computation as well. Returns; -------; data; Miscellaneous information required by callers.; """""". info = """"""; ----------------------------------------------------------; FINDIF; R. A. King and Jonathon Misiewicz; ----------------------------------------------------------. """"""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:9228,Testability,log,logger,9228,"""""; if initialize:; core.print_out(info); logger.info(info). print_lvl = core.get_option(""FINDIF"", ""PRINT""). data = {""print_lvl"": print_lvl, ""stencil_size"": stencil_size, ""step_size"": step_size}. if print_lvl:; info = initialize_string(data); core.print_out(info); logger.info(info). # Get settings for CdSalcList, then get the CdSalcList.; method_allowed_irreps = 0x1 if mode == ""1_0"" else 0xFF; # core.get_option returns an int, but CdSalcList expect a bool, so re-cast; salc_list = core.CdSalcList(mol, method_allowed_irreps, t_project, r_project). n_atom = mol.natom(); n_irrep = salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise Validat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:11103,Testability,log,logger,11103,"p, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:12043,Testability,log,logger,12043,"n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,; ""disps"": disps,; ""project_translations"": t_project,; ""project_rotations"": r_project; }). return data. def _geom_generator(mol: Union[""qcdb.Molecule"", core.Molecule], freq_irrep_only: int, mode: str, *, t_project: bool = True, r_project: bool = True, stencil_size: int = 3, step_size: float = 0.005) -> Dict:; """"""; Generate geometries for the specified molecule and derivative levels.; You probably want to instead use one of the convenience functions:; gradient_from_energies_geometries, hessian_from_energies_geometries,; hessian_from_gradients_geometries. Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choos",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:17948,Testability,log,logger,17948,"_only, mode, stencil_size, step_size, init_string, t_project, r_project,; True, 1). # We can finally start generating displacements.; ref_geom = np.array(mol.geometry()). # Now we generate the metadata...; findifrec = {; ""step"": {; ""units"": ""bohr"",; ""size"": data[""step_size""]; },; ""stencil_size"": data[""stencil_size""],; ""displacement_space"": ""CdSALC"",; ""project_translations"": data[""project_translations""],; ""project_rotations"": data[""project_rotations""],; ""molecule"": mol.to_schema(dtype=2, units='Bohr'),; ""displacements"": {},; ""reference"": {}; }. def append_geoms(indices, steps):; """"""Given a list of indices and a list of steps to displace each, append the corresponding geometry to the list."""""". # Next, to make this salc/magnitude composite.; disp_geom, label = _displace_cart(findifrec['molecule']['masses'], ref_geom, data[""salc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:18655,Testability,log,logger,18655,"# Next, to make this salc/magnitude composite.; disp_geom, label = _displace_cart(findifrec['molecule']['masses'], ref_geom, data[""salc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mod",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:18788,Testability,log,logger,18788,"lc_list""],; zip(indices, steps), data[""step_size""]); if data[""print_lvl""] > 2:; info = ""\nDisplacement '{}'\n{}\n"".format(label, nppp10(disp_geom)); core.print_out(info); logger.info(info); findifrec[""displacements""][label] = {""geometry"": disp_geom}. for h in range(data[""n_irrep""]):; active_indices = data[""salc_indices_pi""][h]. for index in active_indices:; # Displace along the diagonal.; # Remember that the totally symmetric irrep has special displacements.; for val in data[""disps""][""sym_irr"" if h == 0 else ""asym_irr""]:; append_geoms((index, ), val). # Hessian from energies? We have off-diagonal displacements to worry about.; if mode == ""2_0"":; # i indexes SALC indices of the current irrep.; for i, index in enumerate(active_indices):; for index2 in active_indices[:i]:; for val in data[""disps""][""off""]:; append_geoms((index, index2), val). if data[""print_lvl""] > 2:; logger.info(""\nReference\n{}\n"".format(nppp10(ref_geom))); findifrec[""reference""][""geometry""] = ref_geom. if data[""print_lvl""] > 1:; logger.info(""\n-------------------------------------------------------------""). return findifrec. _der_from_lesser_docstring = """"""; Parameters; ----------; mol; The molecule on which to perform a finite difference calculation.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Irrelevant for ""1_0"".; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; Displacement size [a0]. Returns; -------; findifrec : dict; Dictionary of finite difference data, specified in _geom_generator docstring. """""". gradient_from_energies_geometries = partial(_geom_generator, freq_irrep_only=-1, mode=""1_0""); hessian_from_gradients_geometries = partial(_geom_generator, mode=""2_1""); hessian_from_energies_geometries = partial(_geom_generator, mode=""2_0""). gradient_from_energies_geometries.__doc__ = ""Generate geometries for a gradient by finite difference of energies."" + _der_f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:22590,Testability,log,logger,22590,"isplacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massw",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:23031,Testability,log,logger,23031,"een caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_bloc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:42017,Testability,log,logger,42017,"tion ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary point.""""""); stationary_criterion = 1.e-2 # pulled out of a hat; stationary_point = _rms(data['ref_gradient']) < stationary_criterion; else:; stationary_point = False # unknown, so F to be safe; rotations_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMET",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:44263,Testability,log,logger,44263,"f.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:45179,Testability,log,logger,45179,"ents""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:46533,Testability,log,logger,46533,"lone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:52131,Testability,log,logger,52131,"nt'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(fi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:11158,Usability,clear,clear,11158,"ror, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:11308,Usability,clear,clear,11308,"salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:52773,Usability,simpl,simple,52773,"olecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:1203,Availability,error,error,1203,"ver.driver_nbody; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_dat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:4725,Availability,avail,available,4725,"orm `mc_(frag, bas)`; * construct a molecule appropriately real/ghosted from active-fragment info in (frag, bas); * if embedding_charges active, prepare external_potentials array for atoms not in bas fragments; * for any new `mc_(frag, bas)` index, append a new computer to self.task_list. --------------------------; ManyBodyComputer.compute(); --------------------------; * compute() for each job in self.task_list. ----------------------------------; ManyBodyComputer.get_psi_results(); ----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * if multiple modelchems (multilevel):. multilevel.prepare_results(); ----------------------------; * from the pool of calcs, partition them by modelchem treatment and call _prepare_results on each subpool; * sums modelchem levels and returns small dict back to get_results(). * call get_results() for each job in task list; * assemble all the computed energies, all the computed gradients, and all the computed hessians; * for each available derivative, call:. assemble_nbody_components(); ---------------------------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs ac",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:6529,Availability,avail,available,6529,"ype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:6646,Availability,avail,available,6646," treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from ps",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10986,Availability,error,error,10986,"ted energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:30857,Availability,error,error,30857,"nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:45526,Availability,avail,available,45526,Y THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY | |em| 1 | when cp in bsse_type & rtd=T | best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for c,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:46946,Availability,avail,available,46946, | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY | |em| 1 | when cp in bsse_type | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:50057,Availability,avail,available,50057,UGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY | |em| 1 | when nocp in bsse_type | best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body tota,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:51492,Availability,avail,available,51492,1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY | |em| 1 | when nocp in bsse_type | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less ({max_,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:54617,Availability,avail,available,54617,UGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY | |em| 1 | when vmfc in bsse_type | best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body tota,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:56053,Availability,avail,available,56053,| when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less ({max_,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39144,Deployability,update,update,39144,"e_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87420,Deployability,update,update,87420,")},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87641,Deployability,update,update,87641,"dy_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.re",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87738,Deployability,update,update,87738,"d-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:93795,Deployability,update,updated,93795,"nction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.driver_nbody.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:1355,Energy Efficiency,energy,energy,1355,"sponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment level",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:1726,Energy Efficiency,energy,energy,1726,"e implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ---------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:5845,Energy Efficiency,energy,energy,5845,"------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_resul",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:5881,Energy Efficiency,energy,energy,5881,"------; * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again. build_nbody_compute_list(); --------------------------. * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_resul",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:5993,Energy Efficiency,energy,energy,5993,"stem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:6518,Energy Efficiency,energy,energy,6518,"ype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:7049,Energy Efficiency,energy,energy,7049,"ummed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8265,Energy Efficiency,energy,energy,8265,"eral, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpois",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8544,Energy Efficiency,energy,energy,8544,"; import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, can",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:9205,Energy Efficiency,energy,energy,9205,"iteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:9756,Energy Efficiency,energy,energy,9756,":`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of char",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10716,Energy Efficiency,charge,charges,10716," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10774,Energy Efficiency,charge,charges,10774,"/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples not",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10826,Energy Efficiency,charge,charges,10826,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:11064,Energy Efficiency,energy,energy,11064," True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atom",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:11645,Energy Efficiency,energy,energy,11645,"m-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:12471,Energy Efficiency,energy,energy,12471,"y computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl) + ""_"" + str((frag, bas)). if ptype == ""energy"":; ret = 0.0. for frag, bas in compute_list:; ene = ptype_dict[labeler(frag, bas)]. if vmfc:; sign = ((-1)**(nb - len(frag))). ret += sign * ene. return ret. elif ptype == 'gradient':; ret = np.zeros((nat, 3)). for frag, bas in compute_list:; grad = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:12740,Energy Efficiency,energy,energy,12740,"rag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl) + ""_"" + str((frag, bas)). if ptype == ""energy"":; ret = 0.0. for frag, bas in compute_list:; ene = ptype_dict[labeler(frag, bas)]. if vmfc:; sign = ((-1)**(nb - len(frag))). ret += sign * ene. return ret. elif ptype == 'gradient':; ret = np.zeros((nat, 3)). for frag, bas in compute_list:; grad = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:14015,Energy Efficiency,energy,energy,14015,"ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). start = 0; for ifr in bas:; end = start + fragment_size_dict[ifr]; ret[fragment_slice_dict[ifr]] += sign * grad[start:end]; start += fragment_size_dict[ifr]. return ret. elif ptype == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += sign * hess[rel_sl1, rel_sl2]. return ret. else:; raise KeyError(""ptype can only be energy, gradient, or hessian. How did you end up here?""). def _print_nbody_energy(energy_body_dict: Dict[int, float], header: str, nfragments: int, embedding: bool = False):; """"""Format output string for user for a single bsse_type. Prints to output and logger.; Called repeatedly by assemble_nbody_component."""""". info = f""""""\n ==> N-Body: {header} energies <==\n\n""""""; info += f"""""" {""n-Body"":>12} Total Energy Interaction Energy N-body Contribution to Interaction Energy\n""""""; info += f"""""" [Eh] [Eh] [kcal/mol] [Eh] [kcal/mol]\n""""""; previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:16369,Energy Efficiency,energy,energy,16369,"ious_e = energy_body_dict[nb]; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20}\n"""""". info += ""\n""; core.print_out(info); logger.info(info). def build_nbody_compute_list(; bsse_type: List[BsseEnum],; nbodies: List[Union[int, Literal[""supersystem""]]],; nfragments: int,; return_total_data: bool,; verbose: int = 1,; ) -> Dict[str, Dict[int, Set[FragBasIndex]]]:; """"""Generates lists of N-Body computations needed for requested BSSE treatments. Parameters; ----------; bsse_type; Requested BSSE treatments.; nbodies; List of n-body levels (e.g., `[2]` or `[1, 2]` or `[""supersystem""]`) for which to generate tasks.; Often this value is an element of self.nbodies_per_mc_level.; Note the natural 1-indexing, so `[1]` covers one-body contributions.; Formerly nbody; nfragments; Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.; Formerly max_frag; return_total_data; Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).; verbose; Control volume of printing. Returns; -------; compute_dict; Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment.; Subdict keys are n-body levels and values are sets of all the `mc_(frag, bas)` indices; needed to compute that n-body level. A given index can appear multiple times within a; subdict and among subdicts.; Formerly, the subdict values were sets of indices needed for given BSSE treatment _of_ given; n-body level. See current (left) and former (right) definitions below for CP dimer. compute_dict[""cp""] = { compute_dict[""cp""] = {; 1: set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:21106,Energy Efficiency,energy,energy,21106,"o). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:21621,Energy Efficiency,charge,charges,21621,"ent(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:22089,Energy Efficiency,energy,energy,22089,"ield. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & 2-body w/mp2) assembly: len({mc_level_labels}) != 1""). # get the range of nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:23696,Energy Efficiency,energy,energy,23696,"nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:23912,Energy Efficiency,energy,energy,23912,"l = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. # Sum up ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:26249,Energy Efficiency,energy,energy,26249,"_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; cp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); nocp_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; nocp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:26758,Energy Efficiency,energy,energy,26758,"_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-C",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:27106,Energy Efficiency,energy,energy,27106,"s for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_leve",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:27240,Energy Efficiency,energy,energy,27240," for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:28070,Energy Efficiency,energy,energy,28070,"sse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:28364,Energy Efficiency,energy,energy,28364,"RRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Funct",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:29152,Energy Efficiency,energy,energy,29152,"] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:29347,Energy Efficiency,energy,energy,29347,"ody_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:30423,Energy Efficiency,energy,energy,30423,"unction Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:30890,Energy Efficiency,energy,energy,30890,"NERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level int",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:32229,Energy Efficiency,energy,energy,32229,"et_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:32487,Energy Efficiency,energy,energy,32487,"# * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:33729,Energy Efficiency,charge,charges,33729,"in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:33878,Energy Efficiency,charge,charges,33878,"l[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34004,Energy Efficiency,energy,energy,34004,"ll bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34480,Energy Efficiency,energy,energy,34480,"s all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:38905,Energy Efficiency,charge,charges,38905,"self.nfragments}""; self.task_list[key] = mb_computer(**data); count += 1. compute_dict = build_nbody_compute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39021,Energy Efficiency,charge,charges,39021,"ompute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39175,Energy Efficiency,charge,charges,39175,"e_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:40894,Energy Efficiency,energy,energy,40894,"ponent molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client; QCFractal client if using QCArchive for distributed compute. Returns; -------; nbody_results; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +-------------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:42160,Energy Efficiency,energy,energy,42160,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:43747,Energy Efficiency,energy,energy,43747,"a) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | nbody | >=1 | always | energy n-body QCVariables to be set |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of 1-body. summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:45542,Energy Efficiency,energy,energy,45542,DY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY | |em| 1 | when cp in bsse_type & rtd=T | best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; i,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:46968,Energy Efficiency,energy,energy,46968,in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY | |em| 1 | when cp in bsse_type | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE;,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:50073,Energy Efficiency,energy,energy,50073,em| 1 | when nocp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED TOTAL ENERGY | |em| 1 | when nocp in bsse_type | best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumu,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:51514,Energy Efficiency,energy,energy,51514,e_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY | |em| 1 | when nocp in bsse_type | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:54633,Energy Efficiency,energy,energy,54633,em| 1 | when vmfc in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY | |em| 1 | when vmfc in bsse_type | best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumu,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:56075,Energy Efficiency,energy,energy,56075,type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:79584,Energy Efficiency,energy,energy,79584,"----------------------------------------------------------+; | |em| {max_nbody}vmfc | |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type | cumulative through {max_nbody}-body total Hessians with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates | ntasks | always | all individual energies with nice labels |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (1, 2)@(1, 2) TOTAL ENERGY | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (3)@(2, 3) TOTAL ENERGY | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| .",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:80005,Energy Efficiency,energy,energy,80005,"----------------------------------------------------------+; | |em| {max_nbody}vmfc | |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type | cumulative through {max_nbody}-body total Hessians with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates | ntasks | always | all individual energies with nice labels |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (1, 2)@(1, 2) TOTAL ENERGY | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| N-BODY (3)@(2, 3) TOTAL ENERGY | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| .",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:81338,Energy Efficiency,energy,energy,81338,"-+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates_energy | ntasks | always | all individual energies |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 1_((1, 2), (1, 2)) | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 2_((3,), (2, 3)) | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+-------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:81745,Energy Efficiency,energy,energy,81745,"-+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | intermediates_energy | ntasks | always | all individual energies |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 1_((1, 2), (1, 2)) | |em| 1 | always | total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| 2_((3,), (2, 3)) | |em| 1 | always | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+-------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:86385,Energy Efficiency,energy,energy,86385,"gment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+. """"""; if results is None:; results = {}. # formerly nlevels; mc_level_labels = {i.split(""_"")[0] for i in self.task_list}; if len(mc_level_labels) > 1 and not results:; return driver_nbody_multilevel.prepare_results(self, client). results_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trov",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87184,Energy Efficiency,energy,energy,87184,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87237,Energy Efficiency,energy,energy,87237,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87253,Energy Efficiency,energy,energy,87253,"ts_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87362,Energy Efficiency,energy,energy,87362,"t.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermedia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87378,Energy Efficiency,energy,energy,87378,"t.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermedia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87583,Energy Efficiency,energy,energy,87583,".return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:87599,Energy Efficiency,energy,energy,87599,".return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())). elif self.driver.name == ""hessian"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()); nbody_results.update(assemble_nbody_components(""gradient"", trove[""gradient""], metadata.copy())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:88738,Energy Efficiency,energy,energy,88738,"())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:92155,Energy Efficiency,energy,energy,92155,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:2576,Integrability,rout,routes,2576,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:2584,Integrability,depend,depending,2584,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8294,Integrability,depend,depending,8294,"eral, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpois",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:36555,Integrability,wrap,wrappers,36555,"ding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include supersystem in count. """"""; # Get the n-body orders for this level; nbodies = self.nbodies_per_mc_level[mc_level_idx]. info = ""\n"" + p4util.banner(f"" ManyBody Setup: N-Body Levels {nbodies}"", strNotOutfile=True) + ""\n""; core.print_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:41710,Integrability,depend,depending,41710,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:41749,Integrability,depend,depending,41749,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:41810,Integrability,depend,depending,41810,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:42181,Integrability,depend,depending,42181,"dy_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat); e/g/h := energy or gradient or Hessian; rtd := return_total_data. .. |em| unicode:: U+02003 .. em space. .. _`table:nbody_return`:. +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | item | size | present / zeroed | contents / interpretation |; +===============================================================+======================+====================================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:42626,Integrability,depend,depending,42626,"=====================================================+====================================================================================================================+; | ret_ptype | ptype_size | always | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver) |; | | | | with cp/nocp/vmfc treatment (depending on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +--------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:43075,Integrability,depend,depending,43075,"-+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_energy | 1 | always | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_gradient | (nat, 3) | when driver is g/h | interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | nbody | >=1 | always | energy n-body QCVariables to be set |; +---------------------------------------------------------------+----------------------+----------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:91488,Integrability,interface,interface,91488,"ype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). logger.debug('\nNBODY QCSchema:\n' + pp.pformat(nbody_model.dict())). return nbody_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""int",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39029,Modifiability,extend,extend,39029,"(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. U",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:89889,Performance,load,load,89889,"ues()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:2083,Security,validat,validation,2083,"#; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:7409,Security,validat,validator,7409,"turn_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:7469,Security,validat,validator,7469,"turn_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:18044,Security,validat,validated,18044,"set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations required for CP procedure; * ``'nocp'`` |w---w| list of computations required for non-CP procedure; * ``'vmfc_compute'`` |w---w| list of computations required for VMFC procedure; * ``'vmfc_levels'`` |w---w| list of levels required for VMFC procedure. """"""; # What levels do we need?; fragment_range = range(1, nfragments + 1). # Need nbodies and all lower-body in full basis; cp_compute_list = {x: set() for x in nbodies}; nocp_compute_list = {x: set() for x in nbodies}; vmfc_compute_list = {x: set() for x in nbodies}; vmfc_level_list = {x: set() for x in nbodies} # Need to sum something slightly different. # Verify proper passing of bsse_type. already validated in Computer; bsse_type_remainder = set(bsse_type) - {e.value for e in BsseEnum}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): {bsse_type_remainder}""""""). # Build up compute sets; if 'cp' in bsse_type:; # Everything is in full n-mer basis; basis_tuple = tuple(fragment_range). for nb in nbodies:; if nb > 1:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; # below was `nbodies`, which would never hit. present is closest to pre-DDD. purpose unclear to me.; # if self.max_nbody == 1: break; cp_compute_list[nb].add((x, basis_tuple)). if 'nocp' in bsse_type or return_total_data:; # Everything in monomer basis; for nb in nbodies:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; nocp_compute_list[nb].add((x, x)). if 'vmfc' in bsse_type:; # Like a CP for all combinations of pairs or greater; for nb in nbodies:; for cp_combos in itertools.combinations(fragment_range, nb):; basis_tuple = tuple",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34679,Security,validat,validation,34679,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34732,Security,validat,validator,34732,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34791,Security,validat,validator,34791," Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedd",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34977,Security,validat,validator,34977,"ta (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35119,Security,validat,validator,35119,"ation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35243,Security,validat,validator,35243,"data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level speci",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35411,Security,validat,validator,35411," used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~ps",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35635,Security,validat,validator,35635,"nd validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersys",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:36352,Security,access,accessed,36352," if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:5978,Testability,log,logs,5978,"stem mol into fragment atom ranges to help g/h arrays build piecemeal; * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc; * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing; * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications; * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs. _sum_cluster_ptype_data(); -------------------------; * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment. * compute special case of monomers in monomer basis; * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict; * for driver=energy, set several qcvars and call:. _print_nbody_energy(); ---------------------; * prints and logs formatted energy output. called separately for cp, nocp, vmfc. * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver. * merge all the assemble_nbody_components return dictionaries; * in struct[""intermediates""], store dict of `""N-BODY (?)@(?) TOTAL ENERGY"" = return_energy` for all in task_list or results kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:7564,Testability,log,logging,7564,"for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8036,Testability,log,logger,8036,"(non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || `",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8045,Testability,log,logging,8045,"(non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || `",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:14268,Testability,log,logger,14268,"type == 'hessian':; ret = np.zeros((nat * 3, nat * 3)). for frag, bas in compute_list:; hess = np.asarray(ptype_dict[labeler(frag, bas)]). if vmfc:; sign = ((-1)**(nb - len(frag))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for ifr in bas:; rel_end = rel_start + 3 * fragment_size_dict[ifr]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[ifr]. tmp_slice = fragment_slice_dict[ifr]; abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += sign * hess[rel_sl1, rel_sl2]. return ret. else:; raise KeyError(""ptype can only be energy, gradient, or hessian. How did you end up here?""). def _print_nbody_energy(energy_body_dict: Dict[int, float], header: str, nfragments: int, embedding: bool = False):; """"""Format output string for user for a single bsse_type. Prints to output and logger.; Called repeatedly by assemble_nbody_component."""""". info = f""""""\n ==> N-Body: {header} energies <==\n\n""""""; info += f"""""" {""n-Body"":>12} Total Energy Interaction Energy N-body Contribution to Interaction Energy\n""""""; info += f"""""" [Eh] [Eh] [kcal/mol] [Eh] [kcal/mol]\n""""""; previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; int_e = energy_body_dict[nb] - energy_body_dict[1]; int_e_kcal = int_e * constants.hartree2kcalmol; if tot_e:; info += f"""""" {lbl:>8} {nb:3} {energy_body_dict[nb]:20.12f} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; else",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:15552,Testability,log,logger,15552," previous_e = energy_body_dict[1]; tot_e = (previous_e != 0.0); nbody_range = list(energy_body_dict); nbody_range.sort(); for nb in range(1, nfragments + 1):; lbl = []; if nb == nfragments:; lbl.append(""FULL""); if nb == max(nbody_range):; lbl.append(""RTN""); lbl = ""/"".join(lbl). if nb in nbody_range:; delta_e = (energy_body_dict[nb] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; if embedding:; int_e = np.nan; int_e_kcal = np.nan; else:; int_e = energy_body_dict[nb] - energy_body_dict[1]; int_e_kcal = int_e * constants.hartree2kcalmol; if tot_e:; info += f"""""" {lbl:>8} {nb:3} {energy_body_dict[nb]:20.12f} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {int_e:20.12f} {int_e_kcal:20.12f} {delta_e:20.12f} {delta_e_kcal:20.12f}\n""""""; previous_e = energy_body_dict[nb]; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20}\n"""""". info += ""\n""; core.print_out(info); logger.info(info). def build_nbody_compute_list(; bsse_type: List[BsseEnum],; nbodies: List[Union[int, Literal[""supersystem""]]],; nfragments: int,; return_total_data: bool,; verbose: int = 1,; ) -> Dict[str, Dict[int, Set[FragBasIndex]]]:; """"""Generates lists of N-Body computations needed for requested BSSE treatments. Parameters; ----------; bsse_type; Requested BSSE treatments.; nbodies; List of n-body levels (e.g., `[2]` or `[1, 2]` or `[""supersystem""]`) for which to generate tasks.; Often this value is an element of self.nbodies_per_mc_level.; Note the natural 1-indexing, so `[1]` covers one-body contributions.; Formerly nbody; nfragments; Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.; Formerly max_frag; return_total_data; Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).; verbose; Control volume of printing. Returns; -------; compute_dict;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:20088,Testability,log,logger,20088,"bos); for interior_nbody in range(1, nb + 1):; for x in itertools.combinations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_compute_list[nb].add(combo_tuple); vmfc_level_list[len(basis_tuple)].add(combo_tuple). # Build a comprehensive compute range; # * do not use list length to count number of {nb}-body computations; compute_list = {x: set() for x in nbodies}; for nb in nbodies:; compute_list[nb] |= cp_compute_list[nb]; compute_list[nb] |= nocp_compute_list[nb]; compute_list[nb] |= vmfc_compute_list[nb]. # Rearrange compute_list from key nb having values to compute all of that nb; # to key nb including values of that nb. Use for counting.; compute_list_count = {x: set() for x in nbodies}; for nb in nbodies:; for nbset in compute_list.values():; for item in nbset:; if len(item[0]) == nb:; compute_list_count[nb].add(item); if verbose >= 1:; info = ""\n"".join([f"" Number of {nb}-body computations: {len(compute_list_count[nb])}"" for nb in nbodies]); core.print_out(info + ""\n""); logger.info(info). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class fi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:21102,Testability,log,log,21102,"o). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34459,Testability,log,log,34459,"s all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:37558,Testability,log,logger,37558,"n wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include supersystem in count. """"""; # Get the n-body orders for this level; nbodies = self.nbodies_per_mc_level[mc_level_idx]. info = ""\n"" + p4util.banner(f"" ManyBody Setup: N-Body Levels {nbodies}"", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). for kwg in ['dft_functional']:; if kwg in kwargs:; kwargs['keywords']['function_kwargs'][kwg] = kwargs.pop(kwg). count = 0; template = copy.deepcopy(kwargs). # Get compute list; if nbodies == [""supersystem""]:; # Add supersystem computation if requested -- always nocp; data = template; data[""molecule""] = self.molecule; key = f""supersystem_{self.nfragments}""; self.task_list[key] = mb_computer(**data); count += 1. compute_dict = build_nbody_compute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39569,Testability,log,logger,39569,"[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client; QCFractal client if using QCArchive for distributed compute. Returns; -------; nbody_results; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:89693,Testability,log,logger,89693,"y. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:91111,Testability,log,logger,91111,""": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). logger.debug('\nNBODY QCSchema:\n' + pp.pformat(nbody_model.dict())). return nbody_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be b",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:2597,Usability,simpl,simple,2597,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:21027,Usability,simpl,simply,21027,"utations: {len(compute_list_count[nb])}"" for nb in nbodies]); core.print_out(info + ""\n""); logger.info(info). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:92211,Usability,simpl,simple,92211,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:13858,Availability,down,down,13858,"; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:23571,Deployability,update,updated,23571,"le=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.frac.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:3723,Energy Efficiency,charge,chargep,3723,"ionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = Fals",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:3746,Energy Efficiency,charge,chargem,3746,"ionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = Fals",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:5412,Energy Efficiency,energy,energy,5412,"MO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if core.get_local_option('SCF', 'REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:5637,Energy Efficiency,charge,chargem,5637,"tral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if core.get_local_option('SCF', 'REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.ap",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:5802,Energy Efficiency,energy,energy,5802," True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:6322,Energy Efficiency,energy,energy,6322,"ption(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:7284,Energy Efficiency,energy,energy,7284,"er.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_dii",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:7752,Energy Efficiency,energy,energy,7752,"n(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Ju",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:10662,Energy Efficiency,charge,charge,10662,"re.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_nuke requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_nuke` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:11270,Energy Efficiency,energy,energy,11270,"t = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:11664,Energy Efficiency,charge,charge,11664,"= int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:11725,Energy Efficiency,charge,charge,11725,"electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:12137,Energy Efficiency,energy,energy,12137,"ials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:12721,Energy Efficiency,charge,charge,12721," charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:12764,Energy Efficiency,charge,charge,12764,".set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:13154,Energy Efficiency,charge,charge,13154,"iver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.wr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:13215,Energy Efficiency,charge,charge,13215,"wargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k],",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:16871,Energy Efficiency,energy,energy,16871," molecule.molecular_charge() != 0:; raise ValidationError(""""""IP Fitting requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:17890,Energy Efficiency,energy,energy,17890,"SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:18488,Energy Efficiency,energy,energy,18488,"]; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:19362,Energy Efficiency,energy,energy,19362,"rge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1l = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.appen",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:19982,Energy Efficiency,energy,energy,19982,"ESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1l = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; for step in range(maxiter):. # Regula Falsi (modified); if repeat_l > 1:; delta_l /= 2.0; if repeat_r > 1:; delta_r /= 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:20991,Energy Efficiency,energy,energy,20991,"tting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; for step in range(maxiter):. # Regula Falsi (modified); if repeat_l > 1:; delta_l /= 2.0; if repeat_r > 1:; delta_r /= 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:21609,Energy Efficiency,energy,energy,21609,"l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:6434,Modifiability,variab,variable,6434,"e=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:7864,Modifiability,variab,variable,7864,"re.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Just trying to kill some bugs sir!; -Starship Troopers""""""). # Drop the files out; wi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:12249,Modifiability,variab,variable,12249,".energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:1572,Performance,optimiz,optimized,1572,"ral Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver; from psi4.driver.p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:1690,Performance,tune,tuned,1690,"l be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver; from psi4.driver.p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14755,Performance,optimiz,optimized,14755,"s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS referenc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14987,Performance,tune,tuned,14987,"). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS reference.\n""""""); core.set_local_option('SCF', 'REFERENCE', 'UKS'). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:17118,Performance,optimiz,optimize,17118,"ocedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16471,Availability,error,error,16471,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16659,Availability,error,error,16659,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16820,Availability,error,error,16820,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:25945,Deployability,update,updated,25945," = '\n'.join(future_imports) + '\n'; imports += 'import psi4\n'; imports += 'from psi4 import *\n'; imports += 'from psi4.core import *\n'; imports += 'from psi4.driver.diatomic import anharmonicity\n'; imports += 'from psi4.driver.gaussian_n import *\n'; imports += 'from psi4.driver.frac import ip_fitting, frac_traverse\n'; imports += 'from psi4.driver.aliases import *\n'; imports += 'from psi4.driver.driver_cbs import *\n'; imports += 'from psi4.driver.wrapper_database import database, db, DB_RGT, DB_RXN\n'; imports += 'from psi4.driver.wrapper_autofrag import auto_fragments\n'; imports += 'psi4_io = core.IOManager.shared_object()\n'. # psirc (a baby PSIthon script that might live in ~/.psi4rc); psirc_file = os.path.expanduser('~') + os.path.sep + '.psi4rc'; if os.path.isfile(psirc_file):; fh = open(psirc_file); psirc = fh.read(); fh.close(); psirc = psirc.replace('psi4.IOManager', 'psi4.core.IOManager'); psirc += ""\npsi4.core.print_out('Warning: As of v1.5, the ~/.psi4rc file will no longer be read into Psi4 input.\\n')\n""; else:; psirc = ''. blank_mol = 'geometry(""""""\n'; blank_mol += '0 1\nH 0 0 0\nH 0.74 0 0\n'; blank_mol += '"""""",""blank_molecule_psi4_yo"")\n'. temp = imports + psirc + blank_mol + temp. # Move up the psi4.core namespace; for func in dir(core):; temp = temp.replace(""psi4."" + func, ""psi4.core."" + func). # Move pseudonamespace for physconst into proper namespace; from psi4.driver import constants; for pc in dir(constants):; if not pc.startswith('__'):; temp = temp.replace('psi_' + pc, 'psi4.constants.' + pc). return temp. if __name__ == ""__main__"":; result = process_input(""""""; molecule h2 {; H; H 1 R. R = .9; }. set basis 6-31G**. """"""). print(""Result\n==========================""); print(result). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.inputparser.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:13491,Energy Efficiency,charge,charge,13491,"e:; lines2.append(line); lines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if mobj:; unit = mobj.group(1); if unit in ['bohr', 'au', 'a.u.']:; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if mobj:; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if mobj:; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if mobj:; if units == 'ang':; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2),; mobj.group(3), mobj.group(4)); if units == 'bohr':; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2), mobj.group(3),; mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if mobj:; if len(frags[len(frags) - 1]):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = core.get_active_molecule()\n' % (spaces). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:1729,Integrability,message,message,1729,"FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:1809,Integrability,message,message,1809,"FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:1898,Integrability,wrap,wrapping,1898,"# You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar si",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2123,Integrability,message,message,2123,"nput file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2200,Integrability,message,message,2200,"nput file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2294,Integrability,wrap,wrap,2294," = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2407,Integrability,wrap,wrapped,2407,"p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2559,Integrability,wrap,wrap,2559,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace()",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2790,Integrability,wrap,wraps,2790,"):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; if runalso:; core.set_global_option(key, dequotify(value)); return ""%score.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there to",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:10303,Integrability,message,message,10303,"= symbol_re.match(line); result += """"""%s mol.set_basis_by_symbol(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('symbol'), m.group('basis')). elif label_re.match(line):; m = label_re.match(line); result += """"""%s mol.set_basis_by_label(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""{}qcdb.libmintsbasisset.basishorde['{}'] = {}\n"""""" \; .format(spaces, name.upper(), 'basisspec_psi4_yo__' + cleanbas); result += """"""%score.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)) # Get input to PCMSolver; suffix = str(os.getpid()) + '.' + str(uuid.uuid4())[:8]; pcmsolver_fname = 'pcmsolv",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:10440,Integrability,message,message,10440,"% \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""{}qcdb.libmintsbasisset.basishorde['{}'] = {}\n"""""" \; .format(spaces, name.upper(), 'basisspec_psi4_yo__' + cleanbas); result += """"""%score.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)) # Get input to PCMSolver; suffix = str(os.getpid()) + '.' + str(uuid.uuid4())[:8]; pcmsolver_fname = 'pcmsolver.' + suffix + '.inp'; with open(pcmsolver_fname, 'w') as handle:; handle.write(block); import pcmsolver; parsed_pcm = pcmsolver.parse_pcm_input(pcmsolver_fname).splitlines(); os.remove(pcmsolver_fname); pcmsolver_parsed_fname = '@pcmsolver.' + suffix; write_input_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16453,Integrability,message,message,16453,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16523,Integrability,message,message,16523,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16641,Integrability,message,message,16641,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16730,Integrability,message,message,16730,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16802,Integrability,message,message,16802,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:16890,Integrability,message,message,16890,"_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:19462,Integrability,message,message,19462,"enating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; core.print_out(""\n ==> Input File <==\n\n""); core.print_out(""--------------------------------------------------------------------------\n""); core.print_out(raw_input); core.print_out(""--------------------------------------------------------------------------\n""); core.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:19539,Integrability,message,message,19539," a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; core.print_out(""\n ==> Input File <==\n\n""); core.print_out(""--------------------------------------------------------------------------\n""); core.print_out(raw_input); core.print_out(""--------------------------------------------------------------------------\n""); core.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processing. # Process ""cfour name? { ... }""; cfour = re.compile(r'^(\s*?)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2016,Modifiability,variab,variable,2016,"51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2150,Modifiability,variab,variable,2150,"nput file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2656,Modifiability,variab,variables,2656,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace()",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2889,Modifiability,variab,variables,2889,"):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; if runalso:; core.set_global_option(key, dequotify(value)); return ""%score.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there to",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:1242,Security,access,access,1242,"oftware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:18211,Security,validat,validate,18211,"ch up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]; def process_input(raw_input: str, print_level: int = 1) -> str:; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python. Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:1729,Availability,avail,available,1729," warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""ipi_broker"",; ""IPIBroker"",; ]. import sys; import time; from typing import Dict, Optional, Union. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:1814,Availability,avail,available,1814,"; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""ipi_broker"",; ""IPIBroker"",; ]. import sys; import time; from typing import Dict, Optional, Union. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atom",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:5137,Deployability,update,updated,5137,"e is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.ipi_broker.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:3096,Energy Efficiency,energy,energy,3096,"lse); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done befo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:4034,Energy Efficiency,energy,energy,4034,"ulate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:1263,Integrability,interface,interfaces,1263,"19-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""ipi_broker"",; ""IPIBroker"",; ]. import sys; import time; from typing import Dict, Optional, Union. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orien",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:3728,Modifiability,variab,variable,3728,"core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:1389,Testability,test,testing,1389,"file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""ipi_broker"",; ""IPIBroker"",; ]. import sys; import time; from typing import Dict, Optional, Union. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:2235,Testability,assert,assert,2235,"y as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:2315,Testability,assert,assert,2315,"; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. [docs]; class IPIBroker(Client):; """"""Interface implementation between i-PI (https://ipi-code.org/) and |PSIfour|."""""". def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); po",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13450,Deployability,configurat,configuration,13450,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.mdi_engine.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:14163,Deployability,update,updated,14163,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.mdi_engine.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2088,Energy Efficiency,energy,energy,2088,"#; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """""". __all__ = [; ""mdi_init"",; ""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2252,Energy Efficiency,energy,energy,2252,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2674,Energy Efficiency,energy,energy,2674,"r:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2687,Energy Efficiency,energy,energy,2687,"e. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2751,Energy Efficiency,charge,charges,2751,", scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2804,Energy Efficiency,charge,charges,2804,"object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI com",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2899,Energy Efficiency,charge,charges,2899,"thod (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2952,Energy Efficiency,charge,chargefield,2952,"adients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MAS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:3059,Energy Efficiency,charge,charges,3059,"ts to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5526,Energy Efficiency,charge,charges,5526,"ULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5558,Energy Efficiency,charge,charges,5558,"command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5574,Energy Efficiency,charge,charges,5574,"command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5619,Energy Efficiency,charge,charges,5619,"n the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5644,Energy Efficiency,charge,charge,5644," and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """"""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5695,Energy Efficiency,charge,charges,5695," and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """"""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:5742,Energy Efficiency,charge,charges,5742,"tween the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:6474,Energy Efficiency,energy,energy,6474," # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom <",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:6505,Energy Efficiency,energy,energy,6505,"uclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:6570,Energy Efficiency,energy,energy,6570,"""""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms whe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:6617,Energy Efficiency,energy,energy,6617,"harges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:6993,Energy Efficiency,charge,charges,6993,"OUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7038,Energy Efficiency,charge,charges,7038,"OUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7124,Energy Efficiency,charge,charges,7124,"tomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7145,Energy Efficiency,charge,charges,7145,"tomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7224,Energy Efficiency,charge,charges,7224,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7242,Energy Efficiency,charge,charges,7242,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7305,Energy Efficiency,charge,charge,7305,", natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7646,Energy Efficiency,charge,charges,7646,"command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; wh",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:8946,Energy Efficiency,charge,charges,8946,"* natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:9018,Energy Efficiency,charge,charges,9018,"* natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:9482,Energy Efficiency,charge,charges,9482,"MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the latti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:9545,Energy Efficiency,charge,charges,9545,"BLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:9966,Energy Efficiency,charge,charges,9966,"jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *di",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10049,Energy Efficiency,charge,charges,10049,"rges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10333,Energy Efficiency,charge,charges,10333,"ay(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10367,Energy Efficiency,charge,charges,10367,"ay(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10413,Energy Efficiency,charge,charges,10413,"elf, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10445,Energy Efficiency,charge,charges,10445,"elf, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10692,Energy Efficiency,energy,energy,10692,"ttice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT comman",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10722,Energy Efficiency,energy,energy,10722,"nge(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:10736,Energy Efficiency,energy,energy,10736,"nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplic",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11136,Energy Efficiency,charge,charge,11136,"lattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11167,Energy Efficiency,charge,charge,11167,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11181,Energy Efficiency,charge,charge,11181,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11208,Energy Efficiency,charge,charge,11208,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11260,Energy Efficiency,charge,charge,11260," >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11302,Energy Efficiency,charge,charge,11302,"f, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11375,Energy Efficiency,charge,charge,11375,"s through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11419,Energy Efficiency,charge,charge,11419,"s through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11451,Energy Efficiency,charge,charge,11451,", receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11463,Energy Efficiency,charge,charge,11463,", receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11524,Energy Efficiency,charge,charge,11524,"ce, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11541,Energy Efficiency,charge,charge,11541,"ce, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:11631,Energy Efficiency,charge,charge,11631,"e_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """"",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:12425,Energy Efficiency,charge,charges,12425,"h MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; m",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13854,Energy Efficiency,energy,energy,13854,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.mdi_engine.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:1840,Integrability,interface,interface,1840,"ESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """""". __all__ = [; ""mdi_init"",; ""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13599,Integrability,interface,interface,13599,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.mdi_engine.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2971,Modifiability,variab,variables,2971,"rget molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13450,Modifiability,config,configuration,13450,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.mdi_engine.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2273,Performance,optimiz,optimization,2273,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2356,Performance,perform,performed,2356,"ve_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7341,Safety,avoid,avoid,7341,", natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:8591,Safety,avoid,avoid,8591,"s'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:3247,Availability,error,error,3247,"). @classmethod; def _molecule_from_string(cls,; molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:7645,Deployability,install,install,7645," H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #. [docs]; def geometry(geom: str, name: str = ""default"") -> core.Molecule:; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except Exception:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]; def activate(mol: core.Molecule):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.molutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:8607,Deployability,update,updated,8607," H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #. [docs]; def geometry(geom: str, name: str = ""default"") -> core.Molecule:; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except Exception:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]; def activate(mol: core.Molecule):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.molutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:3433,Integrability,wrap,wrapper,3433,"try=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:4935,Integrability,wrap,wrapper,4935,"; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]; def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:3416,Modifiability,variab,variables,3416,"ame=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:8130,Modifiability,variab,variables,8130," H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #. [docs]; def geometry(geom: str, name: str = ""default"") -> core.Molecule:; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except Exception:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]; def activate(mol: core.Molecule):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.molutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:5222,Security,validat,validation,5222,"ltiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]; def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays; cls.to_dict = qcdb.Molecule.to_dict; cls.BFS = qcdb.Molecule.BFS; cls.B787 = qcdb.Molecule.B787; cls.scramble = qcdb.Molecule.scramble; cls.from_arrays = _molecule_from_arrays; cls.from_string = _molecule_from_string; cls.to_string = qcdb.Molecule.to_string;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3099,Availability,error,error,3099,""", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3443,Availability,avail,available,3443,"r_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.en",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:4142,Availability,error,error,4142,"onstinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:4959,Availability,error,error,4959,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5025,Availability,error,error,5025,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5396,Availability,error,error,5396,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5454,Availability,error,error,5454,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5769,Deployability,update,updated,5769,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:2657,Integrability,synchroniz,synchronized,2657,"of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). retu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:15,Modifiability,plugin,pluginutil,15,". psi4.driver.pluginutil. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]; def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:112,Modifiability,plugin,pluginutil,112,". psi4.driver.pluginutil. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]; def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:152,Modifiability,plugin,pluginutil,152,". psi4.driver.pluginutil. Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]; def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3269,Modifiability,plugin,plugin,3269,"float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3453,Modifiability,plugin,plugins,3453,"r_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.en",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3553,Modifiability,plugin,plugin,3553,"equires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Cre",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3742,Modifiability,plugin,plugin,3742,"pedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3845,Modifiability,plugin,plugin,3845,"""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:4094,Modifiability,plugin,plugin,4094," ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5080,Modifiability,plugin,plugin,5080,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5497,Modifiability,plugin,plugin,5497,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5710,Modifiability,plugin,pluginutil,5710,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.pluginutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:1525,Security,sanitiz,sanitized,1525,"blic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]; def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3767,Security,sanitiz,sanitized,3767,"pedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:1111,Deployability,integrat,integrate,1111,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse():. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5664,Deployability,update,updated,5664," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:1124,Energy Efficiency,charge,charges,1124,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse():. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:1693,Energy Efficiency,charge,charges,1693,"HOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse():. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:2229,Energy Efficiency,energy,energy,2229,"ecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:2752,Energy Efficiency,charge,charges,2752,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3486,Energy Efficiency,charge,charges,3486,"ype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3704,Energy Efficiency,charge,charges,3704,"to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constan",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3769,Energy Efficiency,energy,energy,3769,"ction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3881,Energy Efficiency,charge,charges,3881,"n.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3950,Energy Efficiency,charge,charges,3950,"rser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4005,Energy Efficiency,charge,charges,4005,"rser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4102,Energy Efficiency,charge,charges,4102,"etAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4245,Energy Efficiency,charge,charge,4245,"n(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to defin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4377,Energy Efficiency,charge,charge,4377,"arge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(ch",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4446,Energy Efficiency,charge,charges,4446,"A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffus",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4553,Energy Efficiency,charge,charge,4553,"y:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. m",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4627,Energy Efficiency,charge,charges,4627,"elf.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 20",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4904,Energy Efficiency,charge,charges,4904," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4965,Energy Efficiency,charge,charges,4965," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4985,Energy Efficiency,charge,charges,4985," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5005,Energy Efficiency,charge,charges,5005," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5025,Energy Efficiency,charge,charges,5025," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5226,Energy Efficiency,charge,charge,5226," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5291,Energy Efficiency,charge,charges,5291," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5320,Energy Efficiency,charge,charge,5320," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5335,Energy Efficiency,charge,charges,5335," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5367,Energy Efficiency,charge,charge,5367," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5378,Energy Efficiency,charge,charge,5378," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5389,Energy Efficiency,charge,charge,5389," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:5400,Energy Efficiency,charge,charge,5400," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qmmm.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:1111,Integrability,integrat,integrate,1111,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse():. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:2719,Performance,perform,perform,2719,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5202,Availability,error,errored,5202,"driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; clien",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6071,Availability,error,errored,6071,"nt.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6184,Availability,error,error,6184,"ing will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:9049,Availability,error,error,9049,"ilter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Atomic-flavored QCSchema."""""". if self.result:; return self.result. if client:; try:; # QCFractal/QCPortal v0.15.8; result = client.query_results(id=self.result_id); qca_next_branch = False; except AttributeError:; # QCFractal/QCPortal `next`; record = client.get_singlepoints(record_ids=self.result_id); qca_next_branch = True. logger.debug(f""Querying AtomicResult {self.result_id}""). if not qca_next_branch:; # QCFractal v0.15.8; if len(result) == 0:; return self.result. self.result = result[0]. else:; # QCFractal `next`; if record.status != ""complete"":; return self.result. self.result = _singlepointrecord_to_atomicresult(record). return self.result. def _singlepointrecord_to_atomicresult(spr: ""qcportal.singlepoint.SinglepointRecord"") -> AtomicResult:; atres = spr.to_qcschema_result(). # QCFractal `next` database stores return_result, properties, and extras[""qcvars""] merged; # together and with lowercase keys. `to_qcschema_result` partitions properties back out,; # but we need to restore qcvars keys, types, and dimensions.; qcvars = atres.extras.pop(""extra_properties""); qcvars.pop(""return_result""); qcvars = {k.upper(): p4util.plump_qcvar(k, v) for k, v in qcvars.items()}; atres.extras[""qcvars""] = qcvars. return atres. def _drink_filter(stdout: str) -> str:; """"""Don't mess up the widespread ``grep beer`` test of Psi4 doneness by printing multiple drinks per outfile."""""". stdout = stdout.replace(""\n*** Psi4 exiting successfully. Buy a developer a beer!"", """"); stdout = stdout.replace(""\n*** Psi4 encountered an error. Buy a developer more coffee!"", """"); return stdout. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_base.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:9284,Deployability,update,updated,9284,"ilter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Atomic-flavored QCSchema."""""". if self.result:; return self.result. if client:; try:; # QCFractal/QCPortal v0.15.8; result = client.query_results(id=self.result_id); qca_next_branch = False; except AttributeError:; # QCFractal/QCPortal `next`; record = client.get_singlepoints(record_ids=self.result_id); qca_next_branch = True. logger.debug(f""Querying AtomicResult {self.result_id}""). if not qca_next_branch:; # QCFractal v0.15.8; if len(result) == 0:; return self.result. self.result = result[0]. else:; # QCFractal `next`; if record.status != ""complete"":; return self.result. self.result = _singlepointrecord_to_atomicresult(record). return self.result. def _singlepointrecord_to_atomicresult(spr: ""qcportal.singlepoint.SinglepointRecord"") -> AtomicResult:; atres = spr.to_qcschema_result(). # QCFractal `next` database stores return_result, properties, and extras[""qcvars""] merged; # together and with lowercase keys. `to_qcschema_result` partitions properties back out,; # but we need to restore qcvars keys, types, and dimensions.; qcvars = atres.extras.pop(""extra_properties""); qcvars.pop(""return_result""); qcvars = {k.upper(): p4util.plump_qcvar(k, v) for k, v in qcvars.items()}; atres.extras[""qcvars""] = qcvars. return atres. def _drink_filter(stdout: str) -> str:; """"""Don't mess up the widespread ``grep beer`` test of Psi4 doneness by printing multiple drinks per outfile."""""". stdout = stdout.replace(""\n*** Psi4 exiting successfully. Buy a developer a beer!"", """"); stdout = stdout.replace(""\n*** Psi4 encountered an error. Buy a developer more coffee!"", """"); return stdout. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_base.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:2750,Energy Efficiency,energy,energy,2750,"mport p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:2994,Integrability,protocol,protocols,2994," QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:4310,Integrability,protocol,protocols,4310,"2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:4327,Integrability,protocol,protocols,4327,"Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5911,Integrability,protocol,protocols,5911," not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5926,Integrability,protocol,protocols,5926,"# QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1349,Security,validat,validator,1349,"This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., descr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1409,Security,validat,validator,1409,"This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., descr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3781,Security,validat,validator,3781,"e difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Mole",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3860,Security,validat,validator,3860,"ords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecul",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3943,Security,validat,validator,3943,"n the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keyw",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1219,Testability,log,logging,1219," Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mut",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1794,Testability,log,logger,1794," the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1803,Testability,log,logging,1803," the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5414,Testability,log,logger,5414,"tomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.deb",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5516,Testability,log,logger,5516,"; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch .",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5588,Testability,log,logger,5588,"ted:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:5660,Testability,log,logger,5660,"8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. r = client.add_compute(""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]); self.result_id = r.ids[0]; # NOTE: The following will re-run errored jobs by default; if self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driv",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6231,Testability,log,logger,6231,"f self.result_id in r.existing:; ret = client.query_tasks(base_result=self.result_id); if ret:; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6330,Testability,log,logger,6330,"; if ret[0].status == ""ERROR"":; client.modify_tasks(""restart"", base_result=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); core.reopen_outfile(); logger.debug(pp.pformat(self.result.dict())); if stdout := self.result.d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6402,Testability,log,logger,6402,"t=self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); core.reopen_outfile(); logger.debug(pp.pformat(self.result.dict())); if stdout := self.result.dict()[""stdout""]:; core.print_out(_drink_filter(stdout)); self.computed = T",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:6477,Testability,log,logger,6477," elif ret[0].status == ""COMPLETE"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). else:; # QCFractal `next`. meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner_group=self.owner_group,; ); self.result_id = ids[0]; # NOTE: The following will re-run errored jobs by default; if meta.existing_idx:; rec = client.get_singlepoints(self.result_id); if rec.status == ""error"":; client.reset_records(self.result_id); logger.info(""Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); core.reopen_outfile(); logger.debug(pp.pformat(self.result.dict())); if stdout := self.result.dict()[""stdout""]:; core.print_out(_drink_filter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:7250,Testability,log,logger,7250,"Resubmitting Errored Job {}"".format(self.result_id)); elif rec.status == ""complete"":; logger.debug(""Job already completed {}"".format(self.result_id)); else:; logger.debug(""Submitting AtomicResult {}"".format(self.result_id)). return. logger.info(f'<<< JSON launch ... {self.molecule.schoenflies_symbol()} {self.molecule.nuclear_repulsion_energy()}'); gof = core.get_output_file(). # EITHER ...; # from psi4.driver import schema_wrapper; # self.result = schema_wrapper.run_qcschema(self.plan()); # ... OR ...; self.result = qcng.compute(; self.plan(),; ""psi4"",; raise_error=True,; # local_options below suitable for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); core.reopen_outfile(); logger.debug(pp.pformat(self.result.dict())); if stdout := self.result.dict()[""stdout""]:; core.print_out(_drink_filter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Atomic-flavored QCSchema."""""". if self.result:; return self.result. if client:; try:; # QCFractal/QCPortal v0.15.8; result = client.query_results(id=self.result_id); qca_next_branch = False; except AttributeError:; # QCFractal/QCPortal `next`; record = client.get_singlepoints(record_ids=self.result_id); qca_next_branch = True. logger.debug(f""Querying AtomicResult {self.result_id}""). if not qca_next_branch:; # QCFractal v0.15.8; if len(result) == 0:; return self.result. self.result = result[0]. else:; # QCFractal `next`; if record.status != ""complete"":; return self.result. self.result = _singlepointrecord_to_atomicresult(record). return self.result. def _singlepointrecord_to_atomicresult(spr: ""qcportal.singlepoint.Si",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:7849,Testability,log,logger,7849,"e for serial mode where each job takes all the resources of the parent Psi4 job.; # distributed runs through QCFractal will likely need a different setup.; task_config={; # B -> GiB; ""memory"": core.get_memory() / (2 ** 30),; ""ncores"": core.get_num_threads(),; },; ); # ... END. #pp.pprint(self.result.dict()); #print(""... JSON returns >>>""); core.set_output_file(gof, True); core.reopen_outfile(); logger.debug(pp.pformat(self.result.dict())); if stdout := self.result.dict()[""stdout""]:; core.print_out(_drink_filter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Atomic-flavored QCSchema."""""". if self.result:; return self.result. if client:; try:; # QCFractal/QCPortal v0.15.8; result = client.query_results(id=self.result_id); qca_next_branch = False; except AttributeError:; # QCFractal/QCPortal `next`; record = client.get_singlepoints(record_ids=self.result_id); qca_next_branch = True. logger.debug(f""Querying AtomicResult {self.result_id}""). if not qca_next_branch:; # QCFractal v0.15.8; if len(result) == 0:; return self.result. self.result = result[0]. else:; # QCFractal `next`; if record.status != ""complete"":; return self.result. self.result = _singlepointrecord_to_atomicresult(record). return self.result. def _singlepointrecord_to_atomicresult(spr: ""qcportal.singlepoint.SinglepointRecord"") -> AtomicResult:; atres = spr.to_qcschema_result(). # QCFractal `next` database stores return_result, properties, and extras[""qcvars""] merged; # together and with lowercase keys. `to_qcschema_result` partitions properties back out,; # but we need to restore qcvars keys, types, and dimensions.; qcvars = atres.extras.pop(""extra_properties""); qcvars.pop(""return_result""); qcvars = {k.upper(): p4util.plump_qcvar(k, v) for k, v in qcvars.items()}; atres.extras[""qcvars""] = qcvars. return atres. def _drink_filter(stdout: str) -> str:; """"""Don't mess up the widespread ``grep beer`` test of Ps",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:8842,Testability,test,test,8842,"ilter(stdout)); self.computed = True. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Atomic-flavored QCSchema."""""". if self.result:; return self.result. if client:; try:; # QCFractal/QCPortal v0.15.8; result = client.query_results(id=self.result_id); qca_next_branch = False; except AttributeError:; # QCFractal/QCPortal `next`; record = client.get_singlepoints(record_ids=self.result_id); qca_next_branch = True. logger.debug(f""Querying AtomicResult {self.result_id}""). if not qca_next_branch:; # QCFractal v0.15.8; if len(result) == 0:; return self.result. self.result = result[0]. else:; # QCFractal `next`; if record.status != ""complete"":; return self.result. self.result = _singlepointrecord_to_atomicresult(record). return self.result. def _singlepointrecord_to_atomicresult(spr: ""qcportal.singlepoint.SinglepointRecord"") -> AtomicResult:; atres = spr.to_qcschema_result(). # QCFractal `next` database stores return_result, properties, and extras[""qcvars""] merged; # together and with lowercase keys. `to_qcschema_result` partitions properties back out,; # but we need to restore qcvars keys, types, and dimensions.; qcvars = atres.extras.pop(""extra_properties""); qcvars.pop(""return_result""); qcvars = {k.upper(): p4util.plump_qcvar(k, v) for k, v in qcvars.items()}; atres.extras[""qcvars""] = qcvars. return atres. def _drink_filter(stdout: str) -> str:; """"""Don't mess up the widespread ``grep beer`` test of Psi4 doneness by printing multiple drinks per outfile."""""". stdout = stdout.replace(""\n*** Psi4 exiting successfully. Buy a developer a beer!"", """"); stdout = stdout.replace(""\n*** Psi4 encountered an error. Buy a developer more coffee!"", """"); return stdout. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_base.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:4332,Deployability,update,update,4332,"arameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = kwargs.pop(""basis"", keywords.pop(""BASIS"", ""(auto)"")); method = method.lower(). # Expand CBS methods; method, basis, cbsmeta = expand_cbs_methods(method, basis, driver, **kwargs); if method in composite_procedures:; kwargs.update({'cbs_metadata': composite_procedures[method](**kwargs)}); method = 'cbs'. pertinent_findif_kwargs = ['findif_irrep', 'findif_stencil_size', 'findif_step_size', 'findif_verbose']; current_findif_kwargs = {kw: kwargs.pop(kw) for kw in pertinent_findif_kwargs if kw in kwargs}; # explicit: 'findif_mode'. # Build a packet; packet = {""molecule"": molecule, ""driver"": driver, ""method"": method, ""basis"": basis, ""keywords"": keywords}. # Firs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:4910,Deployability,update,update,4910,"psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = kwargs.pop(""basis"", keywords.pop(""BASIS"", ""(auto)"")); method = method.lower(). # Expand CBS methods; method, basis, cbsmeta = expand_cbs_methods(method, basis, driver, **kwargs); if method in composite_procedures:; kwargs.update({'cbs_metadata': composite_procedures[method](**kwargs)}); method = 'cbs'. pertinent_findif_kwargs = ['findif_irrep', 'findif_stencil_size', 'findif_step_size', 'findif_verbose']; current_findif_kwargs = {kw: kwargs.pop(kw) for kw in pertinent_findif_kwargs if kw in kwargs}; # explicit: 'findif_mode'. # Build a packet; packet = {""molecule"": molecule, ""driver"": driver, ""method"": method, ""basis"": basis, ""keywords"": keywords}. # First check for BSSE type; if kwargs.get(""bsse_type"", None) is not None:; levels = kwargs.pop('levels', None). plan = ManyBodyComputer(**packet, **kwargs); original_molecule = packet.pop(""molecule""). # Add tasks for every nbody level requested; if levels is None:; levels = {plan.max_nbody: method}; else:; # rearrange bodies in order with supersystem last lest body count fail in organization loop below; levels = dict(sorted(levels.items(), key=lambda item: 1000 if item[0] == ""supersystem"" else item[0])). # We define cp as being a correction to only interaction energies; # If only doing cp, we need ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7173,Deployability,update,update,7173,"'cp' correction, but provided level 1 details"") ; logger.info(f""NOTE: Removing level {removed_level}""); logger.info(""NOTE: For total energies, add 'nocp' to bsse_list""). # Organize nbody calculations into modelchem levels; # * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs).",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9108,Deployability,update,update,9108,"level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:10580,Deployability,update,update,10580,"S; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={keywords} findif_kw={current_findif_kwargs} kw={kwargs}'); return FiniteDifferenceComputer(**packet,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_planner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:10996,Deployability,update,updated,10996,"S; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={keywords} findif_kw={current_findif_kwargs} kw={kwargs}'); return FiniteDifferenceComputer(**packet,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_planner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:3699,Modifiability,config,configure,3699,"s; if ""/"" in method:; kwargs[""ptype""] = driver; cbsmeta = cbs_text_parser(method, **kwargs). # Single call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]; def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:2794,Safety,detect,detected,2794,"er]. [docs]; def expand_cbs_methods(method: str, basis: str, driver: DriverEnum, **kwargs) -> Tuple[str, str, Dict]:; """"""Sort out the user input method string into recognized fields.; Handles cases like:. (i) ``""mp2""`` -- passes through;; (ii) ``""mp2/cc-pvdz""`` -- broken into method and basis fields;; (iii) ``""mp2/cc-pv[d,t]z""`` -- processed into method=""cbs"" & CBSMetadata spec;; (iv) ``method=""cbs"", cbsmeta=CBSMetadata`` -- passes through. Parameters; ----------; method; User first argument to driver function. A string hint of the method --; see cases above.; basis; User basis hint.; driver; The calling driver function. Note for finite difference that this is; the target driver, not the means driver. """"""; if method == 'cbs' and kwargs.get('cbsmeta', False):; return method, basis, kwargs['cbsmeta']. # Expand CBS methods; if ""/"" in method:; kwargs[""ptype""] = driver; cbsmeta = cbs_text_parser(method, **kwargs). # Single call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]; def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.drive",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:1214,Testability,log,logging,1214,"tum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""expand_cbs_methods"",; ""task_planner"",; ""TaskComputers"",; ]. import os; import copy; import logging; from typing import Dict, Tuple, Union. from qcelemental.models import DriverEnum; from psi4.driver import p4util, pp; from psi4.driver.task_base import AtomicComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer; from psi4.driver.driver_nbody import ManyBodyComputer; from psi4.driver.driver_cbs import CompositeComputer, composite_procedures, cbs_text_parser; from psi4.driver.driver_util import negotiate_derivative_type, negotiate_convergence_criterion; from psi4 import core. logger = logging.getLogger(__name__). TaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. [docs]; def expand_cbs_methods(method: str, basis: str, driver: DriverEnum, **kwargs) -> Tuple[str, str, Dict]:; """"""Sort out the user input method string into recognized fields.; Handles cases like:. (i) ``""mp2""`` -- passes through;; (ii) ``""mp2/cc-pvdz""`` -- broken into method and basis fields;; (iii) ``""mp2/cc-pv[d,t]z""`` -- processed into method=""cbs"" & C",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:1722,Testability,log,logger,1722,"e implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""expand_cbs_methods"",; ""task_planner"",; ""TaskComputers"",; ]. import os; import copy; import logging; from typing import Dict, Tuple, Union. from qcelemental.models import DriverEnum; from psi4.driver import p4util, pp; from psi4.driver.task_base import AtomicComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer; from psi4.driver.driver_nbody import ManyBodyComputer; from psi4.driver.driver_cbs import CompositeComputer, composite_procedures, cbs_text_parser; from psi4.driver.driver_util import negotiate_derivative_type, negotiate_convergence_criterion; from psi4 import core. logger = logging.getLogger(__name__). TaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. [docs]; def expand_cbs_methods(method: str, basis: str, driver: DriverEnum, **kwargs) -> Tuple[str, str, Dict]:; """"""Sort out the user input method string into recognized fields.; Handles cases like:. (i) ``""mp2""`` -- passes through;; (ii) ``""mp2/cc-pvdz""`` -- broken into method and basis fields;; (iii) ``""mp2/cc-pv[d,t]z""`` -- processed into method=""cbs"" & CBSMetadata spec;; (iv) ``method=""cbs"", cbsmeta=CBSMetadata`` -- passes through. Parameters; ----------; method; User first argument to driver function. A string hint of the method --; see cases above.; basis; User basis hint.; driver; The calling driver function. Note for finite difference that this is; the target driver, not the means driver. """"""; if method == 'cbs' and kwargs.get('cbsmeta', False):; return method, basis, kwargs['cbsmeta']. # Expand CBS methods; if ""/"" in method:; kwargs[""ptype""] = dri",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:1731,Testability,log,logging,1731,"e implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""expand_cbs_methods"",; ""task_planner"",; ""TaskComputers"",; ]. import os; import copy; import logging; from typing import Dict, Tuple, Union. from qcelemental.models import DriverEnum; from psi4.driver import p4util, pp; from psi4.driver.task_base import AtomicComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer; from psi4.driver.driver_nbody import ManyBodyComputer; from psi4.driver.driver_cbs import CompositeComputer, composite_procedures, cbs_text_parser; from psi4.driver.driver_util import negotiate_derivative_type, negotiate_convergence_criterion; from psi4 import core. logger = logging.getLogger(__name__). TaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. [docs]; def expand_cbs_methods(method: str, basis: str, driver: DriverEnum, **kwargs) -> Tuple[str, str, Dict]:; """"""Sort out the user input method string into recognized fields.; Handles cases like:. (i) ``""mp2""`` -- passes through;; (ii) ``""mp2/cc-pvdz""`` -- broken into method and basis fields;; (iii) ``""mp2/cc-pv[d,t]z""`` -- processed into method=""cbs"" & CBSMetadata spec;; (iv) ``method=""cbs"", cbsmeta=CBSMetadata`` -- passes through. Parameters; ----------; method; User first argument to driver function. A string hint of the method --; see cases above.; basis; User basis hint.; driver; The calling driver function. Note for finite difference that this is; the target driver, not the means driver. """"""; if method == 'cbs' and kwargs.get('cbsmeta', False):; return method, basis, kwargs['cbsmeta']. # Expand CBS methods; if ""/"" in method:; kwargs[""ptype""] = dri",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:6148,Testability,log,logger,6148," in pertinent_findif_kwargs if kw in kwargs}; # explicit: 'findif_mode'. # Build a packet; packet = {""molecule"": molecule, ""driver"": driver, ""method"": method, ""basis"": basis, ""keywords"": keywords}. # First check for BSSE type; if kwargs.get(""bsse_type"", None) is not None:; levels = kwargs.pop('levels', None). plan = ManyBodyComputer(**packet, **kwargs); original_molecule = packet.pop(""molecule""). # Add tasks for every nbody level requested; if levels is None:; levels = {plan.max_nbody: method}; else:; # rearrange bodies in order with supersystem last lest body count fail in organization loop below; levels = dict(sorted(levels.items(), key=lambda item: 1000 if item[0] == ""supersystem"" else item[0])). # We define cp as being a correction to only interaction energies; # If only doing cp, we need to ignore any user-specified 1st (monomer) level; if 'cp' in kwargs.get(""bsse_type"", None) and 'nocp' not in kwargs.get(""bsse_type"", None): ; if 1 in levels.keys():; removed_level = levels.pop(1); logger.info(""NOTE: User specified exclusively 'cp' correction, but provided level 1 details"") ; logger.info(f""NOTE: Removing level {removed_level}""); logger.info(""NOTE: For total energies, add 'nocp' to bsse_list""). # Organize nbody calculations into modelchem levels; # * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cb",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:6244,Testability,log,logger,6244,": 'findif_mode'. # Build a packet; packet = {""molecule"": molecule, ""driver"": driver, ""method"": method, ""basis"": basis, ""keywords"": keywords}. # First check for BSSE type; if kwargs.get(""bsse_type"", None) is not None:; levels = kwargs.pop('levels', None). plan = ManyBodyComputer(**packet, **kwargs); original_molecule = packet.pop(""molecule""). # Add tasks for every nbody level requested; if levels is None:; levels = {plan.max_nbody: method}; else:; # rearrange bodies in order with supersystem last lest body count fail in organization loop below; levels = dict(sorted(levels.items(), key=lambda item: 1000 if item[0] == ""supersystem"" else item[0])). # We define cp as being a correction to only interaction energies; # If only doing cp, we need to ignore any user-specified 1st (monomer) level; if 'cp' in kwargs.get(""bsse_type"", None) and 'nocp' not in kwargs.get(""bsse_type"", None): ; if 1 in levels.keys():; removed_level = levels.pop(1); logger.info(""NOTE: User specified exclusively 'cp' correction, but provided level 1 details"") ; logger.info(f""NOTE: Removing level {removed_level}""); logger.info(""NOTE: For total energies, add 'nocp' to bsse_list""). # Organize nbody calculations into modelchem levels; # * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'bas",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:6298,Testability,log,logger,6298,": driver, ""method"": method, ""basis"": basis, ""keywords"": keywords}. # First check for BSSE type; if kwargs.get(""bsse_type"", None) is not None:; levels = kwargs.pop('levels', None). plan = ManyBodyComputer(**packet, **kwargs); original_molecule = packet.pop(""molecule""). # Add tasks for every nbody level requested; if levels is None:; levels = {plan.max_nbody: method}; else:; # rearrange bodies in order with supersystem last lest body count fail in organization loop below; levels = dict(sorted(levels.items(), key=lambda item: 1000 if item[0] == ""supersystem"" else item[0])). # We define cp as being a correction to only interaction energies; # If only doing cp, we need to ignore any user-specified 1st (monomer) level; if 'cp' in kwargs.get(""bsse_type"", None) and 'nocp' not in kwargs.get(""bsse_type"", None): ; if 1 in levels.keys():; removed_level = levels.pop(1); logger.info(""NOTE: User specified exclusively 'cp' correction, but provided level 1 details"") ; logger.info(f""NOTE: Removing level {removed_level}""); logger.info(""NOTE: For total energies, add 'nocp' to bsse_list""). # Organize nbody calculations into modelchem levels; # * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; #",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7383,Testability,log,logic,7383,"nto modelchem levels; # * expand keys of `levels` into full lists of nbodies covered. save to plan, resetting max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:8018,Testability,log,logger,8018,"odies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:8203,Testability,log,logger,8203,"sis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:8652,Testability,log,logger,8652,"['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None),",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:8796,Testability,log,logger,8796,"for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9672,Testability,log,logger,9672,"gger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9891,Testability,log,logger,9891,"kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={keywords} findif_kw={current_findif_kwargs} kw={kwargs}'); return FiniteDifferenceComputer(**packet,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:10467,Testability,log,logger,10467,"S; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={keywords} findif_kw={current_findif_kwargs} kw={kwargs}'); return FiniteDifferenceComputer(**packet,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_planner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:10598,Testability,log,logger,10598,"S; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); convcrit = negotiate_convergence_criterion(dermode, method, return_optstash=False). if dermode[0] == dermode[1]: # analytic; logger.info(f'PLANNING Atomic: keywords={keywords}'); return AtomicComputer(**packet, **kwargs); else:; keywords.update(convcrit); logger.info(; f'PLANNING FD: dermode={dermode} keywords={keywords} findif_kw={current_findif_kwargs} kw={kwargs}'); return FiniteDifferenceComputer(**packet,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.task_planner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:3831,Usability,simpl,simple,3831," call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]; def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = kwargs.pop(""basis"", keywords.pop(""BASIS"", ""(auto)"")); method = method.lower(). # Expand CBS methods; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7492,Usability,simpl,simplekwargs,7492,"ing max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; *",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7530,Usability,simpl,simplekwargs,7530," # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7565,Usability,simpl,simplecbsmeta,7565,"`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, met",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7605,Usability,simpl,simplecbsmeta,7605,"nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7677,Usability,simpl,simplecbsmeta,7677,"nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:7722,Usability,simpl,simplekwargs,7722,"nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9267,Usability,simpl,simplekwargs,9267," {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9305,Usability,simpl,simplekwargs,9305,"_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:9376,Usability,simpl,simplekwargs,9376,"_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html:2803,Deployability,update,updated,2803,"; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [""auto_fragments""]. from typing import List, Optional. from psi4 import core. [docs]; def auto_fragments(; molecule: Optional[core.Molecule] = None,; seed_atoms: Optional[List[List[int]]] = None,; ) -> core.Molecule:; r""""""Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters; ----------; molecule : :ref:`molecule <op_py_molecule>`, optional; The target molecule, if not the last molecule defined.; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`. Returns; -------; :py:class:`~psi4.core.Molecule` |w--w| fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; --------; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; if molecule is None:; molecule = core.get_active_molecule(); molecule.update_geometry(); molname = molecule.name(). frag, bmol = molecule.BFS(seed_atoms=seed_atoms, return_molecule=True). bmol.set_name(molname); bmol.print_cluster(); core.print_out("""""" Exiting auto_fragments\n""""""). return bmol. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.wrapper_autofrag.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html:1916,Modifiability,variab,variable,1916,"; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [""auto_fragments""]. from typing import List, Optional. from psi4 import core. [docs]; def auto_fragments(; molecule: Optional[core.Molecule] = None,; seed_atoms: Optional[List[List[int]]] = None,; ) -> core.Molecule:; r""""""Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters; ----------; molecule : :ref:`molecule <op_py_molecule>`, optional; The target molecule, if not the last molecule defined.; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`. Returns; -------; :py:class:`~psi4.core.Molecule` |w--w| fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; --------; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; if molecule is None:; molecule = core.get_active_molecule(); molecule.update_geometry(); molname = molecule.name(). frag, bmol = molecule.BFS(seed_atoms=seed_atoms, return_molecule=True). bmol.set_name(molname); bmol.print_cluster(); core.print_out("""""" Exiting auto_fragments\n""""""). return bmol. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.wrapper_autofrag.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_autofrag.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3194,Availability,avail,available,3194,"ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Ind",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:4388,Availability,avail,available,4388,"efault performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:4414,Availability,avail,availableDatabases,4414,"efault performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:4677,Availability,avail,available,4677,"pe mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:4703,Availability,avail,availableDatabases,4703,"pe mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5562,Availability,avail,available,5562,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5587,Availability,avail,availableDatabases,5587,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5646,Availability,error,error,5646,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:6152,Availability,avail,availableDatabases,6152,"lean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculati",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:6176,Availability,avail,available,6176,"lean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculati",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:6752,Availability,avail,available,6752,"m']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:6960,Availability,avail,available,6960," subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='sm",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13212,Availability,error,error,13212,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13551,Availability,avail,available,13551,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HR",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:14155,Availability,avail,available,14155,"Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:14367,Availability,avail,available,14367," = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Data",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:14591,Availability,avail,available,14591,"le for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """"",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:14879,Availability,avail,available,14879,"']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:19813,Availability,error,error,19813," 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" %",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:19995,Availability,error,error,19995,"tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS D",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20002,Availability,error,error,20002,"tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS D",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20159,Availability,error,error,20159," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20197,Availability,error,error,20197," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20211,Availability,error,error,20211," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20249,Availability,error,error,20249," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20268,Availability,error,error,20268," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20291,Availability,error,error,20291," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20312,Availability,error,error,20312," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:20320,Availability,error,error,20320," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3768,Deployability,continuous,continuous,3768,"Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; wit",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3915,Deployability,continuous,continuous,3915,"tr; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:11203,Deployability,continuous,continuous,11203,"; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:11270,Deployability,continuous,continuous,11270,"on.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:15522,Deployability,continuous,continuous,15522,") == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. core.print_out('\n'); p4util.banner(' Database {} Computation: Reagent {} \n {}'.format(db_name, rgt, TAGL[rgt])); core.print_out('\n'). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). if symmetry_override:; molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; core.set_global_option('REFERENCE', 'UHF'); elif user_reference == 'RKS':; c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21441,Deployability,update,update,21441,"unt_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21478,Deployability,update,update,21478," float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt')",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:22896,Deployability,update,updated,22896,"f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.wrapper_database.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2890,Energy Efficiency,energy,energy,2890,"sivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3306,Energy Efficiency,energy,energy,3306,"re not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3462,Energy Efficiency,energy,energy,3462,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3595,Energy Efficiency,energy,energy,3595,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:4615,Energy Efficiency,energy,energy,4615,"es; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5261,Energy Efficiency,energy,energy,5261,"n energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5310,Energy Efficiency,energy,energy,5310,"n energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5742,Energy Efficiency,energy,energy,5742,"bases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5850,Energy Efficiency,energy,energy,5850,"symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7317,Energy Efficiency,energy,energy,7317,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish func",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7734,Energy Efficiency,energy,energy,7734," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7811,Energy Efficiency,energy,energy,7811," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7828,Energy Efficiency,energy,energy,7828," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7982,Energy Efficiency,energy,energy,7982,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:8002,Energy Efficiency,energy,energy,8002,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:8375,Energy Efficiency,energy,energy,8375," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:11635,Energy Efficiency,energy,energy,11635,"ll reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:12097,Energy Efficiency,energy,energy,12097," whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13673,Energy Efficiency,energy,energy,13673,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13740,Energy Efficiency,energy,energy,13740,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:19157,Energy Efficiency,energy,energy,19157,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:8146,Integrability,wrap,wrappers,8146,"age SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__));",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:1801,Modifiability,variab,variables,1801,"TICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core; from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational metho",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2625,Modifiability,variab,variable,2625,"cs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5806,Modifiability,variab,variables,5806,"symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5880,Modifiability,variab,variable,5880,"n'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:6007,Modifiability,flexible,flexible,6007,"``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input th",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:8979,Modifiability,extend,extend,8979,"ergy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.ge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13644,Modifiability,variab,variables,13644,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:17221,Modifiability,variab,variable,17221,"entation(True); molecule.fix_com(True); molecule.update_geometry(). if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; core.set_global_option('REFERENCE', 'UHF'); elif user_reference == 'RKS':; core.set_global_option('REFERENCE', 'UKS'). core.set_global_option('WRITER_FILE_LABEL', user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(f""Optimization exceeded cycles for {rgt}""); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); core.print_out("" Database Contributions Map:\n {}\n"".format('-' * 75)); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not mak",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:17941,Modifiability,variab,variables,17941,"[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:18199,Modifiability,variab,variable,18199,"envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:19164,Modifiability,variab,variable,19164,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3325,Performance,optimiz,optimize,3325,"re not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3388,Performance,perform,performed,3388,"ions (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Opti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3436,Performance,perform,performs,3436,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3489,Performance,optimiz,optimize,3489,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3519,Performance,optimiz,optimization,3519,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:3562,Performance,perform,performs,3562,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7769,Performance,optimiz,optimize,7769," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:9297,Performance,load,load,9297,"ion to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:9459,Performance,load,load,9459,"y); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:9618,Performance,load,loading,9618,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:1624,Security,access,access,1624," 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core; from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2034,Security,access,accessible,2034,"icense along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core; from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2482,Security,access,access,2482,"cs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5419,Testability,benchmark,benchmark,5419,"f bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:5442,Testability,benchmark,benchmark,5442,"f bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7461,Testability,benchmark,benchmark,7461,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:7525,Testability,benchmark,benchmark,7525,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13193,Testability,benchmark,benchmark,13193,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13302,Testability,benchmark,benchmark,13302,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13348,Testability,benchmark,benchmark,13348,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:13530,Testability,benchmark,benchmark,13530,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HR",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21425,Usability,clear,clear,21425,"Derror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21462,Usability,clear,clear,21462," = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str +=",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21877,Usability,simpl,simple,21877,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.wrapper_database.  Copyright ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2288,Availability,error,error,2288,"quiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:4106,Availability,error,error,4106,"..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; -----",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9699,Availability,avail,available,9699,"tistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:10142,Availability,avail,available,10142,"; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:11762,Availability,avail,available,11762,"le in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:12257,Availability,avail,availability,12257,"if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Ps",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:12591,Availability,avail,available,12591,"se:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>>",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13270,Availability,reliab,reliable,13270,"p availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:3915,Deployability,release,release,3915,"es; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:4572,Deployability,release,release,4572,"---!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13279,Deployability,install,install,13279,"p availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13365,Deployability,install,install,13365,"age is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13420,Deployability,install,installation,13420,"age is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13682,Deployability,install,install,13682,"el (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_met",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13702,Deployability,install,install,13702,"el (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_met",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13736,Deployability,install,install,13736,"; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13744,Deployability,install,install,13744,"; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13820,Deployability,install,install,13820,"; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13893,Deployability,install,install,13893,"on):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table link (replace underscore in returned string by dash). """"""; return name.lower(; ).replace(""("", ""_pr"" # ccsd(t); ).replace("")"", ""_pr""; ).replace(""."", ""p"" # mp2.5; ).re",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:16356,Deployability,update,updated,16356," += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table link (replace underscore in returned string by dash). """"""; return name.lower(; ).replace(""("", ""_pr"" # ccsd(t); ).replace("")"", ""_pr""; ).replace(""."", ""p"" # mp2.5; ).replace(""+"", ""p"" # ccsd+t(ccsd); ).replace(""-"", """" # ccsdt-1a; ). [docs]; def docs_table_link(name: str, mode: str) -> str:; """"""Compose a link to *mode* documentation table.; For modes {""summary"", ""details""}, link will be anchored at the table row for method *name*. (Method row not guaranteed to exist.); For other modes, link will be to table in general. """"""; DOCS_BASE = ""https://psicode.org/psi4manual/master/"". if mode == ""summary"":; anchor = ""introduction.html#ss""; elif mode == ""details"":; anchor = ""capabilities.html#dd""; elif mode == ""ccenergy"":; anchor = ""cc.html#table-ccenergy-stdsuite""; elif mode == ""dfmp2"":; anchor = ""dfmp2.html#table-dfmp2-stdsuite""; elif mode == ""fnocc"":; anchor = ""fnocc.html#table-fnocc-stdsuite""; elif mode == ""occ_nonoo"":; anchor = ""occ.html#table-occ-stdsuite-nonoo""; elif mode == ""occ_oo"":; anchor = ""occ.html#table-occ-stdsuite-oo""; elif mode == ""scf"":; anchor = ""dft.html#table-scf-stdsuite""; else:; raise KeyError(""invalid table mode""). # Sphinx reST anchors with underscore build into HTML docs with dash; sanitized_method = sanitize_method(name).replace(""_"", ""-""). if mode in [""summary"", ""details""]:; return f""{DOCS_BASE}{anchor}-{sanitized_method}""; else:; return f""{DOCS_BASE}{anchor}"". ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.exceptions.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6834,Energy Efficiency,energy,energy,6834,"rror(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:7107,Energy Efficiency,energy,energy,7107,"eption. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue fr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:10610,Energy Efficiency,energy,energy,10610,"on. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:11536,Energy Efficiency,energy,energy,11536,"eption.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:1823,Integrability,message,message,1823,"ublic License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:1994,Integrability,message,message,1994,"e Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2056,Integrability,message,message,2056,", Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2140,Integrability,message,message,2140,"lasses."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.drive",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2294,Integrability,message,message,2294,"quiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2479,Integrability,message,message,2479,"]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !-----",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2772,Integrability,message,message,2772,"has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:2943,Integrability,message,message,2943," exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:3585,Integrability,message,message,3585,"# class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:3669,Integrability,message,message,3669,"led when a :func:`~psi4.compare_values` or other comparison; function fails. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:4628,Integrability,message,message,4628," str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5100,Integrability,rout,routine,5100,"ld syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wave",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5189,Integrability,rout,routine,5189,":class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string desc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5238,Integrability,message,message,5238,"Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5281,Integrability,message,message,5281,"preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5376,Integrability,rout,routine,5376,"e users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5397,Integrability,message,message,5397,"-------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5736,Integrability,message,message,5736,"tr):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration numb",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5968,Integrability,rout,routine,5968,"genceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human read",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6061,Integrability,rout,routine,6061,"arameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6142,Integrability,message,message,6142,"tion; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6237,Integrability,rout,routine,6237,"y additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6299,Integrability,message,message,6299,"ribing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6669,Integrability,rout,routine,6669,"onal_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; W",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6758,Integrability,rout,routine,6758,"msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplet",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6936,Integrability,message,message,6936,"tion; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:7031,Integrability,rout,routine,7031,"n).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:7190,Integrability,message,message,7190,"on; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - pr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8355,Integrability,message,message,8355,"loat,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8450,Integrability,rout,routine,8450,"iption, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8687,Integrability,message,message,8687,"were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; avail",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8880,Integrability,message,message,8880,"e norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationErr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9811,Integrability,message,message,9811,"nction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - metho",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9873,Integrability,message,message,9873,"are message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of gov",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9960,Integrability,message,message,9960,"last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_mod",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:10460,Integrability,message,message,10460,". # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:11138,Integrability,message,message,11138,"ut not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:12382,Integrability,message,message,12382,"se:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>>",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:12761,Integrability,message,message,12761,"; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_type"", ""reference"", ""fcae"", ""qc_module""]]; msg = f""Method={stats['method']} is not available for target derivative level (dertype={derivative_int}) under conditions {', '.join(conditions2)}. See {stats['link']}."". PsiException.__init__(self, msg); self.message = msg; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detecte",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:14525,Integrability,message,message,14525,"-Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table link (replace underscore in returned string by dash). """"""; return name.lower(; ).replace(""("", ""_pr"" # ccsd(t); ).replace("")"", ""_pr""; ).replace(""."", ""p"" # mp2.5; ).replace(""+"", ""p"" # ccsd+t(ccsd); ).replace(""-"", """" # ccsdt-1a; ). [docs]; def docs_table_link(name: str, mode: str) -> str:; """"""Compose a link to *mode* documentation table.; For modes {""summary"", ""details""}, link will be anchored at the table row for method *name*. (Method row not guaranteed to exist.); For other modes, link will be to table in general. """"""; DOCS_BASE = ""https://psicode.org/psi4manual/master/"". if mode == ""summary"":; anchor = ""introduction.html#ss""; elif mode == ""details"":; anchor = ""capabilities.html#dd""; elif mode == ""ccenergy"":; anchor = ""cc.html#table-ccenergy-stdsuite""; elif m",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:14593,Integrability,message,message,14593,"e_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table link (replace underscore in returned string by dash). """"""; return name.lower(; ).replace(""("", ""_pr"" # ccsd(t); ).replace("")"", ""_pr""; ).replace(""."", ""p"" # mp2.5; ).replace(""+"", ""p"" # ccsd+t(ccsd); ).replace(""-"", """" # ccsdt-1a; ). [docs]; def docs_table_link(name: str, mode: str) -> str:; """"""Compose a link to *mode* documentation table.; For modes {""summary"", ""details""}, link will be anchored at the table row for method *name*. (Method row not guaranteed to exist.); For other modes, link will be to table in general. """"""; DOCS_BASE = ""https://psicode.org/psi4manual/master/"". if mode == ""summary"":; anchor = ""introduction.html#ss""; elif mode == ""details"":; anchor = ""capabilities.html#dd""; elif mode == ""ccenergy"":; anchor = ""cc.html#table-ccenergy-stdsuite""; elif mode == ""dfmp2"":; anchor = ""dfmp2.html#table-dfmp2-stdsu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:10884,Modifiability,variab,variable,10884,"on. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5136,Performance,optimiz,optimization,5136,"radeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:5905,Performance,optimiz,optimizer,5905,"ception.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iterati",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6008,Performance,optimiz,optimization,6008,"s with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Itera",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8192,Performance,perform,performed,8192,"e: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:8276,Performance,perform,performed,8276,"e: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we; failed to converge.; stats; Dictionary of convergence statistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:13764,Safety,detect,detected,13764,"; self.stats = stats. # Dftd3Error ceased to be used by v1.4. Class removed by v1.7; # class Dftd3Error(PsiException):. [docs]; class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). [docs]; def sanitize_method(name: str) -> str:; """"""Replace characters in method name so that suitable for function name or Sphinx table anchor; (both as-is) or HTML table l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:3820,Usability,simpl,simple,3820,"g* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:4360,Usability,guid,guide,4360,"----------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:2558,Availability,checkpoint,checkpoint,2558,"ndex):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:2791,Availability,avail,available,2791,"dationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:3307,Availability,toler,tolerance,3307,"open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N=",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:3647,Availability,error,error,3647,"hest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5545,Availability,avail,available,5545,"curacy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5834,Availability,toler,tolerance,5834," I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:6174,Availability,error,error,6174,"abel). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:9091,Deployability,update,updated,9091,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:3653,Integrability,message,messages,3653,"hest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:3922,Integrability,depend,dependence,3922,"syu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; cal",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:6180,Integrability,message,messages,6180,"abel). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:1240,Testability,test,testing,1240,"ers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:2940,Testability,log,logical,2940,"else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:2991,Testability,test,test,2991,"else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:3947,Testability,test,tested,3947,"racter) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:4206,Testability,test,tests,4206,"ken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:4470,Testability,test,test,4470,"ken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:4553,Testability,test,test,4553,"ken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:4749,Testability,test,test,4749,"w_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; ato",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:4937,Testability,test,test,4937," coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5015,Testability,test,test,5015," coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5103,Testability,test,tests,5103,"('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the large",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5116,Testability,test,test,5116,"les to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable pro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:5157,Testability,test,tests,5157,"file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). [docs]; def compare_moldenfiles(; expected: str,; computed: str,; atol_exponent: Union[int, float] = 1.e-7,; label: str = ""Compare Molden""):; """"""Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:6579,Testability,test,tests,6579,"ormat description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.matc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:7318,Testability,test,test,7318,"f) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:7673,Testability,test,test,7673,"der_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:7861,Testability,test,test,7861,"m_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(test",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8043,Testability,test,test,8043,"s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-202",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8198,Testability,test,test,8198,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8363,Testability,test,test,8363,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8509,Testability,test,test,8509,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8676,Testability,test,test,8676,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8804,Testability,test,test,8804,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8842,Testability,test,tests,8842,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8855,Testability,test,test,8855,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:8896,Testability,test,tests,8896,"e = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and compare_values(r5, c5, high_accuracy) and compare_values(r6, c6, high_accuracy). elif basis_header_re.match(line):; c1, c2, c3 = basis_header_re.match(line).groups(); r1, r2, r3 = basis_header_re.match(ref[i]).groups(); test = compare_strings(r1,c1) and compare_integers(r2,c2) and compare_values(r3,c3,3). elif s1_re.match(line):; c1, c2 = s1_re.match(line).groups(); r1, r2 = s1_re.match(ref[i]).groups(); test = compare_values(r1, c1, high_accuracy) and compare_values(r2, c2, high_accuracy). elif sym_re.match(line):; c = sym_re.match(line).group(1); r = sym_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif energy_re.match(line):; c = energy_re.match(line).group(1); r = energy_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif spin_re.match(line):; c = spin_re.match(line).group(1); r = spin_re.match(ref[i]).group(1); test = compare_strings(r, c, f'text line: {line}'). elif occ_re.match(line):; c = occ_re.match(line).group(1); r = occ_re.match(ref[i]).group(1); test = compare_values(r, c, high_accuracy, f'float value: {line}'). elif s2_re.match(line):; c1, c2 = s2_re.match(line).groups(); r1, r2 = s2_re.match(line).groups(); test = compare_integers(r1, c1, f'int value: {line}') and compare_values(r2, c2, high_accuracy, f'float value: {line}'). else:; test = compare_strings(line, ref[i]). tests.append(test). return compare_integers(True, all(tests), label). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:16090,Deployability,update,updated,16090," REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, denom) + np.einsum('iajb,iajb,iajb->', MO - MO.swapaxes(1, 3),; MO, denom); return mp2_e. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.fcidump.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:2510,Energy Efficiency,energy,energy,2510,"e_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:2640,Energy Efficiency,energy,energy,2640,"]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:8248,Energy Efficiency,energy,energy,8248,"fset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:8312,Energy Efficiency,energy,energy,8312,"ck[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:9981,Energy Efficiency,energy,energy,9981,"):; eigs_dump += '{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]; def fcidump_from_file(fname: str) -> Dict[str, Any]:; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name. """"""; intdump = {}; with open(fname, 'r') as handle:; firstline = handle.readline().strip(); assert '&FCI' == firstline, firstline. skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intd",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12660,Energy Efficiency,energy,energy,12660,"idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12711,Energy Efficiency,energy,energy,12711,"idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12752,Energy Efficiency,energy,energy,12752,"idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12805,Energy Efficiency,energy,energy,12805,"idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13469,Energy Efficiency,energy,energy,13469,"sym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON EN",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13601,Energy Efficiency,energy,energy,13601,"lectron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13727,Energy Efficiency,energy,energy,13727,"' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13871,Energy Efficiency,energy,energy,13871,"`computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uh",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:14457,Energy Efficiency,energy,energy,14457,"ues(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:14785,Energy Efficiency,energy,energy,14785,"ELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, den",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:5528,Performance,load,load,5528,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, frzcpi+active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:6441,Performance,load,load,6441,"zen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, frzcpi+active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:7052,Performance,load,load,7052,"d in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP for",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:2855,Safety,sanity check,sanity checks,2855,"89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:1435,Testability,test,testing,1435,"an redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format."""""". __all__ = [; ""compare_fcidumps"",; ""energies_from_fcidump"",; ""fcidump"",; ""fcidump_from_file"",; ]. from typing import Any, Dict, List, Optional. import numpy as np. from psi4.driver import psifiles as psif; from psi4.driver.p4util.testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to st",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:10216,Testability,assert,assert,10216,"u; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]; def fcidump_from_file(fname: str) -> Dict[str, Any]:; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name. """"""; intdump = {}; with open(fname, 'r') as handle:; firstline = handle.readline().strip(); assert '&FCI' == firstline, firstline. skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intdump['norb']; idxs = raw_ints[:, 1:].astype(int) - 1. # Slices; sl = slice(ints.shape[0] - nbf, ints.shape[0]). # Extract orbital energies; epsilon = np.zeros(nbf); epsilon[idxs[sl, 0]] = ints[sl]; intdump['epsilon'] = epsilon. # Count how many 2-index intdump we have; sl = slice(sl.start - nbf * nbf, sl.stop - nbf); two_index = np.all(idxs[sl, 2:] == ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12994,Testability,test,test,12994,", 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/inpsight.html:20214,Deployability,update,updated,20214,"'); fh.write('// ***********************************************\n'); fh.write('#macro check_shadow()\n'); fh.write(' #if (!Shadows)\n'); fh.write(' no_shadow \n'); fh.write(' #end\n'); fh.write('#end\n'); fh.write('\n'); fh.write('#macro translucentFinish(T)\n'); fh.write(' #local shineFactor = T;\n'); fh.write(' #if (T <= 0.25)\n'); fh.write(' #declare shineFactor = (1.0-4*T);\n'); fh.write(' #end\n'); fh.write(' #if (T > 0.25)\n'); fh.write(' #declare shineFactor = 0;\n'); fh.write(' #end\n'); fh.write(' finish {\n'); fh.write(' ambient 0.45\n'); fh.write(' diffuse 0.84\n'); fh.write(' specular 0.22\n'); fh.write(' roughness .00001\n'); fh.write(' metallic shineFactor\n'); fh.write(' phong 0.9*shineFactor\n'); fh.write(' phong_size 120*shineFactor\n'); fh.write('}#end\n'); fh.write('\n'); fh.write('#macro a(X,Y,Z,RADIUS,R,G,B,T)\n'); fh.write(' sphere{<X,Y,Z>,RADIUS\n'); fh.write(' pigment{rgbt<R,G,B,T>}\n'); fh.write(' translucentFinish(T)\n'); fh.write(' check_shadow()}\n'); fh.write('#end\n'); fh.write('\n'); fh.write('#macro b(X1,Y1,Z1,RADIUS1,X2,Y2,Z2,RADIUS2,R,G,B,T)\n'); fh.write(' cone{<X1,Y1,Z1>,RADIUS1,<X2,Y2,Z2>,RADIUS2\n'); fh.write(' pigment{rgbt<R,G,B,T>}\n'); fh.write(' translucentFinish(T)\n'); fh.write(' check_shadow()}\n'); fh.write('#end \n'). for bond in self.bonds:; fh.write('b(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)\n' %; (str(bond[0]),str(bond[1]),str(bond[2]),str(bond[3]),; str(bond[4]),str(bond[5]),str(bond[6]),str(bond[7]),; str(bond[8]),str(bond[9]),str(bond[10]),str(bond[11]))); for atom in self.atoms:; fh.write('a(%s,%s,%s,%s,%s,%s,%s,%s)\n' %; (str(atom[1]),str(atom[2]),str(atom[3]),str(atom[4]),; str(atom[5]),str(atom[6]),str(atom[7]),str(atom[8]))). fh.close(). # yapf: enable. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.inpsight.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/inpsight.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/inpsight.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:18457,Deployability,update,updated,18457,"et = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation. [docs]; def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's :func:`scipy.linalg.block_diag`. Parameters; ----------; args; Arbitrary number of square arrays.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.numpy_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1167,Integrability,interface,interface,1167,"river.p4util.numpy_helper; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:5161,Integrability,interface,interface,5161,".Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:5283,Integrability,interface,interface,5283," elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Mat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:5787,Integrability,interface,interface,5787,"ot None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:5880,Integrability,interface,interface,5880," = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:6798,Integrability,depend,depending,6798,"um, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in matrix_views:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:8862,Integrability,interface,interface,8862,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(; self: Union[core.Matrix, core.Vector],; filename: Optional[str] = None,; prefix: str = """",; ) -> Optional[Dict[str, Any]]:; """"""; Writes the irrepped matrix to a NumPy uncompressed file using :func:`numpy.savez`. Can return the packed data for saving many matrices into the same file. Parameters; ----------; self; Instance to be serialized.; filename; File name where the data will be saved.; prefix; Name of instance prepared for NumPy. Returns; -------; None or ~typing.Dict[str, ~typing.Any]; When `filename` given, it and dict serialization passed to; :func:`numpy.savez`, so ``.npz`` file saved and None returned.; When `filename` None, dict serialization returned. """"""; ret = {}; ret[prefix + ""Irreps""] =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:10657,Performance,load,load,10657," and dict serialization passed to; :func:`numpy.savez`, so ``.npz`` file saved and None returned.; When `filename` None, dict serialization returned. """"""; ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using; :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""D",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:10998,Performance,load,load,10998,"ory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using; :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1253,Security,access,access,1253,"3 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1306,Security,access,access,1306,"3 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:11910,Security,access,accessor,11910," not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str, ~typing.Any]; Serialized dictionary with keys:. - shape; - data : List[str]; - type : {'matrix', 'vector'}. """"""; json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in self.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data: Dict[str, Any]) -> Union[core.Matrix, core.Vector]:; """"""; Converts serialized data to the correct Psi4 data type. Parameters; ----------; self; Pointer to which class to be constructed.; json_data; Serialization of class. See :meth:`to_serial` for data layout. """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:14313,Security,access,accessing,14313,"tion of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes.; Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:14385,Security,access,access,14385,"ta[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes.; Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _np",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1691,Usability,simpl,simple,1691,"t it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.nda",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:6385,Usability,simpl,simply,6385,"n ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:8875,Usability,simpl,simply,8875,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(; self: Union[core.Matrix, core.Vector],; filename: Optional[str] = None,; prefix: str = """",; ) -> Optional[Dict[str, Any]]:; """"""; Writes the irrepped matrix to a NumPy uncompressed file using :func:`numpy.savez`. Can return the packed data for saving many matrices into the same file. Parameters; ----------; self; Instance to be serialized.; filename; File name where the data will be saved.; prefix; Name of instance prepared for NumPy. Returns; -------; None or ~typing.Dict[str, ~typing.Any]; When `filename` given, it and dict serialization passed to; :func:`numpy.savez`, so ``.npz`` file saved and None returned.; When `filename` None, dict serialization returned. """"""; ret = {}; ret[prefix + ""Irreps""] =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html:5868,Deployability,update,updated,5868,"ameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs]; def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs]; def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]; @contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsState(osd); yield; oso.restore(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.optproc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:5183,Availability,avail,available,5183,"nputparser.process_input` applied to the XYZ; format of molecule, passed as either fragmented; geometry string *mol* or molecule instance *mol*.; Used to capture molecule information from database; modules and for distributed (sow/reap) input files.; For the reverse, see :py:func:`~psi4.driver.geometry`. Parameters; ----------; mol; Fragmented geometry string or molecule instance.; name; Name to call the resulting molecule.; forcexyz; Use Cartesians, even for Z-Matrix molecules. """"""; warnings.warn(; ""Using `psi4.driver.p4util.format_molecule_for_input` instead of `Molecule.to_string(dtype='psi4')` is deprecated, and as soon as 1.8 it will stop working\n"",; category=FutureWarning,; stacklevel=2). # when mol is already a string; if isinstance(mol, str):; mol_string = mol; mol_name = name; # when mol is core.Molecule or qcdb.Molecule object; else:; # save_string_for_psi4 is the more detailed choice as it includes fragment; # (and possibly no_com/no_reorient) info. but this is only available; # for qcdb Molecules. Since save_string_xyz was added to libmints just; # for the sow/reap purpose, may want to unify these fns sometime.; # the time for unification is nigh; if forcexyz:; mol_string = mol.save_string_xyz(); else:; mol_string = mol.create_psi4_string_from_molecule(); mol_name = mol.name() if name == '' else name. commands = """"""\nmolecule %s {\n%s%s\n}\n"""""" % (mol_name, mol_string, '\nno_com\nno_reorient' if forcexyz else ''); return commands. [docs]; def format_options_for_input(molecule: Optional[core.Molecule] = None, **kwargs) -> str:; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. """"""; warnings.warn(; ""Using `psi4.driver.p4util.format_molecule_for_input` instead of `Molecule.to_string(dtype='psi4')",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:8268,Availability,avail,available,8268,"obal_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); return commands. [docs]; def drop_duplicates(seq: Iterable) -> List:; """"""Return a copy of collection *seq* without any duplicate entries. Parameters; ----------; seq; Collection to be de-duplicated. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]; def all_casings(input_string: str) -> Iterator[str]:; """"""Return a generator of all lettercase permutations of `input_string`. Parameters; ----------; input_string; String of which to permute the case. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]; def getattr_ignorecase(module: str, attr: str):; """"""Extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Parameters; ----------; module; Object on which to seek `attr`.; attr; Name of attribute with uncertain case. Returns; -------; attribute : Any; Module attribute returned if available. None if not. """"""; obj_attr = None; for permutation in list(all_casings(attr)):; try:; getattr(module, permutation); except AttributeError:; pass; else:; obj_attr = getattr(module, permutation); break. return obj_attr. [docs]; def import_ignorecase(module: str) -> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:8492,Availability,avail,available,8492," to be de-duplicated. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]; def all_casings(input_string: str) -> Iterator[str]:; """"""Return a generator of all lettercase permutations of `input_string`. Parameters; ----------; input_string; String of which to permute the case. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]; def getattr_ignorecase(module: str, attr: str):; """"""Extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Parameters; ----------; module; Object on which to seek `attr`.; attr; Name of attribute with uncertain case. Returns; -------; attribute : Any; Module attribute returned if available. None if not. """"""; obj_attr = None; for permutation in list(all_casings(attr)):; try:; getattr(module, permutation); except AttributeError:; pass; else:; obj_attr = getattr(module, permutation); break. return obj_attr. [docs]; def import_ignorecase(module: str) -> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:18242,Availability,avail,available,18242," },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__),; }). return resi. [docs]; def mat2arr(mat: core.Matrix) -> List[List[float]]:; """"""Convert Matrix to List. Parameters; ----------; mat; |PSIfour| matrix. Should be flat with respect to symmetry. Returns; -------; List[List[float]]; Pure Python representation of `mat`. """"""; warnings.warn(; ""Using `psi4.driver.p4util.mat2arr` instead of `MatrixInstance.to_array().tolist()` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]; def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:20419,Deployability,update,updated,20419,"e; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.procutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:16284,Energy Efficiency,energy,energy,16284,"s.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]; def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] = None,; molecule: Optional[core.Molecule] = None,; function_kwargs: Optional[Dict[str, Any]] = None) -> AtomicInput:; """"""Form a QCSchema for job input from the current state of |PSIfour| settings. Parameters; ----------; driver; {'energy', 'gradient', 'hessian'}; Target derivative level.; method; Level of theory for job.; basis; Basis set for job, if not to be extracted from :term:`BASIS <BASIS (MINTS)>`.; molecule; Molecule for job, if not the active one from; :py:func:`~psi4.core.get_active_molecule`.; function_kwargs; Additional keyword arguments to pass to the driver function. Returns; -------; ~qcelemental.models.AtomicInput; QCSchema instance including current keyword set and provenance. """"""; if molecule is None:; molecule = core.get_active_molecule(). keywords = {k.lower(): v for k, v in prepare_options_for_set_options().items()}; if function_kwargs is not None:; keywords[""function_kwargs""] = function_kwargs. kw_basis = keywords.pop(""basis"", None); basis = basis or kw_basis. resi = AtomicInput(; **{; ""driver"": driver,; ""extras"": {; ""wfn_qcvars_only"": True,; },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:12010,Integrability,mediat,mediated,12010,": bool = False,; commandsInsteadDict: bool = False,; globalsOnly: bool = False,; stateInsteadMediated: bool = False,; ) -> Union[Dict, str]:; """"""Capture current state of :py:class:`psi4.core.Options` information. Parameters; ----------; changedOnly; Record info only for options that have been set (may still be default).; When False, records values for every option.; commandsInsteadDict; Return string of commands to exec to reset options in current form.; When False, return nested dictionary with globals in 'GLOBALS' subdictionary; and locals in subdictionaries by module.; globalsOnly; Record only global options to save time querying the; :py:class:`~psi4.core.Options` object.; When False, record module-level options, too.; stateInsteadMediated; When ``True``, querying this function for options to be later *reset* into the same; state -- the raw values and has_changed status at the global and local levels.; When ``False``, querying this function for mediated options to be *used* -- the results; of the globals/locals handshake as computed by the Options object itself. Here,; ``dict[module][option][value]`` is the value to be used by module. Returns; -------; Dict; When `commandsInsteadDict` is False.; str; When `commandsInsteadDict` is True. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. - not all kwargs are independent. """"""; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}; options = collections.defaultdict(dict); commands = ''; for opt in core.get_global_option_list():; hoc = core.has_global_option_changed(opt); if hoc or not changedOnly:; if opt in ['DFT_CUSTOM_FUNCTIONAL', 'EXTERN']: # Feb 2017 hack; continue; val = core.get_global_option(opt); options['GLOBALS'][opt] = {'value': val, 'has_changed': hoc}; if isinstance(val, str):; commands += """"""core.set_global_option('%s', '%s')\n"""""" % (opt, val); else:; co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:19616,Integrability,rout,routine,19616,"e; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.procutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:19753,Integrability,rout,routine,19753,"e; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.procutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:20166,Integrability,rout,routine,20166,"e; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.procutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:20176,Integrability,rout,routine,20176,"e; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.procutil.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:14925,Modifiability,plugin,plugin,14925,"ding by :py:func:`~psi4.driver.p4util.set_options`. Returns; -------; Dict[str, Any]; Dictionary where keys are keyword names, either plain for those to be; set globally or mangled ""module__keyword"" for those to be set locally,; and values are keyword values. """"""; flat_options = {}; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}. for opt in core.get_global_option_list():; handled_locally = False; ghoc = core.has_global_option_changed(opt); opt_snapshot = {k: v[opt] for k, v in has_changed_snapshot.items() if opt in v}; for module, (lhoc, ohoc) in opt_snapshot.items():; if ohoc:; if lhoc:; key = module + '__' + opt; val = core.get_local_option(module, opt); else:; key = opt; val = core.get_global_option(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(curren",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:15027,Modifiability,rewrite,rewrite,15027,"names, either plain for those to be; set globally or mangled ""module__keyword"" for those to be set locally,; and values are keyword values. """"""; flat_options = {}; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}. for opt in core.get_global_option_list():; handled_locally = False; ghoc = core.has_global_option_changed(opt); opt_snapshot = {k: v[opt] for k, v in has_changed_snapshot.items() if opt in v}; for module, (lhoc, ohoc) in opt_snapshot.items():; if ohoc:; if lhoc:; key = module + '__' + opt; val = core.get_local_option(module, opt); else:; key = opt; val = core.get_global_option(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]; def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:18195,Modifiability,variab,variables,18195," },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__),; }). return resi. [docs]; def mat2arr(mat: core.Matrix) -> List[List[float]]:; """"""Convert Matrix to List. Parameters; ----------; mat; |PSIfour| matrix. Should be flat with respect to symmetry. Returns; -------; List[List[float]]; Pure Python representation of `mat`. """"""; warnings.warn(; ""Using `psi4.driver.p4util.mat2arr` instead of `MatrixInstance.to_array().tolist()` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]; def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:8790,Performance,load,loader,8790," ----------; input_string; String of which to permute the case. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]; def getattr_ignorecase(module: str, attr: str):; """"""Extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Parameters; ----------; module; Object on which to seek `attr`.; attr; Name of attribute with uncertain case. Returns; -------; attribute : Any; Module attribute returned if available. None if not. """"""; obj_attr = None; for permutation in list(all_casings(attr)):; try:; getattr(module, permutation); except AttributeError:; pass; else:; obj_attr = getattr(module, permutation); break. return obj_attr. [docs]; def import_ignorecase(module: str) -> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]; @contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:2127,Security,sanitiz,sanitized,2127,"ston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kw",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:9747,Usability,clear,clear,9747,"-> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]; @contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:10079,Usability,clear,clear,10079,"pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]; @contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.revoke_global_option_changed(go); # for module in _modules:; # for lo, dlo in pofm[module].items():; # core.set_local_option(module, lo, dlo['value']); # if not dlo['has_changed']:; # core.revoke_local_option_changed(module, lo). [docs]; def prepare_options_for_modules(; changedOnly: bool = False,; commandsInsteadDict: bool = False,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:4672,Deployability,update,updated,4672," 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.prop_util.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:3887,Energy Efficiency,energy,energy,3887," 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.prop_util.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:1761,Integrability,rout,routine,1761,"implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:1497,Modifiability,variab,variables,1497,"ribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:4191,Modifiability,variab,variables,4191," 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.prop_util.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:1956,Safety,avoid,avoid,1956,"not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique ato",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:1495,Availability,avail,avail,1495,"cluded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import math; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4 import extras; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:3272,Availability,avail,available,3272,"l[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,; quiet: bool = False,; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from `key` in global options. If; a user-defined-basis callable is available at string `target`, `target`; value will be set to it. In practice, setting this argument to a; |PSIfour| keyword (e.g., ``core.get_option(""SCF"", ""DF_BASIS_SCF"")`` or; ``core.get_global_option(""BASIS"")``) works to handle both simple and; user-defined bases.; fitrole; {'ORBITAL', 'JKFIT', 'RIFIT', 'DECON'}; Role for which to build basis. Only used when `key` indicates auxiliary; (i.e., *is not* ``""BASIS""``) and auxiliary spec from processing `target`; can't complete the `mol`. Then, primary spec from `other` can be used; to complete the auxiliary basis by looking up suitable default basis; according to `fitrole`.; other; Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like `target`.; puream; Whether to override the native spherical/cartesian-ness of `target` for; returned basis? Value ``1`` forces spherical, value ``0`` forces; Cartesian, value ``-1`` (default) uses native puream. Note that; explicitly setting :term:`PUREAM <PUREAM (GLOB",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:23548,Deployability,release,release,23548,"ARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROU",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:26976,Deployability,upgrade,upgrade,26976,"CSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCS-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; }. def _qcvar_warnings(key: str) -> str:; """"""Intercept QCVariable keys to issue warnings or upgrade hints. Otherwise,; pass through. """"""; if any([key.upper().endswith("" DIPOLE "" + cart) for cart in [""X"", ""Y"", ""Z""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-2], 1.6, "" Note the Debye -> a.u. units change.""). if any([key.upper().endswith("" QUADRUPOLE "" + cart) for cart in [""XX"", ""YY"", ""ZZ"", ""XY"", ""XZ"", ""YZ""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-3], 1.6, "" Note the Debye -> a.u. units change.""). if key.upper() in _qcvar_transitions:; replacement, version = _qcvar_transitions[key.upper()]; warnings.warn(; f""Using QCVariable `{key.upper()}` instead of `{replacement}` is deprecated, and as soon as {version} it will stop working\n"",; category=FutureWarning,; stacklevel=3); return replacement. if key.upper() in _qcvar_cancellations:; raise UpgradeHelper(key.upper(), ""no direct replacement"", 1.4, "" Consult QCVariables "" + "", "".join(_qcvar_cancellations[key.upper()]) + "" to recompose the quantity.""). return key. [docs]; def plu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:51113,Deployability,release,released,51113," of `psi4.core.doublet` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.doublet(A, B, transA, transB). def _core_triplet(A, B, C, transA, transB, transC):; """"""Multiply three matrices together. .. deprecated:: 1.4; Use :py:func:`psi4.core.triplet` instead. """"""; warnings.warn(; ""Using `psi4.core.Matrix.triplet` instead of `psi4.core.triplet` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.triplet(A, B, C, transA, transB, transC). core.Matrix.doublet = staticmethod(_core_doublet); core.Matrix.triplet = staticmethod(_core_triplet). @staticmethod; def _core_erisieve_build(; orbital_basis: core.BasisSet,; cutoff: float = 0.0,; do_csam: bool = False; ) -> core.ERISieve:; """"""; Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for; ERI screening and an optional input to enable CSAM screening (over Schwarz screening). Parameters; ----------; orbital_basis; Basis set to use in the ERISieve object.; cutoff; Integral cutoff threshold to use for Schwarz/CSAM screening. Defaults to 0.0, disabling screening entirely.; do_csam; Use CSAM screening? If True, CSAM screening is used; else, Schwarz screening is used. By default,; Schwarz screening is utilized. Returns; -------; ERISieve; Initialized ERISieve object. Example; -------; >>> sieve = psi4.core.ERISieve.build(bas, cutoff, csam); """""". warnings.warn(; ""`ERISieve` is deprecated in favor of `TwoBodyAOInt`, and will be removed as soon as Psi4 v1.9 is released.\n"",; category=FutureWarning,; stacklevel=2). return core.ERISieve(orbital_basis, cutoff, do_csam). core.ERISieve.build = _core_erisieve_build. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.python_helpers.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:51455,Deployability,update,updated,51455," of `psi4.core.doublet` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.doublet(A, B, transA, transB). def _core_triplet(A, B, C, transA, transB, transC):; """"""Multiply three matrices together. .. deprecated:: 1.4; Use :py:func:`psi4.core.triplet` instead. """"""; warnings.warn(; ""Using `psi4.core.Matrix.triplet` instead of `psi4.core.triplet` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.triplet(A, B, C, transA, transB, transC). core.Matrix.doublet = staticmethod(_core_doublet); core.Matrix.triplet = staticmethod(_core_triplet). @staticmethod; def _core_erisieve_build(; orbital_basis: core.BasisSet,; cutoff: float = 0.0,; do_csam: bool = False; ) -> core.ERISieve:; """"""; Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for; ERI screening and an optional input to enable CSAM screening (over Schwarz screening). Parameters; ----------; orbital_basis; Basis set to use in the ERISieve object.; cutoff; Integral cutoff threshold to use for Schwarz/CSAM screening. Defaults to 0.0, disabling screening entirely.; do_csam; Use CSAM screening? If True, CSAM screening is used; else, Schwarz screening is used. By default,; Schwarz screening is utilized. Returns; -------; ERISieve; Initialized ERISieve object. Example; -------; >>> sieve = psi4.core.ERISieve.build(bas, cutoff, csam); """""". warnings.warn(; ""`ERISieve` is deprecated in favor of `TwoBodyAOInt`, and will be removed as soon as Psi4 v1.9 is released.\n"",; category=FutureWarning,; stacklevel=2). return core.ERISieve(orbital_basis, cutoff, do_csam). core.ERISieve.build = _core_erisieve_build. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.python_helpers.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:13065,Energy Efficiency,energy,energy,13065,",; 'vector': {; 'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(; orbital_basis: core.BasisSet,; aux: Optional[core.BasisSet] = None,; jk_type: Optional[str] = None,; do_wK: Optional[bool] = None,; memory: Optional[int] = None,; ) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the :",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:13078,Energy Efficiency,energy,energy,13078,"epsilon_a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(; orbital_basis: core.BasisSet,; aux: Optional[core.BasisSet] = None,; jk_type: Optional[str] = None,; do_wK: Optional[bool] = None,; memory: Optional[int] = None,; ) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the :term:`DF_BASIS_SCF <DF_BASIS_SCF (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
