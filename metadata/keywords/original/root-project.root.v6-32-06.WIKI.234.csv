id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/RooAbsAnaConvPdf.html:49647,Integrability,integrat,integration,49647,"ngeName = 0) const; Return analytical integral defined by given code, which is returned; by getAnalyticalIntegralWN(). For unnormalized integrals the returned value is; _ _; PDF = sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the re",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:49677,Integrability,interface,interface,49677,"x) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:49823,Integrability,integrat,integration,49823,"x) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50140,Integrability,integrat,integration,50140,"basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printM",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50274,Integrability,integrat,integration,50274,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50286,Integrability,depend,dependents,50286,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50377,Integrability,integrat,integration,50377,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50521,Integrability,integrat,integrate,50521,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50541,Integrability,depend,dependents,50541,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50592,Integrability,integrat,integration,50592,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50604,Integrability,interface,interface,50604,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50666,Integrability,integrat,integrate,50666,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50682,Integrability,depend,dependents,50682,"Name = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coe",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:715,Modifiability,variab,variable,715,". RooAbsAnaConvPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsAnaConvPdf. class RooAbsAnaConvPdf: public RooAbsPdf. RooAbsAnaConvPdf is the base class of for PDFs that represents a; physics model that can be analytically convolved with a resolution model. To achieve factorization between the physics model and the resolution; model, each physics model must be able to be written in the form; _ _ _ _; Phys(x,a,b) = Sum_k coef_k(a) * basis_k(x,b). where basis_k are a limited number of functions in terms of the variable; to be convoluted and coef_k are coefficients independent of the convolution; variable. Classes derived from RooResolutionModel implement; _ _ _ _; R_k(x,b,c) = Int(dx') basis_k(x',b) * resModel(x-x',c). which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; _ _ _ _ _ _; PDF(x,a,b,c) = Sum_k coef_k(a) * R_k(x,b,c). A minimal implementation of a RooAbsAnaConvPdf physics model consists of. - A constructor that declares the required basis functions using the declareBasis() method.; The declareBasis() function assigns a unique identifier code to each declare basis. - An implementation of coefficient(Int_t code) returning the coefficient value for each; declared basis function. Optionally, analytical integrals can be provided for the coefficient functions. The; interface for this is quite similar to that for integrals of regular PDFs. Two functions,. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const; Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName) const. advertise the coefficient integration capabilities and implement them respectively.; Please see RooAbsPdf for additional details. Advertised analytical integrals must be; valid for all coefficients. Fun",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:802,Modifiability,variab,variable,802,". RooAbsAnaConvPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsAnaConvPdf. class RooAbsAnaConvPdf: public RooAbsPdf. RooAbsAnaConvPdf is the base class of for PDFs that represents a; physics model that can be analytically convolved with a resolution model. To achieve factorization between the physics model and the resolution; model, each physics model must be able to be written in the form; _ _ _ _; Phys(x,a,b) = Sum_k coef_k(a) * basis_k(x,b). where basis_k are a limited number of functions in terms of the variable; to be convoluted and coef_k are coefficients independent of the convolution; variable. Classes derived from RooResolutionModel implement; _ _ _ _; R_k(x,b,c) = Int(dx') basis_k(x',b) * resModel(x-x',c). which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; _ _ _ _ _ _; PDF(x,a,b,c) = Sum_k coef_k(a) * R_k(x,b,c). A minimal implementation of a RooAbsAnaConvPdf physics model consists of. - A constructor that declares the required basis functions using the declareBasis() method.; The declareBasis() function assigns a unique identifier code to each declare basis. - An implementation of coefficient(Int_t code) returning the coefficient value for each; declared basis function. Optionally, analytical integrals can be provided for the coefficient functions. The; interface for this is quite similar to that for integrals of regular PDFs. Two functions,. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const; Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName) const. advertise the coefficient integration capabilities and implement them respectively.; Please see RooAbsPdf for additional details. Advertised analytical integrals must be; valid for all coefficients. Fun",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:12718,Modifiability,extend,extendedTerm,12718,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:12830,Modifiability,extend,extendMode,12830,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:16487,Modifiability,extend,extended,16487,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:16641,Modifiability,extend,extended,16641,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:31662,Modifiability,config,config,31662,"ect::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:31820,Modifiability,config,config,31820,"rRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:35945,Modifiability,extend,extended,35945,"Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Double_tgetCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; vo",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:42490,Modifiability,variab,variable,42490,"nt cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsR",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:45069,Modifiability,config,configuration,45069," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:45177,Modifiability,config,configuration,45177," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:46287,Modifiability,variab,variable,46287,"ibString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsAnaConvPdf(); Destructor. Int_t declareBasis(const char* expression, const RooArgList& params); Declare a basis function for use in this physics model. The string expression; must be a valid RooFormulVar expression representing the basis function, referring; to the convolution variable as '@0', and any additional parameters (supplied in; 'params' as '@1','@2' etc. The return value is a unique identifier code, that will be passed to coefficient(); to identify the basis function for which the coefficient is requested. If the; resolution model used does not support the declared basis function, code -1 is; returned. Bool_t changeModel(const RooResolutionModel& newModel); Change the current resolution model to newModel. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation contex",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:47592,Modifiability,variab,variable,47592,"he declared basis function, code -1 is; returned. Bool_t changeModel(const RooResolutionModel& newModel); Change the current resolution model to newModel. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates results into composite configuration with a unique; code assigned by RooAICRegistry. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeN",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:48432,Modifiability,config,configuration,48432,"generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates results into composite configuration with a unique; code assigned by RooAICRegistry. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given code, which is returned; by getAnalyticalIntegralWN(). For unnormalized integrals the returned value is; _ _; PDF = sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function depen",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50991,Modifiability,variab,variables,50991,"AnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sat Sep 5 16:39:52 2015 » Last ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:3992,Performance,cache,cacheUniqueSuffix,3992," RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) cons",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:13439,Performance,cache,cacheList,13439,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:13527,Performance,cache,cacheList,13527,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:25827,Performance,optimiz,optimizeCacheMode,25827,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:25899,Performance,optimiz,optimizeCacheMode,25899,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:30271,Performance,cache,cache,30271,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setD",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:31560,Performance,cache,cache,31560,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:34193,Performance,cache,cache,34193,"nit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:37720,Performance,optimiz,optimizeDirtyHook,37720,"= kFALSE) const; Double_tgetCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:41413,Performance,cache,cache,41413,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:41497,Performance,cache,cache,41497,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:41696,Performance,cache,caches,41696,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:42612,Performance,cache,cache,42612,ean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOrig,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:42891,Performance,cache,cache,42891,efCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:43305,Performance,cache,cache,43305,efCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:43965,Performance,cache,cache,43965,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:44636,Performance,cache,cache,44636,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:45435,Performance,cache,cache,45435," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:47922,Performance,perform,perform,47922,"= kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates results into composite configuration with a unique; code assigned by RooAICRegistry. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given code, which is returned; by getAnalyticalIntegralWN(). For unnormalized integrals the returned value is; _ _; PDF = sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to b",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:48105,Performance,perform,performed,48105,"e physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates results into composite configuration with a unique; code assigned by RooAICRegistry. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given code, which is returned; by getAnalyticalIntegralWN(). For unnormalized integrals the returned value is; _ _; PDF = sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:51475,Performance,cache,cache-and-track,51475,"ntegration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sat Sep 5 16:39:52 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:47377,Safety,safe,safe,47377,"fier code, that will be passed to coefficient(); to identify the basis function for which the coefficient is requested. If the; resolution model used does not support the declared basis function, code -1 is; returned. Bool_t changeModel(const RooResolutionModel& newModel); Change the current resolution model to newModel. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates res",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:50430,Safety,unsafe,unsafe,50430,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:14859,Security,hash,hash,14859,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:15010,Security,hash,hash,15010,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const Roo",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:41592,Security,validat,validate,41592,,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:42812,Security,access,access,42812,efCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:51607,Security,access,access,51607,"ntegration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sat Sep 5 16:39:52 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:10911,Testability,test,testArg,10911," RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tdeclareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:11005,Testability,test,testArg,11005," RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tdeclareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:23736,Testability,log,logEvalError,23736,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:23835,Testability,log,logEvalError,23835,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:24946,Testability,test,testArg,24946," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:25041,Testability,test,testArg,25041,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:26043,Testability,test,testArg,26043,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:4639,Usability,clear,clearEvalError,4639,", Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:4680,Usability,clear,clearEvalErrorLog,4680,"al RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCd",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:4716,Usability,clear,clearShapeDirty,4716,"edGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooA",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:4756,Usability,clear,clearValueAndShapeDirty,4756,"erbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAb",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsAnaConvPdf.html:4804,Usability,clear,clearValueDirty,4804,"hNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const",MatchSource.WIKI,root/html534/RooAbsAnaConvPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html
https://root.cern/root/html534/RooAbsArg.html:1211,Availability,avail,available,1211,"s; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidchangeServer(RooAbsArg& server, Bool_t va",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:4391,Availability,error,error,4391,""")MENU ; Bool_tdependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tdependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tdependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_t",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:4475,Availability,error,error,4475,"onst; Bool_tdependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tdependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tfnv1a64(const char* data); static ULong64_tfnv1a64(const char* data, ULong_t sz, ULo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:21261,Availability,mask,mask,21261,"f this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Change dirty flag propagation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all branch nodes of the arg tree starting with; ourself as top node. A branch node is node that has one or more servers declared. void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with nodes of the arg tree, following all server links,; starting with ourself as top node. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const; Create a lis",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24095,Availability,error,error,24095," const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservab",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:26184,Availability,error,error,26184,"AbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. RooAbsArg * findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; Find the new server in the specified set that matches the old server.; Allow a name change if nameChange is kTRUE, in which case the new; server is selected by searching for a new server with an attribute; of ""ORIGNAME:<oldName>"". Return zero if there is not a unique match. Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); Recursively redirect all servers with new server in collection 'newSet'.; Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:27153,Availability,error,error,27153,"ing is printed and error status is returned if not all servers could be sucessfully; substituted. RooAbsArg * findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; Find the new server in the specified set that matches the old server.; Allow a name change if nameChange is kTRUE, in which case the new; server is selected by searching for a new server with an attribute; of ""ORIGNAME:<oldName>"". Return zero if there is not a unique match. Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); Recursively redirect all servers with new server in collection 'newSet'.; Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the pr",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:27608,Deployability,update,updates,27608," unique match. Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); Recursively redirect all servers with new server in collection 'newSet'.; Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:28119,Deployability,update,updates,28119," is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:28566,Deployability,update,updates,28566," pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34200,Deployability,update,update,34200,"s. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34375,Deployability,update,update,34375,"m.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34557,Deployability,update,update,34557,"e; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooAr",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:40759,Deployability,integrat,integrated,40759,"; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testA",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:445,Integrability,depend,depends,445,". RooAbsArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:714,Integrability,depend,depends,714,". RooAbsArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:971,Integrability,interface,interfaces,971,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALS",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:20521,Integrability,depend,depend,20521,"g propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Change dirty flag propagation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:20604,Integrability,depend,dependence,20604,"Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Change dirty flag propagation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* li",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:20988,Integrability,depend,depend,20988,"y'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Change dirty flag propagation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all branch nodes of the arg tree starting with; ourself as top node. A branch node is node that has one or more servers declared. void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:22375,Integrability,depend,dependents,22375,"agation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all branch nodes of the arg tree starting with; ourself as top node. A branch node is node that has one or more servers declared. void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with nodes of the arg tree, following all server links,; starting with ourself as top node. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). void addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; INTERNAL helper function for getParameters(). RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:23259,Integrability,depend,dependents,23259,"sData* data, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). void addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; INTERNAL helper function for getParameters(). RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveChe",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24279,Integrability,depend,dependsOn,24279,"function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* s",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24407,Integrability,depend,depend,24407,"function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* s",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24487,Integrability,depend,dependsOn,24487,"t of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the obj",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24533,Integrability,depend,dependsOn,24533,"supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsA",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24650,Integrability,depend,depend,24650,"supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsA",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25037,Integrability,depend,dependents,25037,"the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25239,Integrability,depend,dependents,25239,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30137,Integrability,depend,dependent,30137,"es. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30338,Integrability,depend,dependent,30338,"lete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observa",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30993,Integrability,depend,depend,30993," set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31497,Integrability,depend,depend,31497,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperM",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34659,Integrability,interface,interface,34659,"Pat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:38338,Integrability,depend,dependsOnValue,38338," of RooAbsArg-derived; classes that are container classes with references to other members, which may; not yet be 'live' in the first ioStreamer() evolution pass. Classes may overload this function, but must call the base method in the; overloaded call to ensure base evolution is handled properly. void ioStreamerPass2Finalize(); Method called by workspace container to finalize schema evolution issues; that cannot be handled in a single ioStreamer pass. This static finalize method; is called after ioStreamerPass2() is called on each directly listed object; in the workspace. It's purpose is to complete schema evolution of any; objects in the workspace that are not directly listed as content elements; (e.g. analytical convolution tokens ). TObject* clone(const char* newname = 0) const. TObject* Clone(const char* newname = 0) const. Bool_t isDerived() const; Accessors to client-server relation information. Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of any of of the values in serverList?. Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of server?. Bool_t hasClients() const; { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }. TIterator* clientIterator() const; Return iterator over all client RooAbsArgs. TIterator* valueClientIterator() const; Return iterator over all value client RooAbsArgs. TIterator* shapeClientIterator() const; Return iterator over all shape client RooAbsArgs. TIterator* serverIterator() const; Return iterator over all server RooAbsArgs. RooFIter valueClientMIterator() const; { return _clientListValue.fwdIterator() ; }. RooFIter shapeClientMIterator() const; { return _clientListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. Roo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:38442,Integrability,depend,depend,38442," of RooAbsArg-derived; classes that are container classes with references to other members, which may; not yet be 'live' in the first ioStreamer() evolution pass. Classes may overload this function, but must call the base method in the; overloaded call to ensure base evolution is handled properly. void ioStreamerPass2Finalize(); Method called by workspace container to finalize schema evolution issues; that cannot be handled in a single ioStreamer pass. This static finalize method; is called after ioStreamerPass2() is called on each directly listed object; in the workspace. It's purpose is to complete schema evolution of any; objects in the workspace that are not directly listed as content elements; (e.g. analytical convolution tokens ). TObject* clone(const char* newname = 0) const. TObject* Clone(const char* newname = 0) const. Bool_t isDerived() const; Accessors to client-server relation information. Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of any of of the values in serverList?. Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of server?. Bool_t hasClients() const; { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }. TIterator* clientIterator() const; Return iterator over all client RooAbsArgs. TIterator* valueClientIterator() const; Return iterator over all value client RooAbsArgs. TIterator* shapeClientIterator() const; Return iterator over all shape client RooAbsArgs. TIterator* serverIterator() const; Return iterator over all server RooAbsArgs. RooFIter valueClientMIterator() const; { return _clientListValue.fwdIterator() ; }. RooFIter shapeClientMIterator() const; { return _clientListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. Roo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:38509,Integrability,depend,dependsOnValue,38509,"tion pass. Classes may overload this function, but must call the base method in the; overloaded call to ensure base evolution is handled properly. void ioStreamerPass2Finalize(); Method called by workspace container to finalize schema evolution issues; that cannot be handled in a single ioStreamer pass. This static finalize method; is called after ioStreamerPass2() is called on each directly listed object; in the workspace. It's purpose is to complete schema evolution of any; objects in the workspace that are not directly listed as content elements; (e.g. analytical convolution tokens ). TObject* clone(const char* newname = 0) const. TObject* Clone(const char* newname = 0) const. Bool_t isDerived() const; Accessors to client-server relation information. Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of any of of the values in serverList?. Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of server?. Bool_t hasClients() const; { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }. TIterator* clientIterator() const; Return iterator over all client RooAbsArgs. TIterator* valueClientIterator() const; Return iterator over all value client RooAbsArgs. TIterator* shapeClientIterator() const; Return iterator over all shape client RooAbsArgs. TIterator* serverIterator() const; Return iterator over all server RooAbsArgs. RooFIter valueClientMIterator() const; { return _clientListValue.fwdIterator() ; }. RooFIter shapeClientMIterator() const; { return _clientListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServe",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:38602,Integrability,depend,depend,38602,"tion pass. Classes may overload this function, but must call the base method in the; overloaded call to ensure base evolution is handled properly. void ioStreamerPass2Finalize(); Method called by workspace container to finalize schema evolution issues; that cannot be handled in a single ioStreamer pass. This static finalize method; is called after ioStreamerPass2() is called on each directly listed object; in the workspace. It's purpose is to complete schema evolution of any; objects in the workspace that are not directly listed as content elements; (e.g. analytical convolution tokens ). TObject* clone(const char* newname = 0) const. TObject* Clone(const char* newname = 0) const. Bool_t isDerived() const; Accessors to client-server relation information. Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of any of of the values in serverList?. Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; Does this arg depend on the value of server?. Bool_t hasClients() const; { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }. TIterator* clientIterator() const; Return iterator over all client RooAbsArgs. TIterator* valueClientIterator() const; Return iterator over all value client RooAbsArgs. TIterator* shapeClientIterator() const; Return iterator over all shape client RooAbsArgs. TIterator* serverIterator() const; Return iterator over all server RooAbsArgs. RooFIter valueClientMIterator() const; { return _clientListValue.fwdIterator() ; }. RooFIter shapeClientMIterator() const; { return _clientListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServe",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:40759,Integrability,integrat,integrated,40759,"; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testA",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41562,Integrability,depend,dependentOverlaps,41562,", ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<s",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41691,Integrability,depend,dependentOverlaps,41691,"ytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Co",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:42163,Integrability,interface,interface,42163,"rn the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:42298,Integrability,interface,interface,42298,"-- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). CacheMode canNodeBeCached() const; { return Always ; }. void setCacheAndTrackHints(RooArgSet& ); {}. Bool_t isShapeDirty() const; Dirty state accessor. Bo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:43099,Integrability,interface,interface,43099,"l_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). CacheMode canNodeBeCached() const; { return Always ; }. void setCacheAndTrackHints(RooArgSet& ); {}. Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:22330,Modifiability,variab,variable,22330,"agation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all branch nodes of the arg tree starting with; ourself as top node. A branch node is node that has one or more servers declared. void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with nodes of the arg tree, following all server links,; starting with ourself as top node. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). void addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; INTERNAL helper function for getParameters(). RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:23214,Modifiability,variab,variable,23214,"sData* data, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). void addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; INTERNAL helper function for getParameters(). RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveChe",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24038,Modifiability,variab,variables,24038," returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAb",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30065,Modifiability,variab,variable,30065,"es. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30101,Modifiability,variab,variables,30101,"es. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30266,Modifiability,variab,variable,30266,"lete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observa",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30302,Modifiability,variab,variables,30302,"lete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observa",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:33804,Modifiability,variab,variables,33804,"Pat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35543,Modifiability,variab,variables,35543,"sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >& ); Utility function that inserts all point-to-point client-serv",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:2079,Performance,cache,cacheUniqueSuffix,2079," virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:4795,Performance,cache,cacheList,4795,"pendsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tfnv1a64(const char* data); static ULong64_tfnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tgetAttribute(const Text_t* name) const; RooAbsCache*getCache(Int_t index) const; RooLinkedListgetCloningAncestors() const; RooArgSet*getComponents() const; RooArgSet*getDependents(const RooArgSet& set) const; RooArgSet*getDependents(const RooAbsData* set) const; RooArgSet*getDependents(",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:4872,Performance,cache,cacheList,4872," 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tfnv1a64(const char* data); static ULong64_tfnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tgetAttribute(const Text_t* name) const; RooAbsCache*getCache(Int_t index) const; RooLinkedListgetCloningAncestors() const; RooArgSet*getComponents() const; RooArgSet*getDependents(const RooArgSet& set) const; RooArgSet*getDependents(const RooAbsData* set) const; RooArgSet*getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:12149,Performance,cache,cache,12149,"tream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidprintTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_trecursiveCheckDependents(const RooArgSet* nset) const; Bool_trecursiveCheckObservables(const RooArgSet* nset) const; Bool_trecursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tredirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidregisterCache(RooAbsCache& cache); voidremoveServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*serverIterator() const; RooFIterserverMIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetLocalNoDirtyInhibit(Bool_t flag) const; virtual voidSetName(const char* name); virtual voidSetNam",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:13040,Performance,cache,cache,13040,"ool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidregisterCache(RooAbsCache& cache); voidremoveServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*serverIterator() const; RooFIterserverMIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetLocalNoDirtyInhibit(Bool_t flag) const; virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; RooFItershapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; B",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:14397,Performance,cache,cache,14397,"Option(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetLocalNoDirtyInhibit(Bool_t flag) const; virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; RooFItershapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&transientAttributes() const; voidtreeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidunRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*valueClientIterator() const; RooFItervalueClientMIterator() const; static voidverboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidwireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:17393,Performance,cache,caches,17393,"WriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status ; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attribut",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:17851,Performance,cache,cache,17851,"WriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status ; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attribut",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:19330,Performance,cache,cache,19330,"named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribu",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:27619,Performance,cache,cached,27619," unique match. Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); Recursively redirect all servers with new server in collection 'newSet'.; Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:28130,Performance,cache,cached,28130," is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:28577,Performance,cache,cached,28577," pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:29009,Performance,cache,cached,29009,"by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30769,Performance,optimiz,optimizeCacheMode,30769,"ntTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-c",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30827,Performance,cache,cache,30827,"ntTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-c",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30838,Performance,optimiz,optimization,30838,"ntTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-c",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:30894,Performance,cache,cache,30894," set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31221,Performance,optimiz,optimizeCacheMode,31221,"ariables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE);",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31331,Performance,cache,cache,31331,"ariables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE);",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31342,Performance,optimiz,optimization,31342,"ariables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE);",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31398,Performance,cache,cache,31398,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperM",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31786,Performance,cache,cacheList,31786,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31893,Performance,cache,cached,31893,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32014,Performance,cache,cacheList,32014,"ty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly d",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32152,Performance,cache,cached,32152,"ty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly d",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32347,Performance,perform,perform,32347,"inkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32370,Performance,optimiz,optimization,32370,"inkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32558,Performance,cache,cache,32558," of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34840,Performance,cache,cache,34840,"s not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* del",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35051,Performance,cache,cache,35051,"; Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on conce",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35106,Performance,cache,cache,35106,"; Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on conce",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35137,Performance,cache,cache,35137,"; Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on conce",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35234,Performance,cache,cache,35234,"t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false);",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35361,Performance,cache,caches,35361,"ng_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given o",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:35429,Performance,cache,cache,35429,"t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConn",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:43864,Performance,optimiz,optimizeDirtyHook,43864,"& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). CacheMode canNodeBeCached() const; { return Always ; }. void setCacheAndTrackHints(RooArgSet& ); {}. Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44325,Performance,cache,cacheUniqueSuffix,44325,"been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44625,Performance,cache,cache,44625," Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44647,Performance,cache,cache,44647," Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24131,Safety,abort,abort,24131," const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservab",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:5356,Security,hash,hash,5356,"thod, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tfnv1a64(const char* data); static ULong64_tfnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tgetAttribute(const Text_t* name) const; RooAbsCache*getCache(Int_t index) const; RooLinkedListgetCloningAncestors() const; RooArgSet*getComponents() const; RooArgSet*getDependents(const RooArgSet& set) const; RooArgSet*getDependents(const RooAbsData* set) const; RooArgSet*getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*getObservables(const RooAbsData* data) const; RooArgSet*getObservables(const RooAbsData& data) const; RooArgSet*getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooArgSet*getObservables(const RooArgSet* depList, Bo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:5485,Security,hash,hash,5485,"virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tfindConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*findServer(const char* name) const; RooAbsArg*findServer(const RooAbsArg& arg) const; RooAbsArg*findServer(Int_t index) const; static UInt_tfnv1a32(const char* data); static UInt_tfnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tfnv1a64(const char* data); static ULong64_tfnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tgetAttribute(const Text_t* name) const; RooAbsCache*getCache(Int_t index) const; RooLinkedListgetCloningAncestors() const; RooArgSet*getComponents() const; RooArgSet*getDependents(const RooArgSet& set) const; RooArgSet*getDependents(const RooAbsData* set) const; RooArgSet*getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*getObservables(const RooAbsData* data) const; RooArgSet*getObservables(const RooAbsData& data) const; RooArgSet*getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooArgSet*getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; virtual Option_t*TObject::GetOption() const; RooArgSet*getParameters(const RooAbsData* data, Bool_",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:17940,Security,access,access,17940,"WriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status ; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attribut",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34114,Security,checksum,checksum,34114," nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34285,Security,hash,hash,34285,"at = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCac",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34353,Security,hash,hash,34353,"m.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34395,Security,hash,hash,34395,"m.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34461,Security,hash,hash,34461,"The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache obj",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34535,Security,hash,hash,34535,"e; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooAr",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:34577,Security,hash,hash,34577,"e; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooAr",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:43274,Security,access,accessor,43274,"t(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). CacheMode canNodeBeCached() const; { return Always ; }. void setCacheAndTrackHints(RooArgSet& ); {}. Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:1048,Testability,test,testing,1048,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALS",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:3468,Testability,test,testArg,3468,"arShapeDirty() const; voidclearValueAndShapeDirty() const; voidclearValueDirty() const; TIterator*clientIterator() const; virtual TObject*clone(const char* newname = 0) const; virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsArg*cloneTree(const char* newname = 0) const; virtual Int_tCompare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tcrc32(const char* data); static UInt_tcrc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tdependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tdependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:3551,Testability,test,testArg,3551,"nst; TIterator*clientIterator() const; virtual TObject*clone(const char* newname = 0) const; virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsArg*cloneTree(const char* newname = 0) const; virtual Int_tCompare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tcrc32(const char* data); static UInt_tcrc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tdependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tdependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:9153,Testability,test,testArg,9153,"ual Bool_tisIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueDirtyAndClear() const; Bool_tisValueOrShapeDirtyAndClear() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tlocalNoDirtyInhibit() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedCompon",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:9237,Testability,test,testArg,9237,"al Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueDirtyAndClear() const; Bool_tisValueOrShapeDirtyAndClear() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tlocalNoDirtyInhibit() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:10087,Testability,test,testArg,10087,"_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidprintAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; voidprintCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidprintCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidprintCompactTreeHook(ostream& os, const char* ind = """"); voidprintComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidprintDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream&) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidp",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:24819,Testability,test,testArg,24819,"pression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Boo",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25002,Testability,test,testArg,25002,"the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25126,Testability,test,testArg,25126,"the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25204,Testability,test,testArg,25204,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:25328,Testability,test,testArg,25328,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:31920,Testability,test,test,31920,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:32179,Testability,test,test,32179,"ty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly d",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:40168,Testability,test,test,40168,"tListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServer(Int_t index) const; Return i-th server from server list. Bool_t isValueServer(const RooAbsArg& arg) const; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:40225,Testability,test,test,40225,"tListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServer(Int_t index) const; Return i-th server from server list. Bool_t isValueServer(const RooAbsArg& arg) const; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. ",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41621,Testability,test,testArg,41621,", ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<s",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41670,Testability,test,testArg,41670,", ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<s",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41752,Testability,test,testArg,41752,"ytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Co",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:41805,Testability,test,testArg,41805,"ytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Co",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:1039,Usability,clear,clearing,1039,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALS",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:19646,Usability,clear,clear,19646," needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:20188,Usability,clear,clear,20188,"~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void change",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44220,Usability,clear,clearValueAndShapeDirty,44220,"Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44258,Usability,clear,clearValueDirty,44258," state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated.",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsArg.html:44288,Usability,clear,clearShapeDirty,44288,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html534/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsArg.html
https://root.cern/root/html534/RooAbsBinning.html:615,Availability,avail,available,615,". RooAbsBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsBinning. class RooAbsBinning: public TNamed, public RooPrintable. RooAbsBinning is the abstract base class for RooRealVar binning definitions; This class defines the interface to retrieve bin boundaries, ranges etc.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_t*array() const; virtual Double_taverageBinWidth() const; virtual Double_tbinCenter(Int_t bin) const; virtual Double_tbinHigh(Int_t bin) const; virtual Double_tbinLow(Int_t bin) const; virtual Int_tbinNumber(Double_t x) const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:2144,Availability,error,error,2144," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*highBoundFunc() const; virtual voidTO",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:2228,Availability,error,error,2228,"virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*highBoundFunc() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::In",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:428,Integrability,interface,interface,428,". RooAbsBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsBinning. class RooAbsBinning: public TNamed, public RooPrintable. RooAbsBinning is the abstract base class for RooRealVar binning definitions; This class defines the interface to retrieve bin boundaries, ranges etc.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_t*array() const; virtual Double_taverageBinWidth() const; virtual Double_tbinCenter(Int_t bin) const; virtual Double_tbinHigh(Int_t bin) const; virtual Double_tbinLow(Int_t bin) const; virtual Int_tbinNumber(Double_t x) const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9270,Integrability,interface,interface,9270,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9756,Integrability,interface,interface,9756,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9879,Integrability,interface,interface,9879,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:8203,Modifiability,variab,variable,8203,". Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsBinning(); Destructor. void printName(ostream& os) const; Print binning name. void printTitle(ostream& os) const; Print binning title. void printClassName(ostream& os) const; Print binning class name. void printArgs(ostream& os) const; Print binning arguments (the RooAbsReal objects represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth(",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:8231,Modifiability,parameteriz,parameterized,8231,". Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsBinning(); Destructor. void printName(ostream& os) const; Print binning name. void printTitle(ostream& os) const; Print binning title. void printClassName(ostream& os) const; Print binning class name. void printArgs(ostream& os) const; Print binning arguments (the RooAbsReal objects represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth(",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9364,Modifiability,parameteriz,parameterized,9364,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9466,Modifiability,parameteriz,parameterized,9466,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsBinning.html:9565,Modifiability,parameteriz,parameterized,9565,"ts represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html
https://root.cern/root/html534/RooAbsCache.html:426,Integrability,interface,interface,426,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:362,Performance,cache,cache,362,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:505,Performance,cache,cache,505,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:598,Performance,optimiz,optimization,598,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1607,Performance,cache,cache,1607,"m optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1737,Performance,cache,cache,1737,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1794,Performance,cache,cache,1794,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1817,Performance,optimiz,optimizeCacheMode,1817,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1913,Performance,cache,cache,1913,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:1924,Performance,optimiz,optimization,1924,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCache.html:2320,Performance,cache,cache,2320,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCache.html
https://root.cern/root/html534/RooAbsCachedPdf.html:1233,Availability,avail,available,1233," ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:10720,Availability,error,error,10720,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:10804,Availability,error,error,10804,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41695,Availability,error,errors,41695,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40443,Deployability,integrat,integration,40443,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40509,Deployability,integrat,integration,40509,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41969,Deployability,integrat,integration,41969,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44055,Deployability,configurat,configuration,44055," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44152,Deployability,integrat,integrator,44152," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44163,Deployability,configurat,configuration,44163," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45902,Deployability,configurat,configuration,45902,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46198,Deployability,integrat,integration,46198,"et = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCache",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46375,Deployability,integrat,integration,46375," evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; R",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46637,Deployability,integrat,integration,46637,"e histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(con",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:7764,Integrability,depend,dependentVars,7764,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9254,Integrability,depend,dependentOverlaps,9254,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9346,Integrability,depend,dependentOverlaps,9346,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9440,Integrability,depend,dependsOn,9440,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9569,Integrability,depend,dependsOn,9569,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9687,Integrability,depend,dependsOnValue,9687,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9794,Integrability,depend,dependsOnValue,9794,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:21904,Integrability,message,message,21904,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:22055,Integrability,message,message,22055,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40443,Integrability,integrat,integration,40443,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40509,Integrability,integrat,integration,40509,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41969,Integrability,integrat,integration,41969,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44152,Integrability,integrat,integrator,44152," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46198,Integrability,integrat,integration,46198,"et = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCache",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46375,Integrability,integrat,integration,46375," evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; R",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46637,Integrability,integrat,integration,46637,"e histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(con",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:11120,Modifiability,extend,extendedTerm,11120,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:11232,Modifiability,extend,extendMode,11232,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:14734,Modifiability,extend,extended,14734,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:14888,Modifiability,extend,extended,14888,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:29812,Modifiability,config,config,29812,"ect::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCou",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:29970,Modifiability,config,config,29970,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:35120,Modifiability,extend,extended,35120,"heElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, Ro",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44055,Modifiability,config,configuration,44055," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44163,Modifiability,config,configuration,44163," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45902,Modifiability,config,configuration,45902,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:393,Performance,cache,cache,393,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:550,Performance,cache,cache,550,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:919,Performance,cache,cached,919,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:1079,Performance,cache,cache,1079,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:2759,Performance,cache,cacheUniqueSuffix,2759,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname =",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:11841,Performance,cache,cacheList,11841,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:11929,Performance,cache,cacheList,11929,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:23970,Performance,optimiz,optimizeCacheMode,23970,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:24042,Performance,optimiz,optimizeCacheMode,24042,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:28421,Performance,cache,cache,28421,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setD",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:29710,Performance,cache,cache,29710,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, cons",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:32383,Performance,cache,cache,32383,"nit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:33964,Performance,cache,cache,33964,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:34547,Performance,cache,cache,34547,", const char* binnedTag = """") const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnection",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:36943,Performance,optimiz,optimizeDirtyHook,36943,"etCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40726,Performance,cache,cache,40726,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40810,Performance,cache,cache,40810,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41009,Performance,cache,caches,41009,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41048,Performance,cache,cache,41048,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41591,Performance,cache,cache,41591,":string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' m",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41870,Performance,cache,cache,41870,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:42284,Performance,cache,cache,42284,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:42367,Performance,cache,cache,42367,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:42951,Performance,cache,cache,42951,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:43622,Performance,cache,cache,43622,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:44421,Performance,cache,cache,44421," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45265,Performance,cache,cache,45265,tribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& ,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45444,Performance,cache,cache,45444,"cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45577,Performance,cache,cache,45577," for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45679,Performance,cache,cache,45679,"ic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45716,Performance,cache,cache,45716,"ic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45757,Performance,cache,cacheNameSuffix,45757,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45843,Performance,cache,cache,45843,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45896,Performance,cache,cache,45896,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46016,Performance,cache,cache,46016,"s. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return R",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46434,Performance,cache,cache,46434," pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) c",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46449,Performance,cache,cache,46449,"f observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inpu",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46696,Performance,cache,cache,46696,"e) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histOb",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46711,Performance,cache,cache,46711,"ed (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:46913,Performance,cache,cache,46913," names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:47010,Performance,cache,cached,47010,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page ha",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:47115,Performance,cache,cached,47115," forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:47354,Performance,cache,cache,47354,"const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:47434,Performance,cache,cache,47434,"const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:47749,Performance,cache,cache,47749,"const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:13261,Security,hash,hash,13261,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgS",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:13412,Security,hash,hash,13412,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:40905,Security,validat,validate,40905,,MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:41791,Security,access,access,41791,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9313,Testability,test,testArg,9313,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:9407,Testability,test,testArg,9407,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:21879,Testability,log,logEvalError,21879,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:21978,Testability,log,logEvalError,21978,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:23089,Testability,test,testArg,23089," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:23184,Testability,test,testArg,23184,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:24186,Testability,test,testArg,24186,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:3343,Usability,clear,clearEvalError,3343,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const R",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:3384,Usability,clear,clearEvalErrorLog,3384,"s(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:3420,Usability,clear,clearShapeDirty,3420,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none()",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:3460,Usability,clear,clearValueAndShapeDirty,3460,"(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(),",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:3508,Usability,clear,clearValueDirty,3508,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), ",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedPdf.html:45631,Usability,clear,clearCacheObject,45631,"ic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html534/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html
https://root.cern/root/html534/RooAbsCachedReal.html:1246,Availability,avail,available,1246,"FIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData&",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:10844,Availability,error,error,10844,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:10928,Availability,error,error,10928,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33445,Deployability,integrat,integration,33445,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:34806,Deployability,integrat,integration,34806,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36403,Deployability,integrat,integrator,36403,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36414,Deployability,configurat,configuration,36414,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37977,Deployability,integrat,integration,37977," dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& ns",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:38520,Deployability,integrat,integration,38520," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:8142,Integrability,depend,dependentVars,8142,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9384,Integrability,depend,dependentOverlaps,9384,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9476,Integrability,depend,dependentOverlaps,9476,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9570,Integrability,depend,dependsOn,9570,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9699,Integrability,depend,dependsOn,9699,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9817,Integrability,depend,dependsOnValue,9817,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9924,Integrability,depend,dependsOnValue,9924,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:18086,Integrability,message,message,18086,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:18237,Integrability,message,message,18237,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33445,Integrability,integrat,integration,33445,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:34806,Integrability,integrat,integration,34806,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36403,Integrability,integrat,integrator,36403,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37977,Integrability,integrat,integration,37977," dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& ns",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:38520,Integrability,integrat,integration,38520," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:24997,Modifiability,config,config,24997,"; virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36414,Modifiability,config,configuration,36414,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:400,Performance,cache,cache,400,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:559,Performance,cache,cache,559,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:932,Performance,cache,cached,932,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:1092,Performance,cache,cache,1092,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:2773,Performance,cache,cacheUniqueSuffix,2773,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:11662,Performance,cache,cacheList,11662,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:11750,Performance,cache,cacheList,11750,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:20070,Performance,optimiz,optimizeCacheMode,20070,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:20142,Performance,optimiz,optimizeCacheMode,20142,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:23617,Performance,cache,cache,23617,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Optio",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:24840,Performance,cache,cache,24840,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsRe",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:26979,Performance,cache,cache,26979,"RooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:28146,Performance,cache,cache,28146,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:28702,Performance,cache,cache,28702,"Store(RooAbsDataStore& store); virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) con",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:30615,Performance,optimiz,optimizeDirtyHook,30615,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual const char*payloadUniqueSuffix() const; virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = k",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33662,Performance,cache,cache,33662,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33746,Performance,cache,cache,33746,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33945,Performance,cache,caches,33945,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33986,Performance,cache,cache,33986,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:34528,Performance,cache,cache,34528,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:34707,Performance,cache,cache,34707,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:35121,Performance,cache,cache,35121,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:35204,Performance,cache,cache,35204,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36055,Performance,cache,cache,36055,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:36608,Performance,cache,cache,36608,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37406,Performance,cache,cache,37406,"eric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represe",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37555,Performance,cache,cache,37555," not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Boo",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37618,Performance,cache,cacheNameSuffix,37618,"hes ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. c",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37697,Performance,cache,cache,37697,"hes ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. c",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37811,Performance,cache,cache,37811," Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:38401,Performance,cache,cache,38401," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:38785,Performance,cache,cache,38785," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:39074,Performance,cache,cache,39074," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:12594,Security,hash,hash,12594,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:12745,Security,hash,hash,12745,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tRooAbsReal::getForceNumIn",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:33841,Security,validat,validate,33841,,MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:34628,Security,access,access,34628,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9443,Testability,test,testArg,9443,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:9537,Testability,test,testArg,9537,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:18061,Testability,log,logEvalError,18061,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:18160,Testability,log,logEvalError,18160,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:19189,Testability,test,testArg,19189,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:19284,Testability,test,testArg,19284,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:20286,Testability,test,testArg,20286," RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:4228,Usability,clear,clearEvalErrorLog,4228,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:4264,Usability,clear,clearShapeDirty,4264,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:4304,Usability,clear,clearValueAndShapeDirty,4304,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:4352,Usability,clear,clearValueDirty,4352,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCachedReal.html:37505,Usability,clear,clearCacheObject,37505," not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Boo",MatchSource.WIKI,root/html534/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html
https://root.cern/root/html534/RooAbsCacheElement.html:712,Availability,avail,available,712,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:447,Integrability,interface,interface,447,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:394,Performance,cache,cache,394,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:545,Performance,optimiz,optimization,545,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:923,Performance,cache,cacheList,923,"C source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. voi",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2008,Performance,cache,cache,2008,"ss*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2145,Performance,optimiz,optimizeCacheMode,2145,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2252,Performance,cache,cache,2252,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2258,Performance,optimiz,optimization,2258,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2465,Performance,cache,cacheList,2465,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCacheElement.html:2536,Performance,optimiz,optimization,2536,"k(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html
https://root.cern/root/html534/RooAbsCategory.html:809,Availability,avail,available,809,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:4395,Availability,error,error,4395,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static U",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:4479,Availability,error,error,4479,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); s",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:23298,Availability,avail,available,23298,"f current state. const char* getLabel() const; Return label string of current state. RooCatType traceEval() const; Recalculate current value and check validity of new result. TIterator* typeIterator() const; Return iterator over all defined states. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:26755,Deployability,integrat,integration,26755,"fSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Mar 10 17:13:55 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:584,Integrability,interface,interface,584,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:644,Integrability,interface,interface,644,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3358,Integrability,depend,dependentOverlaps,3358,"rg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3450,Integrability,depend,dependentOverlaps,3450," virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3544,Integrability,depend,dependsOn,3544,"Arg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3673,Integrability,depend,dependsOn,3673,"::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3791,Integrability,depend,dependsOnValue,3791,"TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3898,Integrability,depend,dependsOnValue,3898," char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:25569,Integrability,synchroniz,synchronize,25569,"os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(con",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:26755,Integrability,integrat,integration,26755,"fSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Mar 10 17:13:55 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:1792,Performance,cache,cacheUniqueSuffix,1792," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:4821,Performance,cache,cacheList,4821,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponen",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:4909,Performance,cache,cacheList,4909,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*Ro",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:11288,Performance,optimiz,optimizeCacheMode,11288,"ata* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:11360,Performance,optimiz,optimizeCacheMode,11360,"verlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:13772,Performance,cache,cache,13772,"g indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidR",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:14762,Performance,cache,cache,14762,"Cache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::str",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:16316,Performance,cache,cache,16316,"st char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:18180,Performance,optimiz,optimizeDirtyHook,18180,"ual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore& vstore); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:20103,Performance,cache,cache,20103,"ption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_ser",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:20193,Performance,cache,caches,20193,"ption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_ser",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:20728,Performance,cache,cache,20728,"ption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_ser",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:25605,Performance,cache,cache,25605,"os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(con",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:25719,Performance,cache,cached,25719,"printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(c",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:25834,Performance,cache,cache,25834,"ied stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PA",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:26739,Safety,safe,safe,26739,"fSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Mar 10 17:13:55 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:5459,Security,hash,hash,5459,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*R",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:5610,Security,hash,hash,5610,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooA",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:20828,Security,access,access,20828,"ption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_ser",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3417,Testability,test,testArg,3417,":clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:3511,Testability,test,testArg,3511,"0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:10325,Testability,test,testArg,10325,"ooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observ",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:10420,Testability,test,testArg,10420,"arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNo",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:11504,Testability,test,testArg,11504,"ar* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:2237,Usability,clear,clearShapeDirty,2237," serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::d",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:2277,Usability,clear,clearValueAndShapeDirty,2277,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:2325,Usability,clear,clearValueDirty,2325,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """"",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategory.html:23617,Usability,clear,clearTypes,23617,"compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root/html534/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:872,Availability,avail,available,872,". RooAbsCategoryLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategoryLValue. class RooAbsCategoryLValue: public RooAbsCategory, public RooAbsLValue. RooAbsCategoryLValue is the common abstract base class for objects that represent a; discrete value that may appear on the left hand side of an equation ('lvalue'); Each implementation must provide setIndex()/setLabel() members to allow direct modification ; of the value. RooAbsCategoryLValue may be derived, but its functional relation; to other RooAbsArgs must be invertible; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bo",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:4496,Availability,error,error,4496,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static U",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:4580,Availability,error,error,4580,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); s",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3459,Integrability,depend,dependentOverlaps,3459,"ual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3551,Integrability,depend,dependentOverlaps,3551,"e(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3645,Integrability,depend,dependsOn,3645,"me = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3774,Integrability,depend,dependsOn,3774,"AbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3892,Integrability,depend,dependsOnValue,3892,"nt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3999,Integrability,depend,dependsOnValue,3999,"crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:1861,Performance,cache,cacheUniqueSuffix,1861," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bo",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:4922,Performance,cache,cacheList,4922,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinnin",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:5010,Performance,cache,cacheList,5010,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Do",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:12052,Performance,optimiz,optimizeCacheMode,12052,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:12124,Performance,optimiz,optimizeCacheMode,12124," voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:14618,Performance,cache,cache,14618,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:15706,Performance,cache,cache,15706,"g::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:17410,Performance,cache,cache,17410," const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:19501,Performance,optimiz,optimizeDirtyHook,19501,"CatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:21598,Performance,cache,cache,21598,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:21688,Performance,cache,caches,21688,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:22223,Performance,cache,cache,22223,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:24348,Performance,cache,cached,24348,"typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t pr",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:24463,Performance,cache,cache,24463,"irtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTRUE). Int_t getBin(const char* rangeName = 0) const. Double_t getBinWidth(Int_t , const char* = 0) const; Return volume of i-t",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:5560,Security,hash,hash,5560,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAb",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:5711,Security,hash,hash,5711,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::Get",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:22323,Security,access,access,22323,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3518,Testability,test,testArg,3518,"const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:3612,Testability,test,testArg,3612,"bsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:10916,Testability,test,testArg,10916,"oAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtu",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:11011,Testability,test,testArg,11011,":leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::oper",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:12268,Testability,test,testArg,12268,"oid* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:2306,Usability,clear,clearShapeDirty,2306," serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrint",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:2346,Usability,clear,clearValueAndShapeDirty,2346,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintS",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:2394,Usability,clear,clearValueDirty,2394,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObje",MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCategoryLValue.html:18287,Usability,clear,clearTypes,18287,,MatchSource.WIKI,root/html534/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html
https://root.cern/root/html534/RooAbsCollection.html:879,Availability,avail,available,879,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidassignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:3053,Availability,error,error,3053,"ol_tcontainsInstance(const RooAbsArg& var) const; stringcontentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; RooAbsArg*find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; RooFIterfwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* tim",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:3137,Availability,error,error,3137,"ual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; RooAbsArg*find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; RooFIterfwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* met",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:18831,Availability,error,error,18831,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHash",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:18860,Availability,error,error,18860,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHash",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:19063,Availability,error,error,19063,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsIn",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:20751,Deployability,release,releaseOwnership,20751,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10207,Integrability,depend,dependencies,10207," { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10521,Integrability,depend,dependents,10521,"; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10569,Integrability,depend,dependents,10569,"; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10589,Integrability,depend,dependents,10589,"; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10736,Integrability,depend,dependents,10736,"oLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:11056,Integrability,depend,dependents,11056,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:11104,Integrability,depend,dependents,11104,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:11124,Integrability,depend,dependents,11124,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:11271,Integrability,depend,dependents,11271,"ny client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:20284,Integrability,interface,interface,20284,"NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated:",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:20549,Integrability,interface,interface,20549,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:12174,Modifiability,variab,variable,12174,"y is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this c",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:12564,Modifiability,variab,variable,12564," set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:12645,Modifiability,variab,variables,12645," set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:12778,Modifiability,variab,variables,12778,"ent operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:12933,Modifiability,variab,variable,12933,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:13004,Modifiability,variab,variables,13004,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:14357,Modifiability,variab,variable,14357,"element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is not already in this set,; or if var2 is already in this set. var1 and var2 do not need to have; the same name. Bool_t remove(const RooAbsArg& var, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove the specified argument from our list. Return kFALSE if; the specified argument is not found in our list. An exact pointer; match is required, not just a match by name. A variable can be; removed from a copied list and will be deleted at the same time. Bool_t remove(const RooAbsCollection& list, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove each argument in the input list from our list using remove(const RooAbsArg&).; Return kFALSE in case of problems. void removeAll(); Remove all arguments from our set, deleting them if we own them.; This effectively restores our object to the state it would have; just after calling the RooAbsCollection(const char*) constructor. void setAttribAll(const Text_t* name, Bool_t value = kTRUE); Set given attribute in each element of the collection by; calling each elements setAttribute() function. RooAbsCollection* selectByAttrib(const char* name, Bool_t value) const; Create a subset of the current collection, consisting only of those; elements with the specified attribute set. The caller is responsibe; for deleting the returned collection. RooAbsCollection* selectCommon(const RooAbsCollection& refColl) const; Create a subset of the current col",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:17806,Modifiability,variab,variable,17806," inline printing only show value of objects, for default print show; name,class name value and extras of each object. In verbose mode; also add object adress, argument and title. void printValue(ostream& os) const; Print value of collection, i.e. a comma separated list of contained; object names. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multiline printin of collection, one line for each ontained object showing; the requested content. void dump() const; Base contents dumper for debugging purposes. void printLatex(const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()) const; Output content of collection as LaTex table. By default a table with two columns is created: the left; column contains the name of each variable, the right column the value. The following optional named arguments can be used to modify the default behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:19160,Modifiability,variab,variable,19160,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsIn",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10167,Safety,safe,safeDeleteList,10167," { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:10252,Safety,safe,safe,10252," { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:672,Security,hash,hash-table,672,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidassignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:19956,Security,hash,hash,19956,"rols precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsCollection.html:21117,Usability,clear,clearStructureTags,21117,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html
https://root.cern/root/html534/RooAbsData.html:730,Availability,avail,available,730,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidconvertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRa",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:3660,Availability,error,error,3660,"const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; static RooAbsData::StorageTypegetDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpt",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:3744,Availability,error,error,3744,", const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; static RooAbsData::StorageTypegetDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tgetRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Do",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:18246,Availability,error,error,18246,"a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:18418,Availability,error,error,18418,"f data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataEr",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:19416,Availability,error,error,19416,"eight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWid",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:19532,Availability,error,error,19532,"const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:20743,Availability,error,error,20743,"e intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically ca",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:28192,Availability,error,error,28192,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) di",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:28221,Availability,error,error,28221,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) di",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:28424,Availability,error,error,28424,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; S",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:29140,Availability,error,error,29140,"ng structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; Split dataset into subsets based on states of given splitCat in this dataset.; A TList of RooDataSets is returned in which each RooDataSet is named; after the state name of splitCat of which it contains the dataset subset.; The observables splitCat itself is no longer present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binn",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:30711,Availability,error,error,30711," present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code,",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:30906,Availability,error,error,30906,"d dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t si",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:30951,Availability,error,error,30951,"d dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t si",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:32287,Availability,error,error,32287,"ization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOp",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35507,Availability,error,error,35507,"s; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14865,Deployability,release,releaseVars,14865,"Mask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const Ro",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:20032,Deployability,update,update,20032,"named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add construct",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:31455,Deployability,update,update,31455,"1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:8287,Energy Efficiency,reduce,reduce,8287,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:8323,Energy Efficiency,reduce,reduce,8323,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(B",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:8371,Energy Efficiency,reduce,reduce,8371,", const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:8439,Energy Efficiency,reduce,reduce,8439,"ect::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* o",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:8515,Energy Efficiency,reduce,reduce,8515,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed:",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:13322,Energy Efficiency,reduce,reduceEng,13322,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; e",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:15787,Energy Efficiency,reduce,reduce,15787,"ooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:16086,Energy Efficiency,reduce,reduced,16086,"ooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:16864,Energy Efficiency,reduce,reduce,16864,"arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaV",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17125,Energy Efficiency,reduce,reduce,17125,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17195,Energy Efficiency,reduce,reduce,17195,"et& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17408,Energy Efficiency,reduce,reduced,17408,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17445,Energy Efficiency,reduce,reduce,17445,"ents inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = R",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17787,Energy Efficiency,reduce,reduce,17787,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17857,Energy Efficiency,reduce,reduce,17857," on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binni",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:18147,Energy Efficiency,reduce,reduced,18147,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:38950,Energy Efficiency,reduce,reduceEng,38950," cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Sat Sep 5 16:39:53 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:412,Integrability,interface,interface,412,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidconvertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRa",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:37250,Integrability,interface,interface,37250,"TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Double_t weightSquared() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14218,Modifiability,variab,variables,14218," = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remov",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14260,Modifiability,variab,variables,14260," = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remov",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14394,Modifiability,variab,variables,14394," = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remov",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14916,Modifiability,variab,variables,14916,"Mask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const Ro",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17004,Modifiability,variab,variable,17004,"g(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17056,Modifiability,variab,variables,17056,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17332,Modifiability,variab,variable,17332,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17666,Modifiability,variab,variable,17666," -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = R",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:17718,Modifiability,variab,variables,17718,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:18071,Modifiability,variab,variable,18071,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:21378,Modifiability,variab,variables,21378,"color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically calculated from the distribution in; the dataset. The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset. This function accepts the following arguments. name -- Name of the ROOT histogram; xvar -- Observable to be ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:27175,Modifiability,variab,variable,27175,"nt is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooRealVar* rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; Create a RooRealVar containing the RMS of observable 'var' in; this dataset. If cutSpec and/or cutRange are specified the; moment is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooPlot* statOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with statistics information to the specified frame. By default a box with the; event count, mean and rms of the plotted variable is added. The following optional named arguments are accepted. What(const char* whatstr) -- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Contro",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:28521,Modifiability,variab,variable,28521,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; S",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:32824,Modifiability,variab,variable,32824,"line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plo",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:32872,Modifiability,variab,variable,32872," default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut stri",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:33010,Modifiability,variab,variable,33010,"- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable con",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:33212,Modifiability,variab,variable,33212," fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogr",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:33584,Modifiability,variab,variable,33584,"e referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:33791,Modifiability,variab,variable,33791,"te and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the T",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:33993,Modifiability,variab,variable,33993,"meters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:34351,Modifiability,variab,variable,34351,"contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is cu",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:34513,Modifiability,variab,variable,34513,"ber of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and e",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:34715,Modifiability,variab,variable,34715,"range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expr",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35162,Modifiability,variab,variable,35162," const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. Roo",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:12223,Performance,cache,cachedVars,12223,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; e",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:12381,Performance,cache,cacheClone,12381,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; e",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:12974,Performance,cache,cacheList,12974,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; e",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14211,Performance,cache,cached,14211," = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remov",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:14270,Performance,cache,cached,14270," = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remov",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:15212,Performance,cache,cacheArgs,15212,"; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:15430,Performance,cache,cached,15430,"ooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:15515,Performance,cache,cachedVars,15515,"ns of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:15574,Performance,cache,cache,15574,"ns of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35529,Performance,optimiz,optimizeReadingWithCaching,35529,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35589,Performance,cache,cacheList,35589,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35660,Performance,cache,cached,35660,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35694,Performance,cache,cacheList,35694,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:35838,Performance,cache,cached,35838,"raw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:36005,Performance,cache,cached,36005,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Double_t weightSquared() const. Bool_t valid() const; { return ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsData.html:38838,Performance,cache,cacheClone,38838," cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Sat Sep 5 16:39:53 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsData.html
https://root.cern/root/html534/RooAbsDataStore.html:582,Availability,avail,available,582,". RooAbsDataStore. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsDataStore. class RooAbsDataStore: public TNamed, public RooPrintable. RooAbsDataStore is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:2571,Availability,error,error,2571,"ame = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:2655,Availability,error,error,2655,"al RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const;",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:9928,Integrability,interface,interface,9928,"terator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries()",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11011,Integrability,rout,routines,11011,"taStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDa",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11212,Integrability,interface,interface,11212," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last g",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11388,Integrability,interface,interface,11388,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:8753,Modifiability,variab,variables,8753,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:8923,Modifiability,variab,variables,8923,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:1047,Performance,cache,cachedVars,1047," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:1141,Performance,cache,cacheOwner,1141," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:1249,Performance,cache,cachedVars,1249," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:1293,Performance,cache,cacheOwner,1293," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:8746,Performance,cache,cached,8746,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:8856,Performance,load,loading,8856,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:9233,Performance,load,loaded,9233," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightErro",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11245,Performance,cache,cacheArgs,11245,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11272,Performance,cache,cacheOwner,11272,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11378,Performance,optimiz,optimizer,11378,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11416,Performance,cache,cacheOwner,11416," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11491,Performance,cache,cachedVars,11491," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11577,Performance,cache,cachedVars,11577," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsDataStore.html:11978,Performance,load,loadValues,11978," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html
https://root.cern/root/html534/RooAbsFunc.html:856,Availability,avail,available,856,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:292,Integrability,interface,interface,292,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:425,Integrability,interface,interface,425,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:557,Integrability,interface,interface,557,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:352,Modifiability,variab,variable,352,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:366,Performance,perform,performing,366,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsFunc.html:530,Usability,simpl,simple,530,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root/html534/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html
https://root.cern/root/html534/RooAbsGenContext.html:853,Availability,avail,available,853,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:2069,Availability,error,error,2069,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual voidgenerateEvent(RooArgSet& theEvent, Int_t remaining); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:2153,Availability,error,error,2153,"bject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual voidgenerateEvent(RooArgSet& theEvent, Int_t remaining); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; vir",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:8935,Availability,avail,available,8935,"pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* l",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:9135,Availability,error,error,9135,"servable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype d",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:576,Integrability,interface,interface,576,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:2561,Modifiability,extend,extendedMode,2561,"tyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual voidgenerateEvent(RooArgSet& theEvent, Int_t remaining); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidinitGenerator(const RooArgSet& theEvent); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:7610,Modifiability,extend,extended,7610,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual RooDataSet*createDataSet(const char* name, const char* title, const RooArgSet& obs); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an emp",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:8720,Modifiability,extend,extendedMode,8720,"alidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:9003,Modifiability,extend,extendedMode,9003,"prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of ",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:7864,Performance,load,load,7864,"st va) const; voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of e",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsGenContext.html:10573,Usability,clear,clear,10573,"; The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Sat Sep 5 16:39:54 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html
https://root.cern/root/html534/RooAbsHiddenReal.html:761,Availability,avail,available,761,". RooAbsHiddenReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsHiddenReal. class RooAbsHiddenReal: public RooAbsReal. RooAbsHiddenReal is a base class for objects that want to hide; their return value from interactive use, e.g. for implementations; of parameter unblinding functions. This class overrides all; printing methods with versions that do not reveal the objects value; and it has a protected version of getVal(); . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsHiddenReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsRe",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:10340,Availability,error,error,10340,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:10424,Availability,error,error,10424,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33625,Deployability,integrat,integration,33625,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:35166,Deployability,integrat,integrator,35166,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:35177,Deployability,configurat,configuration,35177,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:7669,Integrability,depend,dependentVars,7669,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:8911,Integrability,depend,dependentOverlaps,8911,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9003,Integrability,depend,dependentOverlaps,9003,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9097,Integrability,depend,dependsOn,9097,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9226,Integrability,depend,dependsOn,9226,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9344,Integrability,depend,dependsOnValue,9344,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9451,Integrability,depend,dependsOnValue,9451,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:17644,Integrability,message,message,17644,"t; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:17795,Integrability,message,message,17795,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33625,Integrability,integrat,integration,33625,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:35166,Integrability,integrat,integrator,35166,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:24497,Modifiability,config,config,24497,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:35177,Modifiability,config,configuration,35177,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:2300,Performance,cache,cacheUniqueSuffix,2300,"uffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:11158,Performance,cache,cacheList,11158,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:11246,Performance,cache,cacheList,11246,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:19628,Performance,optimiz,optimizeCacheMode,19628,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:19700,Performance,optimiz,optimizeCacheMode,19700,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:23155,Performance,cache,cache,23155,"dent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:24340,Performance,cache,cache,24340," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:26439,Performance,cache,cache,26439," flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:29599,Performance,optimiz,optimizeDirtyHook,29599,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:32492,Performance,cache,cache,32492,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:32576,Performance,cache,cache,32576,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:32775,Performance,cache,caches,32775,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33347,Performance,cache,cache,33347,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33526,Performance,cache,cache,33526,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33940,Performance,cache,cache,33940,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:34818,Performance,cache,cache,34818,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:35425,Performance,cache,cache,35425,"for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal t",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:12090,Security,hash,hash,12090,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:12241,Security,hash,hash,12241,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:32671,Security,validat,validate,32671,,MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:33447,Security,access,access,33447,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:36615,Security,access,accessor,36615,"l::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. Double_t getValV(const RooArgSet* nset = 0) const; This is dubious from a C++ point of view, but it blocks the interactive user; from accidentally calling getVal() without explicit cast, which is the whole; point of this class. » Last changed: Tue Mar 10 17:14:00 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:8970,Testability,test,testArg,8970,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:9064,Testability,test,testArg,9064,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:17619,Testability,log,logEvalError,17619,"Object::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:17718,Testability,log,logEvalError,17718,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:18747,Testability,test,testArg,18747,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:18842,Testability,test,testArg,18842,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:19844,Testability,test,testArg,19844," RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:3755,Usability,clear,clearEvalErrorLog,3755,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:3791,Usability,clear,clearShapeDirty,3791,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:3831,Usability,clear,clearValueAndShapeDirty,3831,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsHiddenReal.html:3879,Usability,clear,clearValueDirty,3879,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html534/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html
https://root.cern/root/html534/RooAbsIntegrator.html:580,Availability,avail,available,580,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:1890,Availability,error,error,1890,"nIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:1974,Availability,error,error,1974,"teOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:364,Deployability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6200,Deployability,integrat,integration,6200,"reamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6228,Deployability,integrat,integrator,6228,"reamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6531,Deployability,integrat,integration,6531,"t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last ",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6827,Deployability,integrat,integrator,6827,"t va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Mar 10 17:14:00 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:350,Integrability,interface,interface,350,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:364,Integrability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:432,Integrability,interface,interface,432,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6200,Integrability,integrat,integration,6200,"reamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6228,Integrability,integrat,integrator,6228,"reamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6531,Integrability,integrat,integration,6531,"t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last ",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6827,Integrability,integrat,integrator,6827,"t va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Mar 10 17:14:00 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:1293,Modifiability,config,config,1293," virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsIntegrator.html:6785,Modifiability,config,config,6785,"t va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Mar 10 17:14:00 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsIntegrator.html
https://root.cern/root/html534/RooAbsLValue.html:730,Availability,avail,available,730,". RooAbsLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsLValue. class RooAbsLValue. Abstract base class for objects that are lvalues, i.e. objects; whose value can be modified directly. This class implements; abstract methods for binned fits that return the number of fit; bins and change the value of the object to the central value of a; given fit bin, regardless of the type of value.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsLValue(); static TClass*Class(); virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char* rangeName) const; virtual Double_tgetBinWidth(Int_t i, const char* rangeName = 0) const; virtual TClass*IsA() const; virtual Int_tnumBins(const char* rangeName = 0) const; RooAbsLValue&operator=(const RooAbsLValue&); virtual voidrandomize(const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Double_tvolume(const char* rangeName) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsLValue(); Destructor. void setBin(Int_t ibin, const char* rangeName = 0). Int_t getBin(const char* rangeName = 0) const. Int_t numBins(const char* rangeName = 0) const. Double_t getBinWidth(Int_t i, const char* rangeName = 0) const. Double_t volume(const char* rangeName) const. void randomize(const char* rangeName = 0). const RooAbsBinning* getBinningPtr(const char* rangeName",MatchSource.WIKI,root/html534/RooAbsLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsLValue.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:1990,Availability,error,error,1990,"r* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:2074,Availability,error,error,2074,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9742,Deployability,configurat,configuration,9742,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:5918,Integrability,depend,dependents,5918,"TObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*allDependents(); Bool_tbinGenData(); RooArgSet*dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_textendedGen(); RooArgSet*fitInitParams(); RooAbsPdf*fitModel(); const char*fitOptions(); RooLinkedList*fitOptList(); RooArgSet*fitParams(); RooAbsGenContext*genContext(); RooArgSet*genInitParams(); RooAbsPdf*genModel(); RooArgSet*genParams(); const RooDataSet*genProtoData(); RooAbsData*genSample(); voidTObject::MakeZombie(); RooRealVar*nllVar(); Double_tnumExpGen(); RooArgSet*projDeps(); Bool_trandProto(); RooFitResult*refit(RooAbsData* inGenSample = 0); Bool_tverboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:8916,Integrability,depend,dependents,8916,"(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If tr",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9232,Integrability,depend,dependents,9232,"eters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » L",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:10190,Integrability,message,message,10190,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:647,Modifiability,variab,variables,647,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); RooAbsMCStudyModule(const char* name, const char* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0);",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9742,Modifiability,config,configuration,9742,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9844,Modifiability,extend,extendedGen,9844,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9867,Modifiability,extend,extended,9867,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:404,Performance,perform,perform,404,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); RooAbsMCStudyModule(const char* name, const char* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0);",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:7775,Performance,perform,performed,7775,"kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAb",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:8237,Performance,perform,performed,8237,"ule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:8523,Performance,perform,performed,8523,"ation of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMCStudyModule.html:9652,Testability,log,log,9652,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Mar 10 17:14:01 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html
https://root.cern/root/html534/RooAbsMoment.html:606,Availability,avail,available,606,". RooAbsMoment. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMoment. class RooAbsMoment: public RooAbsReal. RooAbsMoment represents the first, second, or third order derivative; of any RooAbsReal as calculated (numerically) by the MathCore Richardson; derivator class.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsMoment(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, ",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:10204,Availability,error,error,10204,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:10288,Availability,error,error,10288,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33296,Deployability,integrat,integration,33296,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:34999,Deployability,integrat,integrator,34999,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:35010,Deployability,configurat,configuration,35010,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:7533,Integrability,depend,dependentVars,7533,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:8775,Integrability,depend,dependentOverlaps,8775,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:8867,Integrability,depend,dependentOverlaps,8867,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:8961,Integrability,depend,dependsOn,8961,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:9090,Integrability,depend,dependsOn,9090,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:9208,Integrability,depend,dependsOnValue,9208,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:9315,Integrability,depend,dependsOnValue,9315,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:17498,Integrability,message,message,17498,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& t",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:17649,Integrability,message,message,17649,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method,",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33296,Integrability,integrat,integration,33296,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:34999,Integrability,integrat,integrator,34999,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:24291,Modifiability,config,config,24291,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:35010,Modifiability,config,configuration,35010,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:2141,Performance,cache,cacheUniqueSuffix,2141,"uffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tcentral() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& ar",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:11022,Performance,cache,cacheList,11022,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:11110,Performance,cache,cacheList,11110,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:19382,Performance,optimiz,optimizeCacheMode,19382,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*Ro",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:19454,Performance,optimiz,optimizeCacheMode,19454,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:22949,Performance,cache,cache,22949,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:24134,Performance,cache,cache,24134," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:26233,Performance,cache,cache,26233,"RooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:29307,Performance,optimiz,optimizeDirtyHook,29307,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:32200,Performance,cache,cache,32200,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:32284,Performance,cache,cache,32284,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:32483,Performance,cache,caches,32483,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33018,Performance,cache,cache,33018,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33197,Performance,cache,cache,33197,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33644,Performance,cache,cache,33644,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:34651,Performance,cache,cache,34651,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:35249,Performance,cache,cache,35249,"lwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsMoment(); Destructor. Int_t order() const; { return _order ; }. Bool_t ce",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:11954,Security,hash,hash,11954,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:12105,Security,hash,hash,12105,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:32379,Security,validat,validate,32379,,MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:33118,Security,access,access,33118,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:8834,Testability,test,testArg,8834,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:8928,Testability,test,testArg,8928,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:17473,Testability,log,logEvalError,17473,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* ds",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:17572,Testability,log,logEvalError,17572,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, ",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:18501,Testability,test,testArg,18501,", const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:18596,Testability,test,testArg,18596,"l* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:19618,Testability,test,testArg,19618," const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:3619,Usability,clear,clearEvalErrorLog,3619,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:3655,Usability,clear,clearShapeDirty,3655,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:3695,Usability,clear,clearValueAndShapeDirty,3695,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsMoment.html:3743,Usability,clear,clearValueDirty,3743,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html534/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html
https://root.cern/root/html534/RooAbsNumGenerator.html:605,Availability,avail,available,605,". RooAbsNumGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsNumGenerator. class RooAbsNumGenerator: public TNamed, public RooPrintable. Class RooAbsNumGenerator is the abstract base class for MC event generator; implementations like RooAcceptReject and RooFoam; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsNumGenerator.html:2140,Availability,error,error,2140," RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tT",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsNumGenerator.html:2224,Availability,error,error,2224,"et& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfm",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsNumGenerator.html:9026,Integrability,interface,interface,9026,"*_cloneSetSet owning clone of input function; RooAbsReal*_funcClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStore; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verbose; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Tue Mar 10 17:14:04 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsNumGenerator.html:1264,Modifiability,config,config,1264," virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsNumGenerator.html:8564,Modifiability,config,config,8564,"*_cloneSetSet owning clone of input function; RooAbsReal*_funcClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStore; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verbose; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Tue Mar 10 17:14:04 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsNumGenerator.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:1212,Availability,avail,available,1212," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:11172,Availability,error,error,11172,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:11256,Availability,error,error,11256,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36705,Deployability,integrat,integration,36705,set of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! T,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:40502,Deployability,integrat,integrator,40502,"hes ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:40513,Deployability,configurat,configuration,40513,"hes ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:8437,Integrability,depend,dependentVars,8437,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual I",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:9729,Integrability,depend,dependentOverlaps,9729,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:9821,Integrability,depend,dependentOverlaps,9821,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:9915,Integrability,depend,dependsOn,9915,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:10044,Integrability,depend,dependsOn,10044,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:10162,Integrability,depend,dependsOnValue,10162,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:10269,Integrability,depend,dependsOnValue,10269,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:18612,Integrability,message,message,18612,"l Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:18763,Integrability,message,message,18763,"RooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36705,Integrability,integrat,integration,36705,set of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! T,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:40502,Integrability,integrat,integrator,40502,"hes ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42637,Integrability,depend,depends,42637,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42946,Integrability,depend,dependent,42946,"ntCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the dat",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43011,Integrability,depend,dependent,43011,"ntCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the dat",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43158,Integrability,message,messages,43158,"izeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:25419,Modifiability,config,config,25419,"Notice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36479,Modifiability,extend,extended,36479,ant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsR,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:40513,Modifiability,config,configuration,40513,"hes ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:521,Performance,optimiz,optimizations,521,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:2746,Performance,cache,cacheUniqueSuffix,2746,"acheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:11990,Performance,cache,cacheList,11990,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:12078,Performance,cache,cacheList,12078,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:20615,Performance,optimiz,optimizeCacheMode,20615,"EvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:20687,Performance,optimiz,optimizeCacheMode,20687,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:23987,Performance,cache,cache,23987,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:25262,Performance,cache,cache,25262,"ption_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:27361,Performance,cache,cache,27361,"RooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:31424,Performance,optimiz,optimizeDirtyHook,31424,"ectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidoptimizeCaching(); voidoptimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidprintCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsTestStatistic::processEmptyDataSets() const; virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtu",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:35131,Performance,cache,cache,35131,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:35215,Performance,cache,cache,35215,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:35414,Performance,cache,caches,35414,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:35468,Performance,cache,cached,35468,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36256,Performance,cache,cache,36256,"tatic Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSet_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GO",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36606,Performance,cache,cache,36606, of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty stat,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:37720,Performance,cache,cache,37720, getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:39814,Performance,cache,cache,39814, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:40802,Performance,cache,cache,40802,"hes ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42252,Performance,optimiz,optimizations,42252,"saging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42326,Performance,optimiz,optimization,42326,"eritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated const",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42412,Performance,optimiz,optimizations,42412,"nitSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached no",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42520,Performance,optimiz,optimizations,42520," const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Fi",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42555,Performance,optimiz,optimizeCaching,42555,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43190,Performance,optimiz,optimizeConstantTerms,43190,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* c",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43287,Performance,optimiz,optimization,43287,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* c",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43344,Performance,cache,cached,43344,"g constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43391,Performance,cache,cached,43391,"g constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:44241,Performance,cache,cacheUniqueSuffix,44241,"anged from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Mar 10 17:14:05 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:38861,Safety,avoid,avoids,38861, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:12922,Security,hash,hash,12922,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDepen",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:13073,Security,hash,hash,13073,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet*",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:35310,Security,validat,validate,35310,,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:36527,Security,access,access,36527,entListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:39992,Security,access,access,39992,"ers of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messa",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:401,Testability,test,test,401,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:1059,Testability,test,test,1059,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:9788,Testability,test,testArg,9788,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:9882,Testability,test,testArg,9882,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:18587,Testability,log,logEvalError,18587,"sFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:18686,Testability,log,logEvalError,18686,"cal(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:19715,Testability,test,testArg,19715,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSe",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:19810,Testability,test,testArg,19810,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:20831,Testability,test,testArg,20831,") const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:37220,Testability,test,test,37220,AbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-spl,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:37315,Testability,test,test,37315,ject; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; In,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:38376,Testability,test,test,38376, getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:39210,Testability,test,test,39210, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:39757,Testability,test,test,39757, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:39959,Testability,test,test,39959, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:41651,Testability,test,test,41651,"e; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends o",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42269,Testability,test,test,42269,"saging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42612,Testability,log,logic,42612,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:42723,Testability,test,test,42723,"k(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; C",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:43928,Testability,test,test,43928,"changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Mar 10 17:14:05 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:4201,Usability,clear,clearEvalErrorLog,4201,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:4237,Usability,clear,clearShapeDirty,4237,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bo",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:4277,Usability,clear,clearValueAndShapeDirty,4277,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*R",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsOptTestStatistic.html:4325,Usability,clear,clearValueDirty,4325,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, con",MatchSource.WIKI,root/html534/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html
https://root.cern/root/html534/RooAbsPdf.html:461,Availability,error,error,461,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:4441,Availability,avail,available,4441,"d with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:14090,Availability,error,error,14090,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:14174,Availability,error,error,14174,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42916,Availability,error,errors,42916,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:47069,Availability,error,error,47069,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:47086,Availability,error,error,47086,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48199,Availability,error,error,48199,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48260,Availability,error,error,48260,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48590,Availability,error,error,48590,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:58090,Availability,error,errors,58090,"Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:58177,Availability,error,error,58177,"Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:58962,Availability,error,errors,58962,"is option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:59083,Availability,error,error,59083,"(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:59164,Availability,error,error,59164," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:60516,Availability,error,error,60516,", HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(co",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:60559,Availability,error,error,60559,", HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(co",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:60677,Availability,error,error,60677,"dList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:62689,Availability,error,error,62689,"ype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:65254,Availability,error,error,65254,"copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:68464,Availability,error,error,68464,"l be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result i",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69669,Availability,error,error,69669,"bose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71953,Availability,error,error,71953,"getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not speci",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:73094,Availability,error,error,73094,"- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74290,Availability,error,error,74290,"rint informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set)",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:77955,Availability,down,downward,77955,"rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization sc",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:79841,Availability,error,errors,79841," functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:80711,Availability,error,error,80711,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserte",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:80740,Availability,error,error,80740,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserte",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:80943,Availability,error,error,80943,"-- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital re",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:81668,Availability,error,errors,81668,"g structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function o",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84808,Availability,error,error,84808,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84862,Availability,error,error,84862,"egrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherw",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84918,Availability,error,error,84918,"d. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is re",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1457,Deployability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1770,Deployability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1877,Deployability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2452,Deployability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2550,Deployability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2623,Deployability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2635,Deployability,configurat,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2656,Deployability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2949,Deployability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2997,Deployability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3164,Deployability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:43179,Deployability,integrat,integration,43179,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45110,Deployability,configurat,configuration,45110,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45207,Deployability,integrat,integrator,45207,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45218,Deployability,configurat,configuration,45218,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46135,Deployability,integrat,integrating,46135,"nfiguration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46485,Deployability,integrat,integration,46485,"integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:63125,Deployability,deploy,deploy,63125,"ataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:65591,Deployability,deploy,deploy,65591," the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74894,Deployability,integrat,integrated,74894," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:75733,Deployability,integrat,integration,75733,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:82469,Deployability,integrat,integrated,82469,"ion_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:82766,Deployability,integrat,integrated,82766,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83000,Deployability,integrat,integrated,83000," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83622,Deployability,integrat,integration,83622,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83818,Deployability,integrat,integrates,83818,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83843,Deployability,integrat,integrates,83843,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84002,Deployability,integrat,integration,84002,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84101,Deployability,integrat,integration,84101,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85014,Deployability,configurat,configuration,85014,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85122,Deployability,integrat,integrator,85122,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85133,Deployability,configurat,configuration,85133,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85205,Deployability,configurat,configuration,85205,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85336,Deployability,integrat,integrator,85336," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85347,Deployability,configurat,configuration,85347," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85419,Deployability,configurat,configuration,85419,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85531,Deployability,integrat,integrator,85531,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85543,Deployability,configurat,configuration,85543,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85569,Deployability,install,installed,85569,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85594,Deployability,configurat,configuration,85594,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85706,Deployability,configurat,configuration,85706,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85760,Deployability,configurat,configuration,85760,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85812,Deployability,configurat,configuration,85812,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85862,Deployability,configurat,configuration,85862,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85979,Deployability,configurat,configuration,85979,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:86026,Deployability,configurat,configuration,86026,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:86128,Deployability,configurat,configuration,86128,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3493,Energy Efficiency,efficient,efficient,3493,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:58626,Energy Efficiency,consumption,consumption,58626,"ult; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg ar",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:67741,Energy Efficiency,efficient,efficient,67741,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(co",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:78497,Energy Efficiency,adapt,adaptive,78497," Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:325,Integrability,interface,interface,325,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:495,Integrability,interface,interface,495,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1097,Integrability,depend,dependents,1097,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1427,Integrability,depend,dependents,1427,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1457,Integrability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1770,Integrability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1877,Integrability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1896,Integrability,depend,dependents,1896," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2165,Integrability,depend,dependents,2165,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2431,Integrability,depend,dependents,2431,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2452,Integrability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2518,Integrability,depend,dependents,2518," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2550,Integrability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2623,Integrability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2656,Integrability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2949,Integrability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2981,Integrability,depend,dependent,2981,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2997,Integrability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3034,Integrability,depend,dependents,3034,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3146,Integrability,depend,dependent,3146,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3164,Integrability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3302,Integrability,depend,dependents,3302,"et, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Member",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3408,Integrability,depend,dependent,3408,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3999,Integrability,depend,dependent,3999,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbs",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:4172,Integrability,depend,dependent,4172,"integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:11178,Integrability,depend,dependentVars,11178,"rg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Do",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12635,Integrability,depend,dependentOverlaps,12635,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12727,Integrability,depend,dependentOverlaps,12727,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12821,Integrability,depend,dependsOn,12821,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12950,Integrability,depend,dependsOn,12950,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:13068,Integrability,depend,dependsOnValue,13068,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:13175,Integrability,depend,dependsOnValue,13175,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:24946,Integrability,message,message,24946,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; stat",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:25097,Integrability,message,message,25097,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const Roo",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:43179,Integrability,integrat,integration,43179,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45207,Integrability,integrat,integrator,45207,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46135,Integrability,integrat,integrating,46135,"nfiguration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46485,Integrability,integrat,integration,46485,"integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48266,Integrability,message,messages,48266,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48439,Integrability,message,messages,48439,"ject that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48596,Integrability,message,message,48596,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:52415,Integrability,message,messages,52415," 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match he given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:56775,Integrability,interface,interface,56775,"; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by de",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:56836,Integrability,interface,interface,56836,"; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by de",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:56906,Integrability,interface,interface,56906," index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:58780,Integrability,message,messages,58780,"2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:59183,Integrability,message,messages,59183," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:62892,Integrability,message,messages,62892,"autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the reques",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:65457,Integrability,message,messages,65457,"totype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71208,Integrability,depend,depends,71208,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71230,Integrability,rout,route,71230,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:72156,Integrability,message,messages,72156,". Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named argum",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:73297,Integrability,message,messages,73297,"xpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74441,Integrability,interface,interface,74441,"s generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; onl",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74894,Integrability,integrat,integrated,74894," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:75112,Integrability,message,message,75112,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:75733,Integrability,integrat,integration,75733,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:76769,Integrability,depend,depends,76769,"ed by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default i",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:82469,Integrability,integrat,integrated,82469,"ion_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:82766,Integrability,integrat,integrated,82766,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83000,Integrability,integrat,integrated,83000," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83622,Integrability,integrat,integration,83622,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83818,Integrability,integrat,integrates,83818,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83843,Integrability,integrat,integrates,83843,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84002,Integrability,integrat,integration,84002,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84101,Integrability,integrat,integration,84101,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85122,Integrability,integrat,integrator,85122,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85336,Integrability,integrat,integrator,85336," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85531,Integrability,integrat,integrator,85531,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:960,Modifiability,variab,variables,960,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:995,Modifiability,variab,variables,995,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1379,Modifiability,variab,variables,1379,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1413,Modifiability,variab,variables,1413,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2635,Modifiability,config,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:18146,Modifiability,extend,extended,18146," const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:18289,Modifiability,extend,extended,18289,"ts = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:32722,Modifiability,config,config,32722,"ENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:32880,Modifiability,config,config,32880,"st; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::se",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:36907,Modifiability,extend,extended,36907,"nt_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooDataSet*generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bo",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45110,Modifiability,config,configuration,45110,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45218,Modifiability,config,configuration,45218,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48664,Modifiability,extend,extendedTerm,48664,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48749,Modifiability,extend,extended,48749,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48934,Modifiability,extend,extendable,48934,"eclare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given r",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:49770,Modifiability,extend,extended,49770,"(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:54042,Modifiability,extend,extended,54042,"mdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:60444,Modifiability,extend,extended,60444,"elihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:62411,Modifiability,variab,variables,62411,"tegral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:62547,Modifiability,variab,variables,62547,"RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:63050,Modifiability,extend,extended,63050,"ataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:64207,Modifiability,variab,variables,64207," (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:64478,Modifiability,variab,variables,64478," all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:64976,Modifiability,variab,variables,64976,"dOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use b",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:65112,Modifiability,variab,variables,65112," otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagge",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:66359,Modifiability,extend,extended,66359,"et; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:67091,Modifiability,variab,variables,67091,"cuted at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", B",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:67362,Modifiability,variab,variables,67362," use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:67588,Modifiability,config,configured,67588,"random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:68095,Modifiability,extend,extended,68095,"cified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribut",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:68169,Modifiability,variab,variables,68169,"cified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribut",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:68322,Modifiability,variab,variables,68322,"whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:68741,Modifiability,extend,extended,68741,". If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zer",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69027,Modifiability,variab,variables,69027,"ate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69226,Modifiability,variab,variables,69226,"stribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator al",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69498,Modifiability,variab,variables,69498,"s ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The defaul",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71675,Modifiability,variab,variables,71675,"s will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71811,Modifiability,variab,variables,71811,"sponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distributi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:72314,Modifiability,extend,extended,72314,"ateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified numb",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:72816,Modifiability,variab,variables,72816," the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooData",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:72952,Modifiability,variab,variables,72952,"taset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is k",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:73514,Modifiability,extend,extended,73514,"RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:73764,Modifiability,extend,extended,73764,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:73838,Modifiability,variab,variables,73838,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74148,Modifiability,variab,variables,74148,"e(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74705,Modifiability,variab,variable,74705,"whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:74914,Modifiability,variab,variables,74914," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:78497,Modifiability,adapt,adaptive,78497," Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:82118,Modifiability,extend,extended,82118," const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argum",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83804,Modifiability,variab,variables,83804,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85014,Modifiability,config,configuration,85014,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85133,Modifiability,config,configuration,85133,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85205,Modifiability,config,configuration,85205,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85347,Modifiability,config,configuration,85347," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85419,Modifiability,config,configuration,85419,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85543,Modifiability,config,configuration,85543,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85594,Modifiability,config,configuration,85594,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85706,Modifiability,config,configuration,85706,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85760,Modifiability,config,configuration,85760,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85812,Modifiability,config,configuration,85812,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85862,Modifiability,config,configuration,85862,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85956,Modifiability,config,config,85956,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:85979,Modifiability,config,configuration,85979,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:86026,Modifiability,config,configuration,86026,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:86128,Modifiability,config,configuration,86128,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:87428,Modifiability,extend,extendMode,87428,"& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Sat Sep 5 16:39:56 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:87485,Modifiability,extend,extended,87485,"& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Sat Sep 5 16:39:56 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:87702,Modifiability,extend,extended,87702,"& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Sat Sep 5 16:39:56 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:87778,Modifiability,extend,extended,87778,"& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Sat Sep 5 16:39:56 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1853,Performance,perform,perform,1853," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2676,Performance,perform,performed,2676,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:6272,Performance,cache,cacheUniqueSuffix,6272,"RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:15167,Performance,cache,cacheList,15167,"* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:15255,Performance,cache,cacheList,15255,"l Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsR",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:26990,Performance,optimiz,optimizeCacheMode,26990,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:27062,Performance,optimiz,optimizeCacheMode,27062,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:31364,Performance,cache,cache,31364,"e::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:32642,Performance,cache,cache,32642,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidset",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:35176,Performance,cache,cache,35176,"ct::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:38552,Performance,optimiz,optimizeDirtyHook,38552,"DataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42005,Performance,cache,cache,42005,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42089,Performance,cache,cache,42089,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42288,Performance,cache,caches,42288,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42823,Performance,cache,cache,42823,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_n",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:43080,Performance,cache,cache,43080,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:43494,Performance,cache,cache,43494,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:44072,Performance,cache,cache,44072,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:44699,Performance,cache,cache,44699,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:45465,Performance,cache,cache,45465,"Number of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46302,Performance,cache,cached,46302," traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46376,Performance,cache,cache,46376," traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46415,Performance,cache,cached,46415," traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:46516,Performance,perform,performance,46516,"integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:47666,Performance,cache,cached,47666,"tical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:47753,Performance,cache,cached,47753,"RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the g",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:50876,Performance,perform,performed,50876,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:51461,Performance,optimiz,optimization,51461,"istributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match he given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:53661,Performance,perform,performed,53661," improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interlea",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:53730,Performance,perform,performed,53730,"h large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data wi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:55148,Performance,perform,performed,55148,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:57386,Performance,optimiz,optimization,57386,". Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:59366,Performance,perform,performed,59366,"ce matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are suppo",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:59435,Performance,perform,performed,59435,"ing the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:75170,Performance,perform,performed,75170,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:83654,Performance,perform,performed,83654,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:2074,Safety,safe,safe,2074," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71099,Safety,safe,safely,71099,"rs with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:71244,Safety,safe,safe,71244,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:16565,Security,hash,hash,16565," xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), c",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:16716,Security,hash,hash,16716,"nst; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& a",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:42184,Security,validat,validate,42184,,MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:43001,Security,access,access,43001,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69851,Security,access,access,69851,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:69961,Security,access,accessed,69961,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1690,Testability,log,logic,1690," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:3274,Testability,assert,assert,3274,"e implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:4299,Testability,assert,assert,4299," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12694,Testability,test,testArg,12694,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:12788,Testability,test,testArg,12788,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:24921,Testability,log,logEvalError,24921,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:25020,Testability,log,logEvalError,25020,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalError",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:26109,Testability,test,testArg,26109,"har* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:26204,Testability,test,testArg,26204,"e_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:27206,Testability,test,testArg,27206,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48536,Testability,log,log,48536,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48638,Testability,log,log,48638,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:48795,Testability,log,log,48795,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:49443,Testability,log,log,49443,"f future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:52832,Testability,log,log,52832,"parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match he given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; comman",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:53911,Testability,log,log,53911,"nned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:57402,Testability,test,test,57402,". Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:77373,Testability,log,log,77373,"ges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve point",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:1067,Usability,simpl,simply,1067,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:6864,Usability,clear,clearEvalErrorLog,6864,"sReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:6900,Usability,clear,clearShapeDirty,6900,"rs, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:6940,Usability,clear,clearValueAndShapeDirty,6940,"valid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:6988,Usability,clear,clearValueDirty,6988,"ext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 ",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:56969,Usability,simpl,simplex,56969,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:56996,Usability,simpl,simplex,56996,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:57055,Usability,simpl,simplex,57055,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:57082,Usability,simpl,simplex,57082,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:57142,Usability,simpl,simplex,57142,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf.html:84769,Usability,clear,clearEvalError,84769,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html534/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:469,Availability,error,error,469,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1465,Deployability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1778,Deployability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1885,Deployability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2460,Deployability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2558,Deployability,integrat,integrate,2558," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2631,Deployability,integrat,integration,2631," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2643,Deployability,configurat,configuration,2643," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2664,Deployability,integrat,integration,2664,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2957,Deployability,integrat,integration,2957,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:3005,Deployability,integrat,integrated,3005,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:3172,Deployability,integrat,integration,3172,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:3501,Energy Efficiency,efficient,efficient,3501,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&ope",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:333,Integrability,interface,interface,333,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:503,Integrability,interface,interface,503,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1105,Integrability,depend,dependents,1105,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1435,Integrability,depend,dependents,1435,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1465,Integrability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1778,Integrability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1885,Integrability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:1904,Integrability,depend,dependents,1904," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2173,Integrability,depend,dependents,2173,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2439,Integrability,depend,dependents,2439,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
https://root.cern/root/html534/RooAbsPdf__GenSpec.html:2460,Integrability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html534/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html
