id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:116772,Safety,safe,safety,116772," along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; the current node or to one of its daughters. The full prototype of the; method is:. ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; ```. In the prototype above, besides the current point and direction that are; supposed already initialized, the only input parameter is `step`. This; represents the maximum step allowed by the tracking algorithm or the; `physical step`. The modeller will search for a boundary crossing only; up to a distance equal to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ``` {.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ```. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig `(default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag tellin",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:117493,Safety,safe,safety,117493,"to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ``` {.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ```. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig `(default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telling if the current track will enter inside some daughter of the; current volume or it will exit inside its container:. ``` {.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ```. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used i",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:118861,Safety,safe,safety,118861,"ume or it will exit inside its container:. ``` {.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ```. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119063,Safety,safe,safe,119063,"e the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current di",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119506,Safety,safe,safety,119506," instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119569,Safety,safe,safe,119569,"hich provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119759,Safety,safe,safety,119759,",; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119836,Safety,safe,safety,119836,"indNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; b",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119887,Safety,safe,safety,119887," flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; by a previous `TGeoManager::FindNextBoundary()` call. Due to; fl",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131821,Safety,detect,detected,131821,"r is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133786,Safety,safe,safety,133786,"rs (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134061,Safety,safe,safety,134061,"her.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and havi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134253,Safety,avoid,avoid,134253,"; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking M",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134615,Safety,detect,detected,134615,"uces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking Methods. ![Safety computation checking](pictures/030001E0.png). In order to check a given point, `CheckPoint(x,y,z)` method of; **`TGeoManager`** draws the daughters of the volume containing the point; one le",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145502,Safety,detect,detector,145502,"still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and speci",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145606,Safety,detect,detector,145606,"any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145687,Safety,detect,detector,145687,"try (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In **`TGeo`**, physical nodes are represented by; the class **`TGeoPhysicalNo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:146490,Safety,detect,detector,146490," generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In **`TGeo`**, physical nodes are represented by; the class **`TGeoPhysicalNode`** and can be created on demand for; alignment purposes:. ``` {.cpp}; TGeoPhysicalNode(const char* path); ```. The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can; however create ""symbolic links"" to any complex path to make it more; representable for the object it designates:. ``` {.cpp}; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); ```. Such a symbolic link hides the complexity of the path to the align; object and replaces it with a more meaningful name. In addition,; **`TGeoPNEntry`** objects are faster to search by name and they may; optionally store an additional user matrix. ``` {.cpp}; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEn",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:148991,Safety,avoid,avoid,148991,"corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ``` {.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ```. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ``` {.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ```. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ``` {.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ```. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ``` {.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ```. The method above will optionally lock the possibility of doing any",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:160067,Safety,safe,safe,160067," method is the object which shape; boundary will be crossed first. The distance to the next crossing can be; retrieved after the call:. ``` {.cpp}; Double_t TGeoManager::GetStep(); ```. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning *""step approved""*. The default value for `stepmax` is; `TGeoShape::Big `with the meaning that boundaries are looked for; without limitation. ![Finding the distance to the next crossed boundary](pictures/080001E8.png). According the values of the input parameters the method will perform; additional optional tasks:. **`|stepmax| < `** ***`TGeoShape::Big()`*** **` `**. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`:",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:160208,Safety,safe,safe,160208,"an be; retrieved after the call:. ``` {.cpp}; Double_t TGeoManager::GetStep(); ```. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning *""step approved""*. The default value for `stepmax` is; `TGeoShape::Big `with the meaning that boundaries are looked for; without limitation. ![Finding the distance to the next crossed boundary](pictures/080001E8.png). According the values of the input parameters the method will perform; additional optional tasks:. **`|stepmax| < `** ***`TGeoShape::Big()`*** **` `**. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algor",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161019,Safety,safe,safe,161019," < `** ***`TGeoShape::Big()`*** **` `**. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161234,Safety,safe,safety,161234," sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL.",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161364,Safety,safe,safety,161364,"ct that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physicall",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161449,Safety,safe,safety,161449,"the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first st",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161566,Safety,safe,safety,161566,"tly call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape fr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161755,Safety,safe,safe,161755,"tly call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape fr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:162777,Safety,safe,safe,162777," safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is decla",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2576,Security,access,accessed,2576,"aves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:10343,Security,access,accessed,10343,"he; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are seen when; visualizing or tracking the geometry are depicted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by **`TGeoNode`** objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at; <https://root.cern.ch/doc/master/classTGeoManager.html>. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the ROOT; canvas its name, shape type and corresponding path in th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:18461,Security,access,accessed,18461,"he same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be currently accessed via; getters in the **`TGeoElementRN`** class:. Atomic number and charge (from the base class **`TGeoElement`**). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - Isomeric energy level [`MeV`]; - Mass excess [`MeV`]; - Half life [`s`]; - Spin/Parity - can be retrieved with: `TGeoElementRN::GetTitle()`; - Hynalation and ingestion toxicities; - List of decays - `TGeoElementRN::GetDecays()`. The radioactive decays of a radionuclide are represented by the class; **`TGeoDecayChannel`** and they are stored in a **`TObjArray`**. Decay; provides:. - Decay mode; - Variation of isomeric number; - `Q` value for the decay [`GeV`]; - Parent element; - Daughter element. Radionuclides are linked one to each other via their decays, until the; last element in the decay chain which must be stable. One can iterate; decay chains using the iterator **`TGeoElemIter`**:. ``` {.cpp}; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] wh",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:23037,Security,access,accessing,23037,"params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local point; that does NOT result in a boundary crossing of the shape (safe; distance);; - Computing the cosines of the normal vector to the crossed shape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:49850,Security,access,accessible,49850,"270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();; ```. ![A composite shape example](pictures/080001CD.png). Composite shapes can be subsequently used for defining volumes.; Moreover, these volumes contain other volumes, following the general; criteria. Volumes created based on composite shapes cannot be divided. ### Navigation Methods Performed By Shapes. Shapes are named objects and register themselves to the `manager class`; at creation time. This is responsible for their final deletion. Shapes; can be created without name if their retrieval by name is no needed.; Generally shapes are objects that are useful only at geometry creation; stage. The pointer to a shape is in fact needed only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:99505,Security,access,accessible,99505,"- Scale transformations (**`TGeoScale`** class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3], `**`TGeoRotation *fRotation`.**. ``` {.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ```. - General transformations: (**`TGeoHMatrix`** class) represent; combined transformations in any order.; - Identity transformation: (**`TGeoIdentity`** class) is a generic; identity transformation represented by a singleton class object; **`gGeoIdentity`**. ### Ownership of Geometry Objects. The class **`TGeoManager`** class contains the entire API needed for; building and tracking geometry. It defines a global pointer; ***`gGeoManager`*** in order to be fully accessible from external code.; The manager class is the owner of all geometry objects defined in a; session; therefore, users must not try to control their deletion. It; contains lists of media, materials, transformations, shapes and volumes.; A special case is the one of geometrical transformations. When creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use `TGeoMatrix::RegisterYourself()` method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; **`TGeoVolume`** class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101755,Security,access,access,101755,"inter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoMa",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:102681,Security,access,accessible,102681,"etrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remember",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:112933,Security,access,access,112933,"ates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ``` {.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ```. ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms, but user code is also allowed to access it. This; works on any stack principle by using PUSH and POP calls and user code; is responsible for popping the pushed states in order to keep the stack; clean. ``` {.cpp}; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stack index; gGeoManager->PopPath(Int_t index);; ```. ### Navigation Queries. After initializing the current state related to a given point and; direction defined in `MARS` `(‘Where am I?')`, one can query for several; geometrical quantities. All the related algorithms work",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:127769,Security,access,accessed,127769,");; // or directly; gGeoManager->SetCurrentTrack(track_index);; TVirtualGeoTrack *current = gGeoManager->GetCurrentTrack();; ```. One can also look for a track by `user id` or `track index`:. ``` {.cpp}; ptrTrack = gGeoManager->GetTrackOfId(user_id);; ptrParent = gGeoManager->GetParentTrackOfId(user_id);; ptrTrack = gGeoManager->GetTrack(index);; ```. Supposing a particle represented by a primary track decays or interacts,; one should not create new primaries as described before, but rather add; them as secondary:. ``` {.cpp}; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; ```. At any step made by the current track, one is able to add control points; to either primary or secondary:. ``` {.cpp}; track->AddPoint(x,y,z,t);; ```. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from **`TGeoManager`** context menu:. ``` {.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ```. The drawing/animation time range is a global variable that can be; directly set:. ``` {.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ```. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:129378,Security,access,accessible,129378,"to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the **`TGeoChecker`** class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. ![Extruding volumes](pictures/030001DE.png). A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:137507,Security,validat,validation,137507,"arated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/u",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:144160,Security,validat,validation,144160,"ing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clip",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:144525,Security,access,accessible,144525," currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165699,Security,access,access,165699,"is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories o",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167806,Security,access,accessed,167806,"ing different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171843,Security,access,accessible,171843,"s active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visua",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:174070,Security,validat,validate,174070,"l volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no mater",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:174122,Security,validat,validation,174122,"ected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically a",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:10243,Testability,log,logical,10243,"` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are seen when; visualizing or tracking the geometry are depicted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by **`TGeoNode`** objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at; <https://root.cern.ch/doc/master/classTGeoManager.html>. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:20687,Testability,test,test,20687,"lem, Double_t density); ```. To create a radioactive mixture, one can use radionuclides as well as; stable elements:. ``` {.cpp}; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; ```. Once defined, one can retrieve the time evolution for the radioactive; materials/mixtures by using one of the next two methods:. 1. `TGeoMaterial::FillMaterialEvolution(TObjArray *population,`; ` Double_t precision=0.001)`. To use this method, one has to provide an empty **`TObjArray`** object; that will be filled with all elements coming from the decay chain of the; initial radionuclides contained by the material/mixture. The precision; represent the cumulative branching ratio for which decay products are; still considered. ![Concentration of C14 derived elements](pictures/030001B3.png). The population list may contain stable elements as well as; radionuclides, depending on the initial elements. To test if an element; is a radionuclide:. ``` {.cpp}; Bool_t TGeoElement::IsRadioNuclide() const; ```. All radionuclides in the output population list have attached objects; that represent the time evolution of their fraction of nuclei with; respect to the top radionuclide in the decay chain. These objects; (Bateman solutions) can be retrieved and drawn:. ``` {.cpp}; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; ```. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. 2. `TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001)`. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. ![Concentracion of elements de",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:48488,Testability,stub,stub,48488,"rs, the created Boolean nodes will assume that; the shapes are positioned with an identity transformation with respect; to the frame of the created composite. In order to provide some; positioning of the combination components, we have to attach after each; shape identifier the name of an existing transformation, separated by a; colon. Obviously all transformations created for this purpose have to be; objects with unique names in order to be properly substituted during; parsing. #### Composite Shape Example. One should have in mind that the same shape or matrix identifiers can be; used many times in the same expression, as in the following example:. ``` {.cpp}; const Double_t sq2 = TMath::Sqrt(2.);; gSystem->Load(""libGeom"");; TGeoManager *mgr =; new TGeoManager(""Geom"",""composite shape example"");; TGeoMedium *medium = 0;; TGeoVolume *top = mgr->MakeBox(""TOP"",medium,100,250,250);; mgr->SetTopVolume(top);. // make shape components; TGeoBBox *sbox = new TGeoBBox(""B"",100,125*sq2,125*sq2);; TGeoTube *stub = new TGeoTube(""T"",0,100,250);; TGeoPgon *spgon = new TGeoPgon(""P"",0.,360.,6,2);; spgon->DefineSection(0,-250,0,80);; spgon->DefineSection(1,250,0,80);. // define some rotations; TGeoRotation *r1 = new TGeoRotation(""r1"",90,0,0,180,90,90);; r1->RegisterYourself();; TGeoRotation *r2 = new TGeoRotation(""r2"",90,0,45,90,45,270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();; ```. ![A composite shape example](pictures/080001CD.png). Composite shapes can be subsequently used for defining volumes.; Moreover, these volumes contain other volumes, following the general; criteria. Volumes created based on composite shapes cannot be divided. ### Navigation Methods Performed By Shapes. Shapes are named ob",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:58292,Testability,log,logical,58292,"ties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within this unless it is specified (see section:; Overlapping Volumes).; - The top volume (containing all geometry trees) must be specified; before closing the geometry and must not be positioned - it; represents the global reference frame.; - After building the full geometry tree, the geometry must be closed; (see the method **`TGeoManager`**`::CloseGeometry()`). Voxelization; can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry; creation procedure in the following sections. Provided that geometry was; successfully built and closed, the **`TGeoManager`** class will register; itself to ROOT and the logical/physical structures will become; immediately browsable. ### The Volume Hierarchy. The basic components used for building the logical hierarchy of the; geometry are the positioned volumes called `nodes`. Volumes are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of; volumes inside a container volume but users do not directly create them.; They are automatically created as a result of adding one volume inside; other or dividing a volume. The geometrical transformation held by nodes; is always defined with respect to their mother (relative positioning).; Reflection matrices are allowed. A hierarchical element is not fully defined by a node since nodes are; not directly linked to each other, but through volumes (a node points to; a volume, which at its turn points to a list of nodes):. `NodeTop ` ` VolTop ` ` NodeA ` ` VolA ` `...`. One can therefor",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:58425,Testability,log,logical,58425,"uild time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within this unless it is specified (see section:; Overlapping Volumes).; - The top volume (containing all geometry trees) must be specified; before closing the geometry and must not be positioned - it; represents the global reference frame.; - After building the full geometry tree, the geometry must be closed; (see the method **`TGeoManager`**`::CloseGeometry()`). Voxelization; can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry; creation procedure in the following sections. Provided that geometry was; successfully built and closed, the **`TGeoManager`** class will register; itself to ROOT and the logical/physical structures will become; immediately browsable. ### The Volume Hierarchy. The basic components used for building the logical hierarchy of the; geometry are the positioned volumes called `nodes`. Volumes are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of; volumes inside a container volume but users do not directly create them.; They are automatically created as a result of adding one volume inside; other or dividing a volume. The geometrical transformation held by nodes; is always defined with respect to their mother (relative positioning).; Reflection matrices are allowed. A hierarchical element is not fully defined by a node since nodes are; not directly linked to each other, but through volumes (a node points to; a volume, which at its turn points to a list of nodes):. `NodeTop ` ` VolTop ` ` NodeA ` ` VolA ` `...`. One can therefore talk about ""the node or volume hierarchy"", but in; fact, an element is made by a pair volume-node. In the line above is; represented just a single branch, but of course from any v",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:60093,Testability,log,logical,60093,"nts to; a volume, which at its turn points to a list of nodes):. `NodeTop ` ` VolTop ` ` NodeA ` ` VolA ` `...`. One can therefore talk about ""the node or volume hierarchy"", but in; fact, an element is made by a pair volume-node. In the line above is; represented just a single branch, but of course from any volume other; branches can also emerge. The index of a node in such a branch (counting; only nodes) is called `depth`. The top node have always `depth=0`. Volumes need to have their daughter nodes defined when the geometry is; closed. They will build additional structures (called `voxels` ) in; order to fasten-up the search algorithms. Finally, nodes can be regarded; as bi-directional links between containers and contained volumes. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other; volumes), every volume becoming a branch in this graph. Any volume in; the logical graph can become the actual top volume at run time (see; **`TGeoManager::SetTopVolume()`). All functionalities of the modeller; will behave in this case as if only the corresponding branch starting; from this volume is the active geometry.**. ![A geometry hierarchy in memory](pictures/030001CE.png). Nodes are never instantiated directly by users, but created as a result; of volume operations. Adding a volume named A with a given `user id`; inside a volume B will create a node named `A_id.` This will be added to; the list of nodes stored by B. In addition, when applying a division; operation in N slices to a volume A, a list of nodes `B_1`, `B_2`, ... ,; `B_N` is also created. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformatio",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:61241,Testability,log,logical,61241,"f only the corresponding branch starting; from this volume is the active geometry.**. ![A geometry hierarchy in memory](pictures/030001CE.png). Nodes are never instantiated directly by users, but created as a result; of volume operations. Adding a volume named A with a given `user id`; inside a volume B will create a node named `A_id.` This will be added to; the list of nodes stored by B. In addition, when applying a division; operation in N slices to a volume A, a list of nodes `B_1`, `B_2`, ... ,; `B_N` is also created. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformation matrix can be computed as the pile-up of all local; transformations in its branch. We will therefore call `logical graph`; the hierarchy defined by nodes and volumes. The expansion of the logical; graph by all possible paths defines a tree structure where all nodes are; unique ""touchable"" objects. We will call this the ""physical tree"".; Unlike the logical graph, the physical tree can become a huge structure; with several millions of nodes in case of complex geometries; therefore,; it is not always a good idea to keep it transient in memory. Since the; logical and physical structures are correlated, the modeller rather; keeps track only of the current branch, updating the current global; matrix at each change of the level in geometry. The current physical; node is not an object that can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes f",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:61322,Testability,log,logical,61322," in memory](pictures/030001CE.png). Nodes are never instantiated directly by users, but created as a result; of volume operations. Adding a volume named A with a given `user id`; inside a volume B will create a node named `A_id.` This will be added to; the list of nodes stored by B. In addition, when applying a division; operation in N slices to a volume A, a list of nodes `B_1`, `B_2`, ... ,; `B_N` is also created. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformation matrix can be computed as the pile-up of all local; transformations in its branch. We will therefore call `logical graph`; the hierarchy defined by nodes and volumes. The expansion of the logical; graph by all possible paths defines a tree structure where all nodes are; unique ""touchable"" objects. We will call this the ""physical tree"".; Unlike the logical graph, the physical tree can become a huge structure; with several millions of nodes in case of complex geometries; therefore,; it is not always a good idea to keep it transient in memory. Since the; logical and physical structures are correlated, the modeller rather; keeps track only of the current branch, updating the current global; matrix at each change of the level in geometry. The current physical; node is not an object that can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:61484,Testability,log,logical,61484,"a node named `A_id.` This will be added to; the list of nodes stored by B. In addition, when applying a division; operation in N slices to a volume A, a list of nodes `B_1`, `B_2`, ... ,; `B_N` is also created. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformation matrix can be computed as the pile-up of all local; transformations in its branch. We will therefore call `logical graph`; the hierarchy defined by nodes and volumes. The expansion of the logical; graph by all possible paths defines a tree structure where all nodes are; unique ""touchable"" objects. We will call this the ""physical tree"".; Unlike the logical graph, the physical tree can become a huge structure; with several millions of nodes in case of complex geometries; therefore,; it is not always a good idea to keep it transient in memory. Since the; logical and physical structures are correlated, the modeller rather; keeps track only of the current branch, updating the current global; matrix at each change of the level in geometry. The current physical; node is not an object that can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in the geometry can be saved as; a starting state for later use. Nodes can be declared as `overlapping` in case they do overlap with; other nodes inside the same container or extrude this container (see; also ‘Ch",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:61692,Testability,log,logical,61692,"reated. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformation matrix can be computed as the pile-up of all local; transformations in its branch. We will therefore call `logical graph`; the hierarchy defined by nodes and volumes. The expansion of the logical; graph by all possible paths defines a tree structure where all nodes are; unique ""touchable"" objects. We will call this the ""physical tree"".; Unlike the logical graph, the physical tree can become a huge structure; with several millions of nodes in case of complex geometries; therefore,; it is not always a good idea to keep it transient in memory. Since the; logical and physical structures are correlated, the modeller rather; keeps track only of the current branch, updating the current global; matrix at each change of the level in geometry. The current physical; node is not an object that can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in the geometry can be saved as; a starting state for later use. Nodes can be declared as `overlapping` in case they do overlap with; other nodes inside the same container or extrude this container (see; also ‘Checking the Geometry'). Non-overlapping nodes can be created; with:. ``` {.cpp}; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; ```. The creation of overlapping nodes can be ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69459,Testability,log,logical,69459," management is handled by volumes. These build; additional optimization structures upon geometry closure. In order to; have navigation features properly working one has to follow some rules; for building a valid geometry. - The daughter volume(s) must not extrude the mother shape. They are; allowed however to have a common boundaries.; - The volumes positioned in the same container must not overlap with; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its m",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:72841,Testability,test,test,72841,"bling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ``` {.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ```. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see **`TGeoMedium`** class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ``` {.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ```. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ``` {.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); ```. **(\*)** Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been abl",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:100504,Testability,log,logical,100504,"s a global pointer; ***`gGeoManager`*** in order to be fully accessible from external code.; The manager class is the owner of all geometry objects defined in a; session; therefore, users must not try to control their deletion. It; contains lists of media, materials, transformations, shapes and volumes.; A special case is the one of geometrical transformations. When creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use `TGeoMatrix::RegisterYourself()` method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; **`TGeoVolume`** class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node afte",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103608,Testability,test,testing,103608,"etry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:108885,Testability,test,test,108885,"`folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ``` {.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ```. - The `current node`***`, `***`volume` and `material`. In order to; take decisions on post-step or further stepping actions, one has to; know these. In order to get a pointer to the current node one can; do:. ``` {.cpp}; TGeoNode *cnode = gGeoManager->GetCurrentNode();; // then:; TGeoVolume *cvol = gGeoManager->GetCurrentVolume();; // or:; cvol = cnode->GetVolume(); // (*); // then:; TGeoMaterial *cmat = cvol->GetMedium()->GetMaterial();; ```. (\*) Note: If the current point is in fact outside the geometry, the; current node pointer will not be NULL, but pointing to the top node. In order to take decisions in such case one needs always to test:. ``` {.cpp}; if (gGeoManager->IsOutside()) {; // current point is actually outside; ... // corresponding action; }; ```. Specific information related to the current volume/node like ID's or; shape can be then retrieved from the corresponding objects. - Current state `index`. The number of possible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:109549,Testability,log,logical,109549,"ume(); // (*); // then:; TGeoMaterial *cmat = cvol->GetMedium()->GetMaterial();; ```. (\*) Note: If the current point is in fact outside the geometry, the; current node pointer will not be NULL, but pointing to the top node. In order to take decisions in such case one needs always to test:. ``` {.cpp}; if (gGeoManager->IsOutside()) {; // current point is actually outside; ... // corresponding action; }; ```. Specific information related to the current volume/node like ID's or; shape can be then retrieved from the corresponding objects. - Current state `index`. The number of possible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; l",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110331,Testability,log,logical,110331,"nce; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This rep",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110434,Testability,log,logical,110434," cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110799,Testability,log,logical,110799,"lt and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ```. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can b",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:147884,Testability,log,logical,147884,"s; essential since there is no other way of identifying them. One can; however create ""symbolic links"" to any complex path to make it more; representable for the object it designates:. ``` {.cpp}; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); ```. Such a symbolic link hides the complexity of the path to the align; object and replaces it with a more meaningful name. In addition,; **`TGeoPNEntry`** objects are faster to search by name and they may; optionally store an additional user matrix. ``` {.cpp}; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,; const char*path); // Retrieving an existing alignable object.; TGeoPNEntry *TGeoManager::GetAlignableEntry(const char *name); // Retrieving an existing alignable object at a given index.; TGeoPNEntry *GetAlignableEntry(Int_t index); ```. Physical nodes store internally the full list of logical nodes; corresponding to the elements from the string path, as well as the; global transformation matrix for each of them. The top node corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ``` {.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ```. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ``` {.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ```. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarc",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:148909,Testability,log,logical,148909,"nodes; corresponding to the elements from the string path, as well as the; global transformation matrix for each of them. The top node corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ``` {.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ```. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ``` {.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ```. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ``` {.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ```. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nod",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157237,Testability,log,logical,157237,"n our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. ![Finding the location of a point in the geometry hierarchy](pictures/08",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:1988,Usability,simpl,simplest,1988,"ieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = n",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2673,Usability,simpl,simplest,2673,"tself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4067,Usability,simpl,simple,4067,"0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4773,Usability,learn,learn,4773,"essages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. ***`Q:`*** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". ***`A:`*** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ***`containment`***. This is; accomplished by ***`positioning`*** some volumes ***`inside`*** others.; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:6493,Usability,simpl,simple,6493,".; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ***`local geometrical transformation`*** of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. ***`Q:`*** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?"". ***`A:`*** You will also notice that several other volumes are created; by using lines like:. ``` {.cpp}; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); ```. In the method above **`XXX`** represent some shape name (Box, Tube,; etc.). This is just a simple way of creating a volume having a given; shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and ROOT volumes, they are just some; ***`virtual volumes`*** used for grouping and positioning together other; ***`real volumes`***. See ""Positioned Volumes (Nodes)"". The same; structure represented by (a real or) a virtual volume can be; ***`replicated`*** several times in the geometry. ***`Q:`*** ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode()",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:8112,Usability,simpl,simple,8112,"make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". ***`A:`*** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ***`node`*** of; its container and a new object of the class **`TGeoNode`** is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final `TGeoVolume::Draw() `call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folde",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22647,Usability,simpl,simple,22647," of elements derived; fromCa53+Sr78](pictures/030001B4.png). ### Tracking Media. The class **`TGeoMedium`** describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:25199,Usability,simpl,simplicity,25199,"- Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]. ### Primitive Shapes. #### Boxes - TGeoBBox Class. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other sha",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44401,Usability,simpl,simple,44401,"n this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the man",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44788,Usability,simpl,simple,44788,"as a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the manager class and stored; as the ""left"" shape in the Boolean union node. Since the second; expression is not yet fully decomposed, the ""right"" shape in the; combination is created as a new composite shape. This will split at its; turn B+C into B and C and create a **`TGeoUnion`**`(""B"",""C"")`. The B and; C identifiers will be looked for and replaced by the pointers to the; actual shapes into the new node. Fin",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:72978,Usability,simpl,simple,72978,"sembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ``` {.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ```. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see **`TGeoMedium`** class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ``` {.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ```. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ``` {.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); ```. **(\*)** Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been able to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",pt",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:74919,Usability,simpl,simplicity,74919,"le to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,; 0,0.01,1); //(*); ```. **(\*)** The same applies for all primitive shapes, for which there can; be found corresponding `MakeSHAPE()` methods. Their usage is much more; convenient unless a shape has to be shared between more volumes. Let us make now an aluminum wire having the same shape, supposing that; we have created the copper wire with the line above:. ``` {.cpp}; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; ```. We would like now to position our wire in the middle of a gas chamber.; We need first to define the gas chamber:. ``` {.cpp}; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; ```. Now we can put the wire inside:. ``` {.cpp}; chamber->AddNode(wire_co,1);; ```. If we inspect now the chamber volume in a browser, we will notice that; it has one daughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we ha",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:75804,Usability,simpl,simple,75804,"ughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigatio",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80089,Usability,simpl,simple,80089,", we will just need to; replicate the ones that we have already created. ``` {.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`T",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80672,Usability,simpl,simple,80672,"o replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a **`TGeoVolumeMulti`** equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be forced; in particular cases:. ``` {.cpp}; TGeoManager::Volume(const char *vname,const char *shape,; Int_t nmed);; ```. Where: `vname` is the family name, `nmed` is the medium number and; `shap",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83858,Usability,simpl,simplest,83858,"ume families are; used is when we want that a volume positioned inside a container to; match one ore more container limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corre",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83956,Usability,simpl,simple,83956,"tainer limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:88199,Usability,simpl,simply,88199," one (GEANT3 like). Divides `MOTHER` into `NDIV` divisions called `NAME` along axis `IAXIS`; starting at coordinate value `START` and having size `STEP`. The created; volumes will have tracking media `ID=NUMED` (if `NUMED=0` -\> same media; as `MOTHER`). The behavior of the division operation can be triggered using `OPTION`; (case insensitive):. - `N`divide all range in `NDIV` cells (same effect as `STEP<=0`); (GSDVN in G3); - `NX`divide range starting with `START` in `NDIV` cells (GSDVN2 in; G3); - `S`divide all range with given `STEP`; `NDIV` is computed and; divisions will be centered in full range (same effect as `NDIV<=0`); (GSDVS, GSDVT in G3); - `SX`same as `DVS`, but from `START` position (GSDVS2, GSDVT2 in G3). #### Volume Assemblies. In general, geometry contains structures of positioned volumes that have; to be grouped and handled together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; "" Overlapping Volumes **""**); - Representing the container as a composite shape - the Boolean union; of all components (see also "" Composite Shapes ""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all vo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90843,Usability,simpl,simple,90843,". Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the;",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:92429,Usability,simpl,simple,92429,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|$; Scale:; $\left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$. Inverse rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Inverse translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|$; Inverse scale:; $\left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & 0 & 0 \\; 0 & 0 & \frac{1}{s_z} &",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101832,Usability,simpl,simple,101832,". ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, b",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:105461,Usability,simpl,simple,105461," *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. The direction can be initialized in a similar manner as the current; point:. ``` {.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ```. ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: **`TGeoNode`**; \*`TGeoManager::fCurrentNode `and can be asked from the manager class; only after the `'Where am I?'` was completed:. ``` {.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ```. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();;",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:105621,Usability,simpl,simple,105621,"o know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. The direction can be initialized in a similar manner as the current; point:. ``` {.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ```. ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: **`TGeoNode`**; \*`TGeoManager::fCurrentNode `and can be asked from the manager class; only after the `'Where am I?'` was completed:. ``` {.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ```. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Set",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110150,Usability,simpl,simple,110150,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state I",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110188,Usability,simpl,simple,110188,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state I",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:137995,Usability,simpl,simple,137995,"nd; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black.",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:143496,Usability,simpl,simple,143496,"l visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corre",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:163517,Usability,simpl,simple,163517," frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: Th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171187,Usability,undo,undoable,171187,"; ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171751,Usability,undo,undoable,171751," apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictur",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4808,Availability,avail,available,4808,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:11877,Availability,avail,available,11877,"bles/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with the version number. ![](pictures/0300000F.png). #### Classes Menu. - *Classes*: starts the ClassTree viewer that draws inheritance tree; for a list of classes. #### Toolbar. The following menu shortcuts and utilities are available from the; toolbar:. ![](pictures/03000010.png) Create a new canvas window. ![](pictures/03000011.png) Popup the Open File dialog. ![](pictures/03000012.png) Popup the Save As... dialog. ![](pictures/03000013.png) Popup the Print dialog. ![](pictures/03000014.png) Interrupts the current drawing process. ![](pictures/03000015.png) Redraw the canvas. ![](pictures/03000016.png) Inspect the ***`gROOT`*** object. ![](pictures/03000017.png) Create a new objects' browser. You can create the following graphical objects using the toolbar; buttons for primitive drawing. Tool tips are provided for helping; your choice. ![](pictures/03000018.png) **An Arc or circle**: Click on the center; of the arc, and then move the mouse. A rubber band circle is shown.; Click again with the left button to freeze the arc. ![](pictures/03000019.png) **A Line**: Click with the left button at; the point where you want to start the line, then move the mouse and; click again with the left button to ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:15693,Availability,down,down,15693," line. Once done, click with the third button to change the; characteristics of the curly line, like transform it to wave, change; the wavelength, etc. ![](pictures/03000023.png) **A Curly Arc**: Proceed like for an; ellipse. The first click is located at the position of the center, the; second click at the position of the arc beginning. Once done, one; obtains a curly ellipse, for which one can click with the third button; to change the characteristics, like transform it to wavy, change the; wavelength, set the minimum and maximum angle to make an arc that is; not closed, etc. ![](pictures/03000024.png) **A Text/Latex string**: Click with the; left button where you want to draw the text and then type in the text; terminated by carriage return. All **`TLatex`** expressions are valid.; To move the text or formula, point on it keeping the left mouse button; pressed and drag the text to its new position. You can grow/shrink the; text if you position the mouse to the first top-third part of the; string, then move the mouse up or down to grow or shrink the text; respectively. If you position the mouse near the bottom-end of the; text, you can rotate it. ![](pictures/03000025.png) **A Marker**: Click with the left button; where to place the marker. The marker can be modified by using the; method `SetMarkerStyle()` of **`TSystem`**. ![](pictures/03000026.png) **A Graphical Cut**: Click with the left; button on each point of a polygon delimiting the selected area. Close; the cut by double clicking on the last point. A **`TCutG`** object is; created. It can be used as a selection for a **`TTree`**`::Draw`. You; can get a pointer to this object with:. ``` {.cpp}; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); ```. Once you are happy with your picture, you can select the; `Save as canvas.C` item in the canvas File menu. This will; automatically generate a script with the C++ statements corresponding; to the picture. This facility also works if you have other objects not; drawn",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:18076,Availability,avail,available,18076,"r; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interface for Histograms"", ""The User; Interface for Graphs"". ### Classes, Methods and Constructors. Object oriented programming introduces objects, which have data; members and methods. The next line creates an object named `f1` of the; class **`TF1`** that is a one-dimensional function. The type of an; object is called a class. The object itself is called an instance of a; class. When a method builds an object, it is called a constructor. ``` {.cpp}; TF1 f1(""func1"",""sin(x)/x"",0,10); ```. In our constructor the function sin(x)/x is defined for use, and 0 and; 10 are the limits. The first parameter, `func1` is the name of the; object `f1`. Most objects in ROOT have a n",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:21205,Availability,avail,available,21205,"e function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will generate a script; showing the options set in the current canvas. Notice that you can; also save the picture into various file formats such as PostScript,; GIF, etc. Another interesting possibility is to save y",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:25215,Availability,avail,available,25215,"s... This; dialog gives a choice to show or suppress the confirmation message for; overwriting an existing file. If the Overwrite check box is not selected, a message dialog appears; asking the user to overwrite the file (Yes/No). The user choice is; saved for the next time the Save As... dialog shows up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Command Line. We have briefly touched on how to use the command line. There are; different types of commands. 1. Cling commands start with ""`.`"". ``` {.cpp}; root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]; ```. 2. SHELL commands start with ""`.!`"" for example:. ``` {.cpp}; root[] .! ls; ```. 3. C++ commands follow C++ syntax (almost). ``` {.cpp}; root[] TBrowser *b = new TBrowser(); ```. ### Multi-line Commands. You can use the command line to execute multi-line commands. To begin; a multi-line command you must type a single left curly bracket `{`,; and to end it you must type a single right curly bracket `}`.; For example:. ``` {.cpp}; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:38441,Availability,down,down,38441,".rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:285,Deployability,install,installed,285,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:1828,Deployability,install,installed,1828,"OOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set correctly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line opti",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:2424,Deployability,patch,patches,2424,"brary path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set correctly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8466,Deployability,toggle,toggles,8466,"nvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8734,Deployability,toggle,toggles,8734," the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can be interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8996,Deployability,toggle,toggles,8996," drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can be interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits to the window when changing the window; size;; - *off* - the canvas stays fixed when changing the window size. - *Resize Canvas",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:10639,Deployability,toggle,toggles,10639,"e interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits to the window when changing the window; size;; - *off* - the canvas stays fixed when changing the window size. - *Resize Canvas*: resizes and fits the canvas to the window size. - *Move Opaque*: if selected, graphics objects are moved in opaque; mode; otherwise, only the outline of objects is drawn when moving; them. The option opaque produces the best effect but it requires a; reasonably fast workstation or response time. - *Resize Opaque*: if selected, graphics objects are resized in; opaque mode; otherwise, only the outline of objects is drawn when; resizing them. - *Interrupt*: interrupts the current drawing process. - *Refresh*: redraws the canvas contents. - *Pad Auto Exec*: executes the list of **`TExecs`** in the current; pad. - *Statistics*: toggles the display of the histogram statistics box. - *Histogram Title*: toggles the display of the histogram title. - *Fit Parameters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with t",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:10713,Deployability,toggle,toggles,10713,"or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits to the window when changing the window; size;; - *off* - the canvas stays fixed when changing the window size. - *Resize Canvas*: resizes and fits the canvas to the window size. - *Move Opaque*: if selected, graphics objects are moved in opaque; mode; otherwise, only the outline of objects is drawn when moving; them. The option opaque produces the best effect but it requires a; reasonably fast workstation or response time. - *Resize Opaque*: if selected, graphics objects are resized in; opaque mode; otherwise, only the outline of objects is drawn when; resizing them. - *Interrupt*: interrupts the current drawing process. - *Refresh*: redraws the canvas contents. - *Pad Auto Exec*: executes the list of **`TExecs`** in the current; pad. - *Statistics*: toggles the display of the histogram statistics box. - *Histogram Title*: toggles the display of the histogram title. - *Fit Parameters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with the version number. ![](pictures/0300000F.png). #### Classes Menu. -",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:10777,Deployability,toggle,toggles,10777,"ize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits to the window when changing the window; size;; - *off* - the canvas stays fixed when changing the window size. - *Resize Canvas*: resizes and fits the canvas to the window size. - *Move Opaque*: if selected, graphics objects are moved in opaque; mode; otherwise, only the outline of objects is drawn when moving; them. The option opaque produces the best effect but it requires a; reasonably fast workstation or response time. - *Resize Opaque*: if selected, graphics objects are resized in; opaque mode; otherwise, only the outline of objects is drawn when; resizing them. - *Interrupt*: interrupts the current drawing process. - *Refresh*: redraws the canvas contents. - *Pad Auto Exec*: executes the list of **`TExecs`** in the current; pad. - *Statistics*: toggles the display of the histogram statistics box. - *Histogram Title*: toggles the display of the histogram title. - *Fit Parameters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with the version number. ![](pictures/0300000F.png). #### Classes Menu. - *Classes*: starts the ClassTree viewer that draws inheritance tree; for a",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4756,Energy Efficiency,power,powerful,4756,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:39510,Energy Efficiency,monitor,monitoring,39510,"e recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your code or on the command line you can type the line:. ``` {.cpp}; gObjectTable->Print();; ```. This line will print the list of all active classes and the number of; instances for each class. By comparing consecutive print outs, you can; see objects that you forgot to delete. Note that this method cannot; show leaks coming from the allocation of non-objects or classes; unknown to ROOT. ## Converting from PAW to ROOT. The web page at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE> gives the; ""translation"" table of some commonly used PAW commands into ROOT. If; you move the mouse cursor over the picture at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#SET>, you will get; the corresponding ROOT commands as tooltips. ### Converting HB",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:2089,Integrability,depend,depending,2089,". ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set correctly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macro",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7271,Integrability,message,messages,7271,"nvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be imple",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7369,Integrability,interface,interface,7369,"as by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; o",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8666,Integrability,interface,interface,8666,"popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:17456,Integrability,interface,interface,17456," are happy with your picture, you can select the; `Save as canvas.C` item in the canvas File menu. This will; automatically generate a script with the C++ statements corresponding; to the picture. This facility also works if you have other objects not; drawn with the graphics editor (histograms for example). ### The Editor Frame. The ROOT graphics editor loads the corresponding object editor; `objEditor` according to the selected object `obj` in the canvas; respecting the class inheritance. An object in the canvas is selected; after the left mouse click on it. For example, if the selected object; is **`TAxis`**, the **`TAxisEditor`** will shows up in the editor; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interfac",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:17570,Integrability,interface,interface,17570,"u have other objects not; drawn with the graphics editor (histograms for example). ### The Editor Frame. The ROOT graphics editor loads the corresponding object editor; `objEditor` according to the selected object `obj` in the canvas; respecting the class inheritance. An object in the canvas is selected; after the left mouse click on it. For example, if the selected object; is **`TAxis`**, the **`TAxisEditor`** will shows up in the editor; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interface for Histograms"", ""The User; Interface for Graphs"". ### Classes, Methods and Constructors. Object oriented programming introduces objects, which have data; members and methods. The next line creates an object named `f1` of the",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:18037,Integrability,interface,interface,18037,"r; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interface for Histograms"", ""The User; Interface for Graphs"". ### Classes, Methods and Constructors. Object oriented programming introduces objects, which have data; members and methods. The next line creates an object named `f1` of the; class **`TF1`** that is a one-dimensional function. The type of an; object is called a class. The object itself is called an instance of a; class. When a method builds an object, it is called a constructor. ``` {.cpp}; TF1 f1(""func1"",""sin(x)/x"",0,10); ```. In our constructor the function sin(x)/x is defined for use, and 0 and; 10 are the limits. The first parameter, `func1` is the name of the; object `f1`. Most objects in ROOT have a n",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:24308,Integrability,message,message,24308,"e method `TCanvas::cd()` with the pad number, as was done in; the example above:. ``` {.cpp}; root[] MyC->cd(3); ```. Pads are numbered from left to right and from top to bottom. Each new; pad created by `TCanvas::Divide()` has a name, which is the name of; the canvas followed by \_1, \_2, etc. To apply the method `cd()` to; the third pad, you would write:. ``` {.cpp}; root[] MyC_3->cd(); ```. - Third pad will be selected since you called `TPad::cd()` for the; object `MyC_3`. ROOT will find the pad that was named` MyC_3 `when; you typed it on the command line (see ROOT/Cling Extensions to; C++). ### Saving the Canvas. ![The SaveAs... dialog](pictures/0300002B.png). Using the File menu / Save cascade menu users can save the canvas as; one of the files from the list. Please note that saving the canvas; this way will overwrite the file with the same name without a warning. All supported file types can be saved via File menu / SaveAs... This; dialog gives a choice to show or suppress the confirmation message for; overwriting an existing file. If the Overwrite check box is not selected, a message dialog appears; asking the user to overwrite the file (Yes/No). The user choice is; saved for the next time the Save As... dialog shows up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Co",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:24397,Integrability,message,message,24397,"```. Pads are numbered from left to right and from top to bottom. Each new; pad created by `TCanvas::Divide()` has a name, which is the name of; the canvas followed by \_1, \_2, etc. To apply the method `cd()` to; the third pad, you would write:. ``` {.cpp}; root[] MyC_3->cd(); ```. - Third pad will be selected since you called `TPad::cd()` for the; object `MyC_3`. ROOT will find the pad that was named` MyC_3 `when; you typed it on the command line (see ROOT/Cling Extensions to; C++). ### Saving the Canvas. ![The SaveAs... dialog](pictures/0300002B.png). Using the File menu / Save cascade menu users can save the canvas as; one of the files from the list. Please note that saving the canvas; this way will overwrite the file with the same name without a warning. All supported file types can be saved via File menu / SaveAs... This; dialog gives a choice to show or suppress the confirmation message for; overwriting an existing file. If the Overwrite check box is not selected, a message dialog appears; asking the user to overwrite the file (Yes/No). The user choice is; saved for the next time the Save As... dialog shows up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Command Line. We have briefly touched on how to use the command line. There are; different types of commands. 1. Cl",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31342,Integrability,protocol,protocol,31342," of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31604,Integrability,protocol,protocol,31604,"ger 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you g",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:232,Modifiability,variab,variables,232,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:529,Modifiability,variab,variable,529,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:610,Modifiability,variab,variables,610,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:775,Modifiability,variab,variable,775,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3326,Modifiability,config,config,3326," to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3343,Modifiability,config,configure,3343,"-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4840,Modifiability,variab,variables,4840,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:6016,Modifiability,inherit,inheritance,6016,"e:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn in the active pad. The obvious question is: what is the relation; between a canvas and a pad? In fact, a canvas is a pad that spans; through an entire window. This is nothing else than the notion of; inheritance. The **`TPad`** class is the parent of the **`TCanvas`**; class. In ROOT, most objects derive from a base class **`TObject`**.; This class has a virtual method `Draw()` such as all objects are; supposed to be able to be ""drawn"". If several canvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:11775,Modifiability,inherit,inheritance,11775,"meters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with the version number. ![](pictures/0300000F.png). #### Classes Menu. - *Classes*: starts the ClassTree viewer that draws inheritance tree; for a list of classes. #### Toolbar. The following menu shortcuts and utilities are available from the; toolbar:. ![](pictures/03000010.png) Create a new canvas window. ![](pictures/03000011.png) Popup the Open File dialog. ![](pictures/03000012.png) Popup the Save As... dialog. ![](pictures/03000013.png) Popup the Print dialog. ![](pictures/03000014.png) Interrupts the current drawing process. ![](pictures/03000015.png) Redraw the canvas. ![](pictures/03000016.png) Inspect the ***`gROOT`*** object. ![](pictures/03000017.png) Create a new objects' browser. You can create the following graphical objects using the toolbar; buttons for primitive drawing. Tool tips are provided for helping; your choice. ![](pictures/03000018.png) **An Arc or circle**: Click on the center; of the arc, and then move the mouse. A rubber band circle is shown.; Click again with the left button to freeze the arc. ![](pictures/03000019.png) **A Line**: Click with the left button at; the po",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:16878,Modifiability,inherit,inheritance,16878,"rotate it. ![](pictures/03000025.png) **A Marker**: Click with the left button; where to place the marker. The marker can be modified by using the; method `SetMarkerStyle()` of **`TSystem`**. ![](pictures/03000026.png) **A Graphical Cut**: Click with the left; button on each point of a polygon delimiting the selected area. Close; the cut by double clicking on the last point. A **`TCutG`** object is; created. It can be used as a selection for a **`TTree`**`::Draw`. You; can get a pointer to this object with:. ``` {.cpp}; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); ```. Once you are happy with your picture, you can select the; `Save as canvas.C` item in the canvas File menu. This will; automatically generate a script with the C++ statements corresponding; to the picture. This facility also works if you have other objects not; drawn with the graphics editor (histograms for example). ### The Editor Frame. The ROOT graphics editor loads the corresponding object editor; `objEditor` according to the selected object `obj` in the canvas; respecting the class inheritance. An object in the canvas is selected; after the left mouse click on it. For example, if the selected object; is **`TAxis`**, the **`TAxisEditor`** will shows up in the editor; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT s",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:26726,Modifiability,variab,variables,26726,"ntax (almost). ``` {.cpp}; root[] TBrowser *b = new TBrowser(); ```. ### Multi-line Commands. You can use the command line to execute multi-line commands. To begin; a multi-line command you must type a single left curly bracket `{`,; and to end it you must type a single right curly bracket `}`.; For example:. ``` {.cpp}; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; ```. It is more convenient to edit a script than the command line, and if; your multi line commands are getting unmanageable, you may want to; start with a script instead. ### Cling Extensions. We should say that some things are not standard C++. The Cling; interpreter has several extensions. See ""ROOT/Cling Extensions to C++"". ### Helpful Hints for Command Line Typing. The interpreter knows all the classes, functions, variables, and user; defined types. This enables ROOT to help users to complete the command; line. For example, if we do not know anything about the **`TLine`**; class, the Tab feature helps us to get a list of all classes starting; with **`TL`**(where `<TAB>` means type the Tab key). ``` {.cpp}; root[] l = new TLi<TAB>; TList; TListIter; TLink; TLine; TLimitDataSource; TLimit; ```. To list the different constructors and parameters for **`TLine`** use; the `<TAB>` key as follows:. ``` {.cpp}; root[] l = new TLine(<TAB>; TLine TLine(); TLine TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); TLine TLine(const TLine& line); ```. ### Regular Expression. The meta-characters below can be used in a regular expression:. - '`^`' start-of-line anchor. - '`$`' end-of-line anchor. - '`.`' matches any character. - '`[`' start a character class. - '`]`'end a character class. - '`^`'negates character class if first character. - '`*`'`Kleene` closure (matches 0 or more). - '`+`'Positive ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:29801,Modifiability,variab,variables,29801,"hod finds the first occurrence of the regular expression in the; `string` and returns its position. ## Conventions. In this paragraph, we will explain some of the conventions used in; ROOT source and examples. ### Coding Conventions. From the first days of ROOT development, it was decided to use a set; of coding conventions. This allows a consistency throughout the source; code. Learning these will help you identify what type of information; you are dealing with and enable you to understand the code better and; quicker. Of course, you can use whatever convention you want but if; you are going to submit some code for inclusion into the ROOT sources,; you will need to use these. These are the coding conventions:. - Classes begin with **`T`**: **`TLine`**, **`TTree`**. - Non-class types end with **`_t`**: `Int_t`. - Data members begin with **`f`**: `fTree`. - Member functions begin with a capital: `Loop()`. - Constants begin with **`k`**: `kInitialSize`, `kRed `. - Global variables begin with **`g`**: ***`gEnv`***. - Static data members begin with **`fg`**: `fgTokenClient `. - Enumeration types begin with **`E`**: `EColorLevel`. - Locals and parameters begin with a lower case: `nbytes`. - Getters and setters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:30346,Modifiability,variab,variables,30346,"ou can use whatever convention you want but if; you are going to submit some code for inclusion into the ROOT sources,; you will need to use these. These are the coding conventions:. - Classes begin with **`T`**: **`TLine`**, **`TTree`**. - Non-class types end with **`_t`**: `Int_t`. - Data members begin with **`f`**: `fTree`. - Member functions begin with a capital: `Loop()`. - Constants begin with **`k`**: `kInitialSize`, `kRed `. - Global variables begin with **`g`**: ***`gEnv`***. - Static data members begin with **`fg`**: `fgTokenClient `. - Enumeration types begin with **`E`**: `EColorLevel`. - Locals and parameters begin with a lower case: `nbytes`. - Getters and setters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for a",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:30973,Modifiability,variab,variable,30973,"etters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31169,Modifiability,inherit,inherit,31169," for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set o",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32191,Modifiability,variab,variables,32191,"class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFu",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32354,Modifiability,variab,variables,32354,"OT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:35657,Modifiability,variab,variable,35657,"r to the current random number generator.; By default, it points to a **`TRandom3`** object, based on the; ""Mersenne-Twister"" generator. This generator is very fast and has very; good random proprieties (a very long period of 10^600^). Setting the; seed to 0 implies that the seed will be uniquely generated using the; **`TUUID`**. Any other value will be used as a constant. The following; basic random distributions are provided: `Rndm()` or; `Uniform(min,max)`, `Gaus(mean,sigma)`, `Exp(tau)`,; `BreitWigner(mean,sigma)`, `Landau(mean,sigma)`, `Poisson(mean)`,; `Binomial(ntot,prob)`. You can customize your ROOT session by; replacing the random number generator.; You can delete ***`gRandom `*** and recreate it with your own. For; example:. ``` {.cpp}; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; ```. **`TRandom2`** is another generator, which is also very fast and uses; only three words for its state. ### gEnv. **`gEnv`** is the global variable (of type **`TEnv`**) with all the; environment settings for the current session. This variable is set by; reading the contents of a `.rootrc` file (or; `$ROOTSYS/etc/system.rootrc`) at the beginning of the root session.; See Environment Setup below for more information. ## Environment Setup. The behavior of a ROOT session can be tailored with the options in the; .`rootrc` file. At start-up, ROOT looks for a .`rootrc` file in the; following order:. - `./.rootrc` *`//local directory`*. - `$HOME/.rootrc ` *`//user directory`*. - `$ROOTSYS/etc/system.rootrc ` *`//global ROOT directory`*. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. While in; a session, to see current settings, you can do:. ``` {.cpp}; root[] gEnv->Print(); ```. The `rootrc` file typically looks like:. ```; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSY",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:35752,Modifiability,variab,variable,35752,"object, based on the; ""Mersenne-Twister"" generator. This generator is very fast and has very; good random proprieties (a very long period of 10^600^). Setting the; seed to 0 implies that the seed will be uniquely generated using the; **`TUUID`**. Any other value will be used as a constant. The following; basic random distributions are provided: `Rndm()` or; `Uniform(min,max)`, `Gaus(mean,sigma)`, `Exp(tau)`,; `BreitWigner(mean,sigma)`, `Landau(mean,sigma)`, `Poisson(mean)`,; `Binomial(ntot,prob)`. You can customize your ROOT session by; replacing the random number generator.; You can delete ***`gRandom `*** and recreate it with your own. For; example:. ``` {.cpp}; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; ```. **`TRandom2`** is another generator, which is also very fast and uses; only three words for its state. ### gEnv. **`gEnv`** is the global variable (of type **`TEnv`**) with all the; environment settings for the current session. This variable is set by; reading the contents of a `.rootrc` file (or; `$ROOTSYS/etc/system.rootrc`) at the beginning of the root session.; See Environment Setup below for more information. ## Environment Setup. The behavior of a ROOT session can be tailored with the options in the; .`rootrc` file. At start-up, ROOT looks for a .`rootrc` file in the; following order:. - `./.rootrc` *`//local directory`*. - `$HOME/.rootrc ` *`//user directory`*. - `$ROOTSYS/etc/system.rootrc ` *`//global ROOT directory`*. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. While in; a session, to see current settings, you can do:. ``` {.cpp}; root[] gEnv->Print(); ```. The `rootrc` file typically looks like:. ```; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Un",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:37416,Modifiability,variab,variable,37416,"settings, you can do:. ``` {.cpp}; root[] gEnv->Print(); ```. The `rootrc` file typically looks like:. ```; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:37689,Modifiability,variab,variable,37689,")/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:38275,Modifiability,variab,variable,38275," do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:39203,Modifiability,variab,variable,39203,"and line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your code or on the command line you can type the line:. ``` {.cpp}; gObjectTable->Print();; ```. This line will print the list of all active classes and the number of; instances for each class. By comparing consecutive print outs, you can; see objects that you forgot to delete. Note that this method cannot; show leaks coming from the allocation of non-objects or classes; unknown to ROOT. ## Converting from PAW to ROOT. The ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:42524,Modifiability,variab,variable,42524,"; ```. If you do not specify the second parameter, a file name is; automatically generated for you. If `hbookfile` is of the form; `file.hbook`, then the ROOT file will be called `file.root`. This; utility converts HBOOK histograms into ROOT histograms of the class; **`TH1F`**. HBOOK profile histograms are converted into ROOT profile; histograms (see class **`TProfile`**). HBOOK row-wise and column-wise; ntuples are automatically converted to ROOT Trees. See ""Trees"". Some; HBOOK column-wise ntuples may not be fully converted if the columns; are an array of fixed dimension (e.g. `var[6]`) or if they are a; multi-dimensional array. HBOOK integer identifiers are converted into ROOT named objects by; prefixing the integer identifier with the letter ""`h`"" if the; identifier is a positive integer and by `""h_""` if it is a negative; integer identifier. In case of row-wise or column-wise ntuples, each; column is converted to a branch of a tree. Note that `h2root` is able; to convert HBOOK files containing several levels of sub-directories.; Once you have converted your file, you can look at it and draw; histograms or process ntuples using the ROOT command line. An example; of session is shown below:. ``` {.cpp}; // this connects the file hbookconverted.root; root[] TFile f(""hbookconverted.root"");. // display histogram named h10 (was HBBOK id 10); root[] h10.Draw();. // display column ""var"" from ntuple h30; root[] h30.Draw(""var"");; ```. You can also use the ROOT browser (see **`TBrowser`**) to inspect this; file. The chapter on trees explains how to read a tree. ROOT includes a; function **`TTree`**`::MakeClass` to generate automatically the code; for a skeleton analysis function. See ""Example Analysis"". In case one of the ntuple columns has a variable length (e.g.; `px(ntrack)`), `h.Draw(""px"")` will histogram the `px` column for all; tracks in the same histogram. Use the script quoted above to generate; the skeleton function and create/fill the relevant histogram yourself.; ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8636,Performance,load,loads,8636,"popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:10290,Performance,response time,response time,10290,"- *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can be interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits to the window when changing the window; size;; - *off* - the canvas stays fixed when changing the window size. - *Resize Canvas*: resizes and fits the canvas to the window size. - *Move Opaque*: if selected, graphics objects are moved in opaque; mode; otherwise, only the outline of objects is drawn when moving; them. The option opaque produces the best effect but it requires a; reasonably fast workstation or response time. - *Resize Opaque*: if selected, graphics objects are resized in; opaque mode; otherwise, only the outline of objects is drawn when; resizing them. - *Interrupt*: interrupts the current drawing process. - *Refresh*: redraws the canvas contents. - *Pad Auto Exec*: executes the list of **`TExecs`** in the current; pad. - *Statistics*: toggles the display of the histogram statistics box. - *Histogram Title*: toggles the display of the histogram title. - *Fit Parameters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Can",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:16752,Performance,load,loads,16752,"rotate it. ![](pictures/03000025.png) **A Marker**: Click with the left button; where to place the marker. The marker can be modified by using the; method `SetMarkerStyle()` of **`TSystem`**. ![](pictures/03000026.png) **A Graphical Cut**: Click with the left; button on each point of a polygon delimiting the selected area. Close; the cut by double clicking on the last point. A **`TCutG`** object is; created. It can be used as a selection for a **`TTree`**`::Draw`. You; can get a pointer to this object with:. ``` {.cpp}; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); ```. Once you are happy with your picture, you can select the; `Save as canvas.C` item in the canvas File menu. This will; automatically generate a script with the C++ statements corresponding; to the picture. This facility also works if you have other objects not; drawn with the graphics editor (histograms for example). ### The Editor Frame. The ROOT graphics editor loads the corresponding object editor; `objEditor` according to the selected object `obj` in the canvas; respecting the class inheritance. An object in the canvas is selected; after the left mouse click on it. For example, if the selected object; is **`TAxis`**, the **`TAxisEditor`** will shows up in the editor; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT s",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:25534,Performance,load,load,25534,"s up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Command Line. We have briefly touched on how to use the command line. There are; different types of commands. 1. Cling commands start with ""`.`"". ``` {.cpp}; root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]; ```. 2. SHELL commands start with ""`.!`"" for example:. ``` {.cpp}; root[] .! ls; ```. 3. C++ commands follow C++ syntax (almost). ``` {.cpp}; root[] TBrowser *b = new TBrowser(); ```. ### Multi-line Commands. You can use the command line to execute multi-line commands. To begin; a multi-line command you must type a single left curly bracket `{`,; and to end it you must type a single right curly bracket `}`.; For example:. ``` {.cpp}; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; ```. It is more convenient to edit a script than the command line, and if; your multi line commands are getting unmanageable, you may want to; start with a script instead. ### Cling Extensions. We should say that some things are not sta",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:25574,Performance,load,load,25574,"mand in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Command Line. We have briefly touched on how to use the command line. There are; different types of commands. 1. Cling commands start with ""`.`"". ``` {.cpp}; root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]; ```. 2. SHELL commands start with ""`.!`"" for example:. ``` {.cpp}; root[] .! ls; ```. 3. C++ commands follow C++ syntax (almost). ``` {.cpp}; root[] TBrowser *b = new TBrowser(); ```. ### Multi-line Commands. You can use the command line to execute multi-line commands. To begin; a multi-line command you must type a single left curly bracket `{`,; and to end it you must type a single right curly bracket `}`.; For example:. ``` {.cpp}; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; ```. It is more convenient to edit a script than the command line, and if; your multi line commands are getting unmanageable, you may want to; start with a script instead. ### Cling Extensions. We should say that some things are not standard C++. The Cling; interpreter has severa",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:36556,Performance,load,loader,36556,"h is also very fast and uses; only three words for its state. ### gEnv. **`gEnv`** is the global variable (of type **`TEnv`**) with all the; environment settings for the current session. This variable is set by; reading the contents of a `.rootrc` file (or; `$ROOTSYS/etc/system.rootrc`) at the beginning of the root session.; See Environment Setup below for more information. ## Environment Setup. The behavior of a ROOT session can be tailored with the options in the; .`rootrc` file. At start-up, ROOT looks for a .`rootrc` file in the; following order:. - `./.rootrc` *`//local directory`*. - `$HOME/.rootrc ` *`//user directory`*. - `$ROOTSYS/etc/system.rootrc ` *`//global ROOT directory`*. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. While in; a session, to see current settings, you can do:. ``` {.cpp}; root[] gEnv->Print(); ```. The `rootrc` file typically looks like:. ```; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:37840,Performance,load,loaded,37840,"C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:37913,Performance,load,loaded,37913,"vas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:39494,Safety,detect,detect,39494,"e recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your code or on the command line you can type the line:. ``` {.cpp}; gObjectTable->Print();; ```. This line will print the list of all active classes and the number of; instances for each class. By comparing consecutive print outs, you can; see objects that you forgot to delete. Note that this method cannot; show leaks coming from the allocation of non-objects or classes; unknown to ROOT. ## Converting from PAW to ROOT. The web page at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE> gives the; ""translation"" table of some commonly used PAW commands into ROOT. If; you move the mouse cursor over the picture at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#SET>, you will get; the corresponding ROOT commands as tooltips. ### Converting HB",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4794,Security,access,access,4794,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8861,Security,access,access,8861," formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can be interactively rotated, zoomed in wire-frame, solid,; hidden line or stereo mode. ![](pictures/0300000C.png). #### Options Menu. - *Auto Resize Canvas*: turns auto-resize of the canvas *on/off*:. - *on* - the canvas fits t",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:21039,Security,access,access,21039,"ral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); ```. By default the method `TF1::Paint()`, that draws the function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will generate a script; showing the options set in the current canvas. Notice that you can; also",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32460,Security,access,accessible,32460,"and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or tr",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32605,Security,access,access,32605,"rotocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32837,Security,access,accessed,32837,"nspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the full set; of methods supported for a collection. For example, to find a canvas; called `c1 `you can do`:`. ``` {.cpp}; root[] gROOT->GetListOfCanvases()->FindObject(""c1""); ```. This returns a pointer to a **`TObject`**, and before you can use it",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:34233,Security,access,access,34233,"tListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the full set; of methods supported for a collection. For example, to find a canvas; called `c1 `you can do`:`. ``` {.cpp}; root[] gROOT->GetListOfCanvases()->FindObject(""c1""); ```. This returns a pointer to a **`TObject`**, and before you can use it; as a canvas you need to cast it to a **`TCanvas*`.**. ### gFile. ***`gFile`*** is the pointer to the current opened file in the ROOT; session. ### gDirectory. ***`gDirectory`*** is a pointer to the current directory. The concept; and role of a directory is explained in the chapter ""Input/Output"". ### gPad. A graphic object is always drawn on the active pad. It is convenient; to access the active pad, no matter what it is. For that, we have; ***`gPad`*** that is always pointing to the active pad. For example,; if you want to change the fill color of the active pad to blue, but; you do not know its name, you can use ***`gPad`***. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, if you have an open canvas, click in the; ""View"" menu, selecting the ""Colors"" entry. ### gRandom. ***`gRandom`*** is a pointer to the current random number generator.; By default, it points to a **`TRandom3`** object, based on the; ""Mersenne-Twister"" generator. This generator is very fast and has very; good random proprieties (a very long period of 10^600^). Setting the; seed to 0 implies that the seed will be uniquely generated using the; **`TUUID`**. Any other value will be used as a constant. The following; basic random distributions are provided: `Rndm()` or; `Uniform(min,max)`, `Gaus(mean,sigma)`, `Exp(tau)`,; `BreitWigner(mean,sigma)`, `Landau(mean,sigma)`, `Poisson(",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:38476,Security,access,access,38476,".rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3048,Testability,log,logon,3048,"orrectly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a scr",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3058,Testability,log,logoff,3058,"orrectly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a scr",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3585,Testability,log,logon,3585,"-------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3627,Testability,log,logoff,3627,"-------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4108,Testability,log,log,4108,"files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4215,Testability,log,log,4215,"is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4318,Testability,log,log,4318,"e; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4467,Testability,log,log,4467,"t want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4735,Testability,log,log,4735,"pt without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is th",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:38780,Testability,log,logging,38780,"ff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your c",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:119,Usability,learn,learn,119,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:994,Usability,UX,UX,994,"y showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3780,Usability,simpl,simply,3780,"ssible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all a",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7069,Usability,clear,clear,7069,"class is the parent of the **`TCanvas`**; class. In ROOT, most objects derive from a base class **`TObject`**.; This class has a virtual method `Draw()` such as all objects are; supposed to be able to be ""drawn"". If several canvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: ",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:20972,Usability,simpl,simple,20972,"4020e-02; root[] f1.Derivative(3); (Double_t)(-3.45675056671992330e-01); root[] f1.Integral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); ```. By default the method `TF1::Paint()`, that draws the function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will ge",MatchSource.DOCS,documentation/users-guide/GettingStarted.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:50606,Availability,avail,available,50606," wants to draw two axis for the same plot, one on the left and one on; the right. For historical reasons, there are two classes representing axis.; **`TAxis`** \* `axis` is the axis object, which will be returned when; calling the `TH1::GetAxis()` method. ``` {.cpp}; TAxis *axis = histo->GetXaxis(); ```. Of course, you may do the same for `Y` and `Z`-axis. The graphical; representation of an axis is done with the **`TGaxis`** class. The; histogram classes and **`TGraph`** generate instances of this class.; This is internal and the user should not have to see it. ### Axis Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""Whatever title you want""); ```. ### Axis Options and Characteristics. The axis options are most simply set with the styles. The available; style options controlling specific axis options are the following:. ``` {.cpp}; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 100*N2 + 10000*N3`. - `N1 =` number of first divisions. - `N2 =` number",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:51244,Availability,avail,available,51244,"s Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""Whatever title you want""); ```. ### Axis Options and Characteristics. The axis options are most simply set with the styles. The available; style options controlling specific axis options are the following:. ``` {.cpp}; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 100*N2 + 10000*N3`. - `N1 =` number of first divisions. - `N2 =` number of secondary divisions. - `N3 =` number of tertiary divisions. - `optim = kTRUE ` (default), the divisions' number will be optimized; around the specified value. - `optim = kFALSE, ` or n \< 0, the axis will be forced to use exactly; n divisions. For example:. `ndiv = 0`: no tick marks. `ndiv = 2`: 2 divisions, one tick mark in the middle of the axis. `ndiv = 510`: 10 primary divisions, 5 secondary divisions. `ndiv = -10`: exactly 10 primary divisions. ### Zooming the Axis. You can use `TAxis::SetRange` or `TAxis::SetRangeUser` to zoom the axis. ``` {.cpp}; TAxis::SetR",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:56177,Availability,avail,available,56177," is visible from **`TAxis`** context menu.; It centers the bin labels and it makes sense only when the number of; bins is equal to the number of tick marks. The class responsible for; drawing the axis **`TGaxis`** inherits this property. #### Orientation. Labels are normally drawn parallel to the axis. However, if; `xmin = xmax`, then they are drawn orthogonal, and if `ymin=ymax` they; are drawn parallel. #### Labels for Exponents. By default, an exponent of the form 10\^N is used when the label values; are either all very small or very large. One can disable the exponent by; calling:. ``` {.cpp}; TAxis::SetNoExponent(kTRUE); ```. Note that this option is implicitly selected if the number of digits to; draw a label is less than the `fgMaxDigits` global member. If the; property `SetNoExponent` was set in **`TAxis`** (via; `TAxis::SetNoExponent)`, the **`TGaxis`** will inherit this property.; **`TGaxis`** is the class responsible for drawing the axis. The method; `SetNoExponent` is also available from the axis context menu. ![Y-axis with and without exponent labels](pictures/030000C7.png). #### Number of Digits in Labels. `TGaxis::fgMaxDigits` is the maximum number of digits permitted for the; axis labels above which the notation with 10\^N is used. It must be; greater than 0. By default `fgMaxDigits` is 5 and to change it use the; `TGaxis::SetMaxDigits` method. For example to set `fgMaxDigits` to; accept 6 digits and accept numbers like 900000 on an axis call:. ``` {.cpp}; TGaxis::SetMaxDigits(6); ```. #### Tick Mark Positions. Labels are centered on tick marks. However, if `xmin = xmax`, then they; are right adjusted. - `chopt = 'R'`: labels are right adjusted on tick mark (default is; centered). - `chopt = 'L'`: labels are left adjusted on tick mark. - `chopt = 'C'`: labels are centered on tick mark. - `chopt = 'M'`: In the Middle of the divisions. #### Label Formatting. Blank characters are stripped, and then the label is correctly aligned.; The dot, if last chara",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:70521,Availability,avail,available,70521,"he alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horizontal. ``` {.cpp}; root[] la->SetTextAngle(angle); ```. #### Setting Text Color. Use `TAttText::SetTextColor` to set the text color. The `color` is the; color index. The colors are described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With p",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:71791,Availability,avail,available,71791,"0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `font = 62` is the font with ID `6` and precision `2`. ![Font's examples](pictures/030000CF.png). The available fonts are:. +-----------+--------------------------+-----------------------+---------+------------+; | Font ID | X11 | True Type name | Is | ""boldness"" |; | | | | italic | |; +-----------+--------------------------+-----------------------+---------+------------+; | 1 | times-medium-i-normal | ""Times New Roman"" | Yes | 4 |; +-----------+--------------------------+-----------------------+---------+------------+; | 2 | times-bold-r-normal | ""Times New Roman"" | No | 7 |; +-----------+--------------------------+-----------------------+---------+------------+; | 3 | times-bold-i-normal | ""Times New Roman"" | Yes | 7 |; +-----------+--------------------------+-----------------------+---------+------------+; | 4 | helvetica-medium-r-norma | ""Arial"" | No | 4 |; | | l | | | |; +-----------+--------------------------+-----------------------+---------+------------+; | 5 | helvetica-medium-o-norma | ""Arial"" | Yes | 4 |; | | l | | | |; +-----------+--------------------------+-----------------------",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:79506,Availability,avail,available,79506,". - `i(1-9)` specifies the space between each hatch `(1=minimum space`,; `9=maximum)`. The final spacing is set by `SetHatchesSpacing()`; method and it is`*GetHatchesSpacing()`. - `j(0-9)` specifies the angle between 0 and 90 degres as follows:; `0=0`, `1=10`, `2=20`, `3=30`, `4=45`, `5=not drawn`, `6=60`,; `7=70`, `8=80` and `9=90`. - `k(0-9)` specifies the angle between 0 and 90 degres as follows:; `0=180`, `1=170`, `2=160`, `3=150`, `4=135`, `5=not drawn`, `6=120`,; `7=110`, `8=100` and `9=90`. ![The various patterns](pictures/030000D2.png). ### Color and Color Palettes. At initialization time, a table of basic colors is generated when the; first Canvas constructor is called. This table is a linked list, which; can be accessed from the ***`gROOT`*** object (see; `TROOT::GetListOfColors()`). Each color has an index and when a basic; color is defined, two ""companion"" colors are defined: the dark version and the bright version.; Two static functions are available that return the bright or dark color number corresponding; to a given color index. If these variants don't already exist, they are created as needed:; ```; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; ```. The dark and bright colors are used to give 3-D effects when drawing; various boxes (see **`TWbox`**, **`TPave`**, **`TPaveText`**,; **`TPaveLabel`**, etc). If you have a black and white copy of the; manual, here are the basic colors and their indices. ![The basic ROOT colors](pictures/030000D3.png). ![](pictures/image212.jpg). The list of currently supported basic colors (here dark and bright; colors are not shown) are shown. The color numbers specified in the; basic palette, and the picture above, can be viewed by selecting the; menu entry Colors in the View canvas menu. The user may define other; colors. To do this, one has to build a new **`TColor`**:. ``` {.cpp}; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); ```. One has to",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:83969,Availability,avail,available,83969,"pp}; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:83984,Availability,down,download,83984,"pp}; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84315,Availability,avail,available,84315,"etRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resi",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:109475,Availability,down,down,109475,"real world' views. The degree of; foreshortening is affected by the current camera field of view; (focal length of its ‘lens') - see ""Adjusting Cameras"". - Orthographic: Distance from camera does not affect object size.; These projections are useful for measurement or checking alignments,; as the sizes and angles between objects are preserved. You can select the active camera from the viewer's Camera menu on the; top menu bar. There are three perspective camera choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen; floor plane, defined by a pair of world axes, appearing level at all; times - i.e. there is no banking of the ‘horizon' that you experience; when a plane rolls. There are also three orthographic camera choices:. - Orthographic (XOY). - Orthographic (XOZ). - Orthographic (ZOY). Orthographic projections are generally constrained to look down one of; the global axes of the world, with the other two axes lying; horizontal/vertical on the viewer window. Therefore, XOY has the X-axis; horizontal, the Y-axis vertical. You can always confirm the orientation; and constraints of the camera in the world by enabling axis drawing in; the ""Guides"" tab - see sections ""Guides"" and ""Clipping"" below. For; orthographic camera a ruler-depicting current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:109902,Availability,avail,available,109902,"ive camera from the viewer's Camera menu on the; top menu bar. There are three perspective camera choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen; floor plane, defined by a pair of world axes, appearing level at all; times - i.e. there is no banking of the ‘horizon' that you experience; when a plane rolls. There are also three orthographic camera choices:. - Orthographic (XOY). - Orthographic (XOZ). - Orthographic (ZOY). Orthographic projections are generally constrained to look down one of; the global axes of the world, with the other two axes lying; horizontal/vertical on the viewer window. Therefore, XOY has the X-axis; horizontal, the Y-axis vertical. You can always confirm the orientation; and constraints of the camera in the world by enabling axis drawing in; the ""Guides"" tab - see sections ""Guides"" and ""Clipping"" below. For; orthographic camera a ruler-depicting current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all cameras you can reset the original default view,; framing the entire scene, by double clicking any mouse button. ![GL Viewer camera interactions](pictures/020000DB.jpg). For the Zoom interaction you can use the following modifiers; combinations to adjust the sensitivity:. - Shiftx 10. - Ctrlx 0.1. - Shift + Ctrlx 0.01. The modifiers must be applied after the zoom a",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:110913,Availability,down,down,110913,"g current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all cameras you can reset the original default view,; framing the entire scene, by double clicking any mouse button. ![GL Viewer camera interactions](pictures/020000DB.jpg). For the Zoom interaction you can use the following modifiers; combinations to adjust the sensitivity:. - Shiftx 10. - Ctrlx 0.1. - Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right; mouse button is down). Note for orthographic cameras:. - There is no field of view of view/focal length - dollying and; zooming producing an identical scaling action. - There is a fixed eye direction - so the ‘Orbit' action is disabled. Note for perspective cameras:. - Dollying (moving the camera backwards/forwards) and zooming are; often confused, and may appear very similar. - When you dolly the camera the lens focal length does not change,; hence the distortions associated with the projections are; unaffected. However the movement can result in objects coming; ‘through the front' of the camera and disappearing. - When you zoom, the camera does not move - hence clipping of near; objects is unaffected. However with extremely small zooms (FOV; large/focal length short) noticeable distortions, causing straight; lines to become curved, can be seen with objects near the camera -; the ‘fisheye' lens effect. - Generally dollying is more ‘natural', but you may need t",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:120756,Availability,avail,available,120756,"OpenGL materials, colors and lighting is beyond; the scope of this document. You should refer to the OpenGL programming; manual (Red Book) for a full discussion. In most cases adjustment of the; Diffuse color material + Opacity/Shine properties is sufficient to; achieve desired results. A shape has four-color materials (components):. - Diffuse. - Ambient. - Specular. - Emissive. For each of these you can select the component via the radio buttons.; Each component can have the red, green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121644,Availability,down,down,121644,"he shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:.",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121987,Availability,down,down,121987,"ed ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client usi",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:3373,Deployability,update,updated,3373,"e left; mouse button. The cursor changes its shape to indicate what may be done:. Point the object or one part of it: ![](pictures/02000095.jpg); ![](pictures/02000096.jpg). Rotate: ![](pictures/02000097.jpg). Resize (exists also for the other directions):; ![](pictures/02000098.jpg) ![](pictures/02000099.jpg). Enlarge (used for text): ![](pictures/0200009A.jpg). Move: ![](pictures/0200009B.jpg). Here are some examples of:. Moving: ![](pictures/0200009C.jpg) Resizing: ![](pictures/0200009D.jpg). Rotating: ![](pictures/0200009E.jpg) ![](pictures/0300009F.png). #### With C++ Statements (Programmatically). How would one move an object in a script? Since there is a tight; correspondence between what is seen on the screen and the object in; memory, changing the object changes it on the screen. For example, try; to do:. ``` {.cpp}; root[] a.SetX1(0.9); ```. This should change one of the coordinates of our line, but nothing; happens on the screen. Why is that? In short, the canvas is not updated; with each change for performance reasons. See ""Updating the Pad"". ### Selecting Objects. #### The Middle Mouse Button. Objects in a canvas, as well as in a pad, are stacked on top of each; other in the order they were drawn. Some objects may become ""active""; objects, which mean they are reordered to be on top of the others. To; interactively make an object ""active"", you can use the middle mouse; button. In case of canvases or pads, the border becomes highlighted when; it is active. #### With C++ Statements (Programmatically). Frequently we want to draw in different canvases or pads. By default,; the objects are drawn in the active canvas. To activate a canvas you can; use the `TPad::cd()` method. ``` {.cpp}; root[] c1->cd(); ```. ### Context Menus: the Right Mouse Button. The context menus are a way to interactively call certain methods of an; object. When designing a class, the programmer can add methods to the; context menu of the object by making minor changes to the header fil",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7571,Deployability,toggle,toggle,7571,"ow, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU*",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:9552,Deployability,release,released,9552,"option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indicate; to the system which argument corresponds to which data member of the; class. ### Executing Events when a Cursor Passes on Top of an Object. This paragraph is for class designers. When a class is designed, it is; often desirable to include drawing methods for it. We will have a more; extensive discussion about this, but drawing an object in a canvas or a; pad consists in ""attaching"" the object to that pad. When one uses; `object.Draw()`, the object is NOT painted at this moment. It is only; attached to the active pad or canvas. Another method should be provided for the object to be painted, the; `Paint()` method. This is all explained in the next paragraph. As well; as `Draw()` and `Paint()`, other methods may be provided by the designer; of the class. When the mouse is moved or a button pressed/released, the; **`TCanvas`** function named `HandleInput()` scans the list of objects; in all it's pads and for each object calls some standard methods to make; the object react to the event (mouse movement, click or whatever). The second one is `DistancetoPrimitive(px,py)`. This function computes a; ""distance"" to an object from the mouse position at the pixel position; (`px`, `py`, see definition at the end of this paragraph) and returns; this distance in pixel units. The selected object will be the one with; the shortest computed distance. To see how this works, select the; ""`Event Status`"" item in the canvas ""`Options`"" menu. ROOT will display; one status line showing the picked object. If the picked object is, for; example, a histogram, the status line indicates the name of the; histogram, the position `x,y` in histogram coordinates, the channel; number and the channel content. It is nice for the canvas to know what the closest object from the mouse; is, but it's even nicer to be able to make this object react. The third; standard method to be provided is `ExecuteEvent()",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:18260,Deployability,update,updated,18260,"ass. To know; the name of an object, just click with the right button on it. The name; appears at the top of the context menu. In case of multiple unnamed; objects, a call to `GetPrimitive(""className"")` returns the instance of; the class that was first created. To retrieve a later instance you can; use `GetListOfPrimitives()`, which returns a list of all the objects on; the pad. From the list you can select the object you need. #### Hiding an Object. Hiding an object in a pad can be made by removing it from the list of; objects owned by that pad. This list is accessible by the; `GetListOfPrimitives()` method of **`TPad`**. This method returns a; pointer to a **`TList`**. Suppose we get the pointer to the object, we; want to hide, call it `obj` (see paragraph above). We get the pointer to; the list:. ``` {.cpp}; root[] li = gPad->GetListOfPrimitives(); ```. Then remove the object from this list:. ``` {.cpp}; root[] li->Remove(obj); ```. The object will disappear from the pad as soon as the pad is updated; (try to resize it for example). If one wants to make the object; reappear:. ``` {.cpp}; root[] obj->Draw(); ```. Caution, this will not work with composed objects, for example many; histograms drawn on the same plot (with the option ""`same`""). There are; other ways! Try to use the method described here for simple objects. ### The Coordinate Systems of a Pad. There are coordinate systems in a **`TPad`**: user coordinates,; normalized coordinates (NDC), and pixel coordinates. ![Pad coordinate systems](pictures/080000A3.png). #### The User Coordinate System. The most common is the user coordinate system. Most methods of; **`TPad`** use the user coordinates, and all graphic primitives have; their parameters defined in terms of user coordinates. By default, when; an empty pad is drawn, the user coordinates are set to a range from 0 to; 1 starting at the lower left corner. At this point they are equivalent; of the NDC coordinates (see below). If you draw a high level grap",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:26222,Deployability,update,updated,26222,"](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for example the; name and title of an object. - You can also set the ""bit-modified"" explicitly with the `Modified`; method:. ``` {.cpp}; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. I",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:26803,Deployability,update,update,26803,"d* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for example the; name and title of an object. - You can also set the ""bit-modified"" explicitly with the `Modified`; method:. ``` {.cpp}; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modifie",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:27697,Deployability,update,update,27697,"; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modified()`, and follow it with a; `canvas->Update()`. If you use `canvas->Modified()`, followed by a call; to `canvas->Update()`, the sub pad has not been declared modified and it; will not be updated. Also note that a call to `pad->Update()` where pad; is a sub pad of canvas, calls `canvas->Update()` and recursively updates; all the pads on the canvas. ### Making a Pad Transparent. As we will see in the paragraph ""Fill Attributes"", a fill style (type of; hatching) may be set for a pad. ``` {.cpp}; root[] pad1->SetFillStyle(istyle); ```. This is done with the `SetFillStyle` method where `istyle` is a style; number, defined in ""Fill Attributes"". A special set of styles allows; handling of various levels of transparency. These are styles number 4000; to 4100, 4000 being fully transparent and 4100 fully opaque. So, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire c",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:27981,Deployability,update,updated,27981,"sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modified()`, and follow it with a; `canvas->Update()`. If you use `canvas->Modified()`, followed by a call; to `canvas->Update()`, the sub pad has not been declared modified and it; will not be updated. Also note that a call to `pad->Update()` where pad; is a sub pad of canvas, calls `canvas->Update()` and recursively updates; all the pads on the canvas. ### Making a Pad Transparent. As we will see in the paragraph ""Fill Attributes"", a fill style (type of; hatching) may be set for a pad. ``` {.cpp}; root[] pad1->SetFillStyle(istyle); ```. This is done with the `SetFillStyle` method where `istyle` is a style; number, defined in ""Fill Attributes"". A special set of styles allows; handling of various levels of transparency. These are styles number 4000; to 4100, 4000 being fully transparent and 4100 fully opaque. So, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *n",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:28107,Deployability,update,updates,28107,"ess. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modified()`, and follow it with a; `canvas->Update()`. If you use `canvas->Modified()`, followed by a call; to `canvas->Update()`, the sub pad has not been declared modified and it; will not be updated. Also note that a call to `pad->Update()` where pad; is a sub pad of canvas, calls `canvas->Update()` and recursively updates; all the pads on the canvas. ### Making a Pad Transparent. As we will see in the paragraph ""Fill Attributes"", a fill style (type of; hatching) may be set for a pad. ``` {.cpp}; root[] pad1->SetFillStyle(istyle); ```. This is done with the `SetFillStyle` method where `istyle` is a style; number, defined in ""Fill Attributes"". A special set of styles allows; handling of various levels of transparency. These are styles number 4000; to 4100, 4000 being fully transparent and 4100 fully opaque. So, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *newpad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:52968,Deployability,release,release,52968,"ck marks. `ndiv = 2`: 2 divisions, one tick mark in the middle of the axis. `ndiv = 510`: 10 primary divisions, 5 secondary divisions. `ndiv = -10`: exactly 10 primary divisions. ### Zooming the Axis. You can use `TAxis::SetRange` or `TAxis::SetRangeUser` to zoom the axis. ``` {.cpp}; TAxis::SetRange(Int_t binfirst,Int_t binlast); ```. The `SetRange` method parameters are bin numbers. They are not axis. For; example if a histogram plots the values from 0 to 500 and has 100 bins,; `SetRange(0,10)` will cover the values 0 to 50. The parameters for; `SetRangeUser` are user coordinates. If the start or end is in the; middle of a bin the resulting range is approximation. It finds the low; edge bin for the start and the high edge bin for the high. ``` {.cpp}; TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast); ```. Both methods, `SetRange` and `SetRangeUser`, are in the context menu of; any axis and can be used interactively. In addition, you can zoom an; axis interactively: click on the axis on the start, drag the cursor to; the end, and release the mouse button. ### Drawing Axis Independently of Graphs or Histograms. An axis may be drawn independently of a histogram or a graph. This may; be useful to draw for example a supplementary axis for a graph. In this; case, one has to use the **`TGaxis`** class, the graphical; representation of an axis. One may use the standard constructor for this; kind of objects:. ``` {.cpp}; TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; Double_t wmin, Double_t wmax, Int_t ndiv = 510,; Option_t* chopt,Double_t gridlength = 0); ```. The arguments `xmin, ymin` are the coordinates of the axis' start in the; user coordinates system, `and xmax, ymax` are the end coordinates. The; arguments `wmin` and `wmax` are the minimum (at the start) and maximum; (at the end) values to be represented on the axis; `ndiv` is the number; of divisions. The options, given by the ""`chopt`"" string are the; following:. - `chopt = 'G'`: logarithmic sc",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31112,Energy Efficiency,monitor,monitor,31112,"(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By defa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:82739,Energy Efficiency,adapt,adapt,82739,"all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette are good for; coloring pads, labels, and other graphic objects. If `ncolors > 0` and; `colors = 0`, the default palette is used with a maximum of `ncolors`.; If `ncolors == 1 && colors == 0`, then a pretty palette with a spectrum; `Violet->Red` is created. It is recommended to use this pretty palette; when drawing lego(s), surfaces or contours. For example, to set the; current palette to the ""`pretty`"" one, do:. ``` {.cpp}; root[] gStyle->SetPalette(1); ```. A more complete example is shown below. It illustrates the definition of; a custom palette. You can adapt it to suit your needs. In case you use; it for contour coloring, with the current color/contour algorithm,; always define two more colors than the number of contours. ``` {.cpp}; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""f",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:116490,Energy Efficiency,green,green,116490,"described with combination of planes, can; be rendered in this fashion - e.g. a clipping tube is not possible. - Each additional clipping plane requires an additional render pass -; so the more active planes the more time the render will take. Set the current clip object with **`TGLClipSet::SetClipType`**. ``` {.cpp}; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; ```. Configure the clip object with **`TGLClipSet::SetClipState`**. ``` {.cpp}; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; ```. As with cameras, any clip can be configured at any time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:117181,Energy Efficiency,green,green,117181,"‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Init",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:118832,Energy Efficiency,green,green,118832,"axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Initial position is at the center of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the color and geometry; properties of the shape. Note: At present modifications to the shapes are local to the viewer -; they are not propagated back to external objects/client that published; to the viewer. The changes are preserved only until the viewer is; closed. In some cases, this will never be feasible as there is not a; one-to-one correspondence between a shape in the viewer and a single; external object in which the modification could be stored. #### Colors / Style. Viewer Controls Pane ‘Style' tab. A full description of OpenGL materials, colors and lighting is beyond; the scope of this document. You s",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:120239,Energy Efficiency,green,green,120239," the shape. Note: At present modifications to the shapes are local to the viewer -; they are not propagated back to external objects/client that published; to the viewer. The changes are preserved only until the viewer is; closed. In some cases, this will never be feasible as there is not a; one-to-one correspondence between a shape in the viewer and a single; external object in which the modification could be stored. #### Colors / Style. Viewer Controls Pane ‘Style' tab. A full description of OpenGL materials, colors and lighting is beyond; the scope of this document. You should refer to the OpenGL programming; manual (Red Book) for a full discussion. In most cases adjustment of the; Diffuse color material + Opacity/Shine properties is sufficient to; achieve desired results. A shape has four-color materials (components):. - Diffuse. - Ambient. - Specular. - Emissive. For each of these you can select the component via the radio buttons.; Each component can have the red, green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer,",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:123904,Energy Efficiency,efficient,efficiently,123904,"ects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; viewers free of viewer specific drawing code. They allow our simple x3d; viewer, and considerably more sophisticated OpenGL one to both work with; both geometry libraries (`g3d` and `geom`) efficiently. In addition to external viewers, created in separate windows, this; architecture is also used by internal **`TPad`** drawing when it; requires 3D projections. Publishing to a viewer consists of the; following steps:. 1- Create / obtain viewer handle. 2- Begin scene on viewer. 3- Fill mandatory parts of TBuffer3D describing object. 4- Add to viewer. 5- Fill optional parts of TBuffer3D as requested by viewer. [ .... repeat 3/4/5 as required for other/child objects]. 6- End scene on viewer. You should attach the top-level node of your external geometry (or the; manager) to a **`TPad`** object using **`TObject::Draw()`, and perform; the publishing to the viewer in your object's `TObject::Paint()`; overloaded method. See ""Scene Rebuilds"", and example scripts, for more; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in t",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7458,Integrability,depend,depending,7458," you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one ar",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:14427,Integrability,rout,routine,14427,"vases. A pad (class; **`TPad`**) is a graphical container in the sense it contains other; graphical objects like histograms and arrows. It may contain other pads; (sub-pads) as well. A Pad is a linked list of primitives of any type; (graphs, histograms, shapes, tracks, etc.). It is a kind of display list. ![The pad display list](pictures/pad_01.png). Drawing an object is nothing more than adding its pointer to this list.; Look for example at the code of `TH1::Draw()`. It is merely ten lines of; code. The last statement is `AppendPad()`. This statement calls method; of **`TObject`** that just adds the pointer of the object, here a; histogram, to the list of objects attached to the current pad. Since; this is a **`TObject`**'s method, every object may be ""drawn"", which; means attached to a pad. When is the painting done then ? The answer is: when needed. Every object; that derives from **`TObject`** has a `Paint()` method. It may be empty,; but for graphical objects, this routine contains all the instructions to; paint effectively it in the active pad. Since a Pad has the list of; objects it owns, it will call successively the `Paint()` method of each; object, thus re-painting the whole pad on the screen. If the object is a; sub-pad, its `Paint()` method will call the `Paint()` method of the; objects attached, recursively calling `Paint()` for all the objects. ![Pad painting](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:37022,Integrability,interface,interface,37022," A marker is a point with a fancy shape! The possible markers are shown; in the next figure. ![Markers](pictures/030000B0.png). The marker constructor is:. ``` {.cpp}; TMarker(Double_t x,Double_t y,Int_t marker); ```. The parameters `x` and `y` are the marker coordinates and `marker` is; the marker type, shown in the previous figure. Suppose the pointer `ma`; is a valid marker. The marker size is set via `ma->SetMarkerSize(size)`,; where `size` is the desired size. Note, that the marker types 1, 6 and 7; (the dots) cannot be scaled. They are always drawn with the same number; of pixels. `SetMarkerSize` does not apply on them. To have a ""scalable; dot"" a circle shape should be used instead, for example, the marker type; 20. The default marker type is 1, if `SetMarkerStyle` is not specified.; It is the most common one to draw scatter plots. ![Different marker sizes](pictures/030000B1.png). ![Different marker sizes](pictures/030000B2.png). The user interface for changing the marker color, style and size looks; like shown in this picture. It takes place in the editor frame anytime; the selected object inherits the class **`TAttMarker`**. Non-symmetric symbols should be used carefully in plotting. The next two; graphs show how the misleading a careless use of symbols can be. The two; plots represent the same data sets but because of a bad symbol choice,; the two on the top appear further apart from the next example. ![The use of non-symmetric markers](pictures/030000B3.png). A **`TPolyMaker`** is defined by an array on N points in a 2D space. At; each point `x[i]`, `y[i]` a marker is drawn. The list of marker types is; shown in the previous paragraph. The marker attributes are managed by; the class **`TAttMarker`** and are described in ""Graphical Objects; Attributes"". The **`TPolyMarker`** constructor is:. ``` {.cpp}; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); ```. Where `x` and `y` are arrays of coordinates for the `n` points that form; the poly-mark",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:71087,Integrability,depend,depending,71087,"`TAttText::SetTextColor` to set the text color. The `color` is the; color index. The colors are described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `font = 62` is the font with ID `6` and precision `2`. ![Font's examples](pictures/030000CF.png). The available fonts are:. +-----------+--------------------------+-----------------------+---------+------------+; | Font ID | X11 | True Type name | Is | ""boldness"" |; | | | | italic | |; +-----------+--------------------------+-----------------------+---------+------------+; | 1 | times-medium-i-n",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:74808,Integrability,message,message,74808,"-+---------+------------+; | 13 | times-medium-r-normal | ""Times New Roman"" | No | 4 |; +-----------+--------------------------+-----------------------+---------+------------+; | 14 | | ""Wingdings"" | No | 4 |; +-----------+--------------------------+-----------------------+---------+------------+. This script makes the image of the different fonts:. ``` {.cpp}; {; textc = new TCanvas(""textc"",""Example of text"",1);; for (int i=1;i<15;i++) {; cid = new char[8];; sprintf(cid,""ID %d :"",i);; cid[7] = 0;; lid = new TLatex(0.1,1-(double)i/15,cid);; lid->SetTextFont(62);; lid->Draw();; l = new TLatex(.2,1-(double)i/15,; ""The quick brown fox is not here anymore""); l->SetTextFont(i*10+2);; l->Draw();; }; }; ```. #### How to use True Type Fonts. You can activate the True Type Fonts by adding the following line in; your `.rootrc` file. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; ```. You can check that you indeed use the `TTF` in your Root session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set b",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:75400,Integrability,interface,interface,75400,"rown fox is not here anymore""); l->SetTextFont(i*10+2);; l->Draw();; }; }; ```. #### How to use True Type Fonts. You can activate the True Type Fonts by adding the following line in; your `.rootrc` file. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; ```. You can check that you indeed use the `TTF` in your Root session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set by a method call. What; is said here applies to all objects deriving from **`TAttLine`**, and; there are many (histograms, plots). We will take an example that may be; transposed to other types. Suppose ""`li`"" is a **`TLine`** object. The; line color is set with:. ``` {.cpp}; root[] li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types.",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:77055,Integrability,interface,interface,77055,"li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line width is; set with:. ``` {.cpp}; root[] li->SetLineWidth(width); ```. The `width` is the width expressed in pixel units. ![](pictures/030000D1.png) The user interface for changing the line; color, line width and style looks like shown in this picture. It takes; place in the editor frame anytime the selected object inherits the class; **`TAttLine`**. ### Fill Attributes. Almost all graphics classes have a fill area somewhere. These classes; have to deal with fill attributes. This is done by using secondary; inheritance of the class **`TAttFill`**. Fill color may be set by a; method call. What is said here applies to all objects deriving from; **`TAttFill`**, and there are many (histograms, plots). We will take an; example that may be transposed to other types. Suppose ""`h`"" is a; **`TH1F`** (1 dim histogram) object. The histogram fill color is set; with:. ``` {.cpp}; root[] h->SetFillColor(color); ```. The color is a color number. The colors are described in ""Color and; color palettes"". Fill style may be set by a method call. What is said here applies to all; objects deriving from `TAttFill`, and there are many (histograms,; plots). We will take an example that may be transposed ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:81141,Integrability,interface,interface,81141,"; colors are not shown) are shown. The color numbers specified in the; basic palette, and the picture above, can be viewed by selecting the; menu entry Colors in the View canvas menu. The user may define other; colors. To do this, one has to build a new **`TColor`**:. ``` {.cpp}; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); ```. One has to give the color number and the three Red, Green, Blue values,; each being defined from 0 (min) to 1(max). An optional name may be; given. When built, this color is automatically added to the existing; list of colors. If the color number already exists, one has to extract; it from the list and redefine the RGB values. This may be done for; example with:. ``` {.cpp}; root[] color=(TColor*)(gROOT->GetListOfColors()->At(index_color)); root[] color->SetRGB(r,g,b); ```. Where `r`, `g` and `b` go from 0 to 1 and `index_color` is the color; number you wish to change. ![](pictures/030000D4.png) The user interface for changing the fill; color and style looks like shown in this picture. It takes place in the; editor frame anytime the selected object inherits the class; **`TAttFill`**. #### Color Palette (for Histograms). Defining one color at a time may be tedious. The histogram classes (see; Draw Options) use the color palette. For example, `TH1::Draw(""col"")`; draws a 2-D histogram with cells represented by a box filled with a; color `CI` function of the cell content. If the cell content is `N`, the; color `CI` used will be the color number in `colors[N]`. If the maximum; cell content is `>ncolors`, all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84411,Integrability,interface,interface,84411,"exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X ax",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:85260,Integrability,interface,interface,85260,"fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You can make a copy of a canvas using `TCanvas::DrawClonePad`. This; method is unique to **`TCanvas`**. It clones the entire canvas to the; active pad. There is a more general method `TObject::DrawClone`, which; all objects descendent of **`TObject`**, specifically all graphic; objects inherit. Below are two examples, one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:108091,Integrability,interface,interface,108091," is no longer redrawn. When the external viewer is closed,; clicking in the pad will refresh. ### The GL Viewer. The GL Viewer uses <OpenGL®> (or compliant libraries such as <Mesa3D>); to generate high quality, high-performance 3D renderings, with; sophisticated lighting, materials and rendering styles for 3D scenes.; Many users will be able to take advantage of hardware acceleration of; the underlying OpenGL commands by their computer's video card, resulting; is considerable performance gains - up to interactive manipulation of; 1000's of complex shapes in real-time. The GL Viewer is supported on all official ROOT platforms (assuming you; have suitable <OpenGL®> libraries), and is the main 3D viewer, which; development effort is concentrated upon. As OpenGL® is a trademark we; refer to our viewer built on this technology as the ‘GL Viewer'. The; code for it can be found under `$ROOTSYS/gl`. ![The GL 3D Viewer](pictures/020000DA.jpg). You can manipulate the viewer via the GUI or via the base; **`TGLViewer`** object behind the interface. These are detailed below -; see also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Projections Modes (Cameras). The GL Viewer supports two basic types of camera, which affect how the; 3D world is projected onto the 2D render area:. - Perspective: Objects are drawn with characteristic ‘foreshortening'; effect, where distant objects appear smaller than near ones. This is; useful for obtaining a ‘real world' views. The degree of; foreshortening is affected by the current camera field of view; (focal length of its ‘lens') - see ""Adjusting Cameras"". - Orthographic: Distance from camera does not affect object size.; These projections are useful for measurement or checking alignments,; as the sizes and angles between objects are preserved. You can select the active camera from the viewer's Camera menu on the; top menu bar. There are three perspective camera choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspec",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:110008,Integrability,interface,interface,110008,"ra choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen; floor plane, defined by a pair of world axes, appearing level at all; times - i.e. there is no banking of the ‘horizon' that you experience; when a plane rolls. There are also three orthographic camera choices:. - Orthographic (XOY). - Orthographic (XOZ). - Orthographic (ZOY). Orthographic projections are generally constrained to look down one of; the global axes of the world, with the other two axes lying; horizontal/vertical on the viewer window. Therefore, XOY has the X-axis; horizontal, the Y-axis vertical. You can always confirm the orientation; and constraints of the camera in the world by enabling axis drawing in; the ""Guides"" tab - see sections ""Guides"" and ""Clipping"" below. For; orthographic camera a ruler-depicting current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all cameras you can reset the original default view,; framing the entire scene, by double clicking any mouse button. ![GL Viewer camera interactions](pictures/020000DB.jpg). For the Zoom interaction you can use the following modifiers; combinations to adjust the sensitivity:. - Shiftx 10. - Ctrlx 0.1. - Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right; mouse button is down). Note for orthographic cameras:. - There is no ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:119170,Integrability,interface,interface,119170,"r of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the color and geometry; properties of the shape. Note: At present modifications to the shapes are local to the viewer -; they are not propagated back to external objects/client that published; to the viewer. The changes are preserved only until the viewer is; closed. In some cases, this will never be feasible as there is not a; one-to-one correspondence between a shape in the viewer and a single; external object in which the modification could be stored. #### Colors / Style. Viewer Controls Pane ‘Style' tab. A full description of OpenGL materials, colors and lighting is beyond; the scope of this document. You should refer to the OpenGL programming; manual (Red Book) for a full discussion. In most cases adjustment of the; Diffuse color material + Opacity/Shine properties is sufficient to; achieve desired results. A shape has four-color materials (components):. - Diffuse. - Ambient. - Specular. - Emissive. For each of these you can select the component v",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:122679,Integrability,interface,interface,122679,"6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; vi",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:126295,Integrability,interface,interface,126295,"iewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135749,Integrability,interface,interface,135749," GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **each** physical object. As **a minimum requirement** all clients must be capable of filling the; raw tessellation of the object buffer, in the master reference frame.; Conversely viewers must always be capable of displaying the object; described by this buffer. If either does not meet this requirement the; object may not be displayed. #### Scene Rebuilds. `TBuffer3D::AddObject` is not an explicit command to the viewer - it may; for various reasons decide to ignore it:. - It already has the object internally cached. - The ob",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:5762,Modifiability,inherit,inheritance,5762,"from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the parent class methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:5849,Modifiability,inherit,inherits,5849,"::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the parent class methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` p",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7758,Modifiability,variab,variable,7758,"functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indic",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7939,Modifiability,variab,variable,7939,"compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indicate; to the system which argument corresponds to which data member of the; class. ### Executing Events when a Cursor Passes on Top of an Object. This paragraph is for class designers. When a class is designed, it is; often desirable to include drawing methods for it. We will have a more; e",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7971,Modifiability,variab,variable,7971,"compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indicate; to the system which argument corresponds to which data member of the; class. ### Executing Events when a Cursor Passes on Top of an Object. This paragraph is for class designers. When a class is designed, it is; often desirable to include drawing methods for it. We will have a more; e",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:8722,Modifiability,variab,variables,8722,"re `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indicate; to the system which argument corresponds to which data member of the; class. ### Executing Events when a Cursor Passes on Top of an Object. This paragraph is for class designers. When a class is designed, it is; often desirable to include drawing methods for it. We will have a more; extensive discussion about this, but drawing an object in a canvas or a; pad consists in ""attaching"" the object to that pad. When one uses; `object.Draw()`, the object is NOT painted at this moment. It is only; attached to the active pad or canvas. Another method should be provided for the object to be painted, the; `Paint()` method. This is all explained in the next paragraph. As well; as `Draw()` and `Paint()`, other methods may be provided by the designer; of the class. When the mouse is moved or a button pressed/released, the; **`TCanvas`** function named `HandleInput()` scans the list of objects; in all it's pads and for ea",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:12556,Modifiability,inherit,inheritance,12556,"the sources of classes like **`TLine`** or **`TBox`**. Go and look at; their `ExecuteEvent` method! We can nevertheless give some reference to; the various actions that may be performed. For example, one often wants; to change the shape of the cursor when passing on top of an object. This; is done with the `SetCursor` method:. ``` {.cpp}; gPad->SetCursor(cursor); ```. The argument `cursor` is the type of cursor. It may be:. ``` {.cpp}; kBottomLeft, kBottomRight, kTopLeft,; kTopRight, kBottomSide, kLeftSide,; kTopSide, kRightSide, kMove,; kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer,; kArrowRight, kCaret, kWatch; ```. They are defined in `TVirtualX.h` and again we hope the names are; self-explanatory. If not, try them by designing a small class. It may; derive from something already known like **`TLine`**. Note that the `ExecuteEvent()` functions may in turn; invoke such; functions for other objects, in case an object is drawn using other; objects. You can also exploit at best the virtues of inheritance. See; for example how the class **`TArrow`** (derived from **`TLine`**) use or; redefine the picking functions in its base class. The last comment is that mouse position is always given in pixel units; in all these standard functions. `px=0` and `py=0` corresponds to the; top-left corner of the canvas. Here, we have followed the standard; convention in windowing systems. Note that user coordinates in a canvas; (pad) have the origin at the bottom-left corner of the canvas (pad).; This is all explained in the paragraph ""The Coordinate Systems of a; Pad"". ## Graphical Containers: Canvas and Pad; \index{TPad}. We have talked a lot about canvases, which may be seen as windows. More; generally, a graphical entity that contains graphical objects is called; a Pad. A Canvas is a special kind of Pad. From now on, when we say; something about pads, this also applies to canvases. A pad (class; **`TPad`**) is a graphical container in the sense it contains other; graphica",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:16226,Modifiability,variab,variable,16226,"o-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e. `TPad::GetPrimitive(const char* name)` does exactly this. Since; most of the objects that a pad contains derive from **`TObject`**, they; have a name. The following statement will return a pointer to the object; `myobjectname` and put that pointer into the variable `obj`. As you can; see, the type of returned pointer is `TObject*`. ``` {.cpp}; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; ```. Even if your object is something more complicated, like a histogram; **`TH1F`**, this is normal. A function cannot return more than one type.; So the one chosen was the lowest common denominator to all possible; classes, the class from which everything derives, **`TObject`**. How do; we get the right pointer then? Simply do a cast of the function output; that will transform the output (pointer) into the right type. For; example if the object is a **`TPaveLabel`**:. ``` {.cpp}; root[] obj = (TPaveLabel*)(gPad->GetPrimitive(""myobjectname"")); (class TPaveLabel*)0x1063cba8; ```. This works for all objects deriving from **`TObject`**. However, a; question remains. An object has a name if it derives from **`TNamed`**,; not from **`TObject`**. For example, an arrow (**`TArrow`**)",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25484,Modifiability,variab,variables,25484,"hese coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:37177,Modifiability,inherit,inherits,37177,"rs](pictures/030000B0.png). The marker constructor is:. ``` {.cpp}; TMarker(Double_t x,Double_t y,Int_t marker); ```. The parameters `x` and `y` are the marker coordinates and `marker` is; the marker type, shown in the previous figure. Suppose the pointer `ma`; is a valid marker. The marker size is set via `ma->SetMarkerSize(size)`,; where `size` is the desired size. Note, that the marker types 1, 6 and 7; (the dots) cannot be scaled. They are always drawn with the same number; of pixels. `SetMarkerSize` does not apply on them. To have a ""scalable; dot"" a circle shape should be used instead, for example, the marker type; 20. The default marker type is 1, if `SetMarkerStyle` is not specified.; It is the most common one to draw scatter plots. ![Different marker sizes](pictures/030000B1.png). ![Different marker sizes](pictures/030000B2.png). The user interface for changing the marker color, style and size looks; like shown in this picture. It takes place in the editor frame anytime; the selected object inherits the class **`TAttMarker`**. Non-symmetric symbols should be used carefully in plotting. The next two; graphs show how the misleading a careless use of symbols can be. The two; plots represent the same data sets but because of a bad symbol choice,; the two on the top appear further apart from the next example. ![The use of non-symmetric markers](pictures/030000B3.png). A **`TPolyMaker`** is defined by an array on N points in a 2D space. At; each point `x[i]`, `y[i]` a marker is drawn. The list of marker types is; shown in the previous paragraph. The marker attributes are managed by; the class **`TAttMarker`** and are described in ""Graphical Objects; Attributes"". The **`TPolyMarker`** constructor is:. ``` {.cpp}; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); ```. Where `x` and `y` are arrays of coordinates for the `n` points that form; the poly-marker. ### Curly and Wavy Lines for Feynman Diagrams. This is a peculiarity of particle physics, but we ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:38574,Modifiability,inherit,inheritance,38574,"nts in a 2D space. At; each point `x[i]`, `y[i]` a marker is drawn. The list of marker types is; shown in the previous paragraph. The marker attributes are managed by; the class **`TAttMarker`** and are described in ""Graphical Objects; Attributes"". The **`TPolyMarker`** constructor is:. ``` {.cpp}; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); ```. Where `x` and `y` are arrays of coordinates for the `n` points that form; the poly-marker. ### Curly and Wavy Lines for Feynman Diagrams. This is a peculiarity of particle physics, but we do need sometimes to; draw Feynman diagrams. Our friends working in banking can skip this; part. A set of classes implements curly or wavy poly-lines typically; used to draw Feynman diagrams. Amplitudes and wavelengths may be; specified in the constructors, via commands or interactively from; context menus. These classes are **`TCurlyLine`** and **`TCurlyArc`**.; These classes make use of **`TPolyLine`** by inheritance; `ExecuteEvent`; methods are highly inspired from the methods used in **`TPolyLine`** and; **`TArc`**. ![The picture generated by the tutorial macro; feynman.C](pictures/030000B4.png). The **`TCurlyLine`** constructor is:. ``` {.cpp}; TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; Double_t wavelength, Double_t amplitude); ```. The coordinates `(x1`, `y1)` define the starting point, `(x2`, `y2)` -; the end-point. The `wavelength` and the `amplitude` are given in percent; of the pad height. The **`TCurlyArc`** constructor is:. ``` {.cpp}; TCurlyArc(Double_t x1, Double_t y1, Double_t rad,; Double_t phimin, Double_t phimax,; Double_t wavelength, Double_t amplitude); ```. The curly arc center is `(x1`, `y1)` and the radius is `rad`. The; wavelength and the amplitude are given in percent of the line length.; The parameters `phimin` and `phimax` are the starting and ending angle; of the arc (given in degrees). Refer to; `$ROOTSYS/tutorials/graphics/feynman.C` for the script that built the; figure ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:55391,Modifiability,inherit,inherits,55391,"uncname, Int_t ndiv=510,; Option_t* chopt, Double_t gridlength=0); ```. In such a way, it is possible to obtain exponential evolution of the; tick marks position, or even decreasing. In fact, anything you like. ### Orientation of Tick Marks on Axis. Tick marks are normally drawn on the positive side of the axis, however,; if `xmin = xmax`, then negative. - `chopt = '+': ` tick marks are drawn on Positive side. (Default). - `chopt = '-': ` tick marks are drawn on the negative side. - `chopt = '+-':` tick marks are drawn on both sides of the axis. - `chopt = ‘U': ` unlabeled axis, default is labeled. ### Labels. #### Position. Labels are normally drawn on side opposite to tick marks. However,; `chopt = '='`: on Equal side. The function `TAxis::CenterLabels()` sets; the bit `kCenterLabels` and it is visible from **`TAxis`** context menu.; It centers the bin labels and it makes sense only when the number of; bins is equal to the number of tick marks. The class responsible for; drawing the axis **`TGaxis`** inherits this property. #### Orientation. Labels are normally drawn parallel to the axis. However, if; `xmin = xmax`, then they are drawn orthogonal, and if `ymin=ymax` they; are drawn parallel. #### Labels for Exponents. By default, an exponent of the form 10\^N is used when the label values; are either all very small or very large. One can disable the exponent by; calling:. ``` {.cpp}; TAxis::SetNoExponent(kTRUE); ```. Note that this option is implicitly selected if the number of digits to; draw a label is less than the `fgMaxDigits` global member. If the; property `SetNoExponent` was set in **`TAxis`** (via; `TAxis::SetNoExponent)`, the **`TGaxis`** will inherit this property.; **`TGaxis`** is the class responsible for drawing the axis. The method; `SetNoExponent` is also available from the axis context menu. ![Y-axis with and without exponent labels](pictures/030000C7.png). #### Number of Digits in Labels. `TGaxis::fgMaxDigits` is the maximum number of digits permi",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:56057,Modifiability,inherit,inherit,56057,"are normally drawn on side opposite to tick marks. However,; `chopt = '='`: on Equal side. The function `TAxis::CenterLabels()` sets; the bit `kCenterLabels` and it is visible from **`TAxis`** context menu.; It centers the bin labels and it makes sense only when the number of; bins is equal to the number of tick marks. The class responsible for; drawing the axis **`TGaxis`** inherits this property. #### Orientation. Labels are normally drawn parallel to the axis. However, if; `xmin = xmax`, then they are drawn orthogonal, and if `ymin=ymax` they; are drawn parallel. #### Labels for Exponents. By default, an exponent of the form 10\^N is used when the label values; are either all very small or very large. One can disable the exponent by; calling:. ``` {.cpp}; TAxis::SetNoExponent(kTRUE); ```. Note that this option is implicitly selected if the number of digits to; draw a label is less than the `fgMaxDigits` global member. If the; property `SetNoExponent` was set in **`TAxis`** (via; `TAxis::SetNoExponent)`, the **`TGaxis`** will inherit this property.; **`TGaxis`** is the class responsible for drawing the axis. The method; `SetNoExponent` is also available from the axis context menu. ![Y-axis with and without exponent labels](pictures/030000C7.png). #### Number of Digits in Labels. `TGaxis::fgMaxDigits` is the maximum number of digits permitted for the; axis labels above which the notation with 10\^N is used. It must be; greater than 0. By default `fgMaxDigits` is 5 and to change it use the; `TGaxis::SetMaxDigits` method. For example to set `fgMaxDigits` to; accept 6 digits and accept numbers like 900000 on an axis call:. ``` {.cpp}; TGaxis::SetMaxDigits(6); ```. #### Tick Mark Positions. Labels are centered on tick marks. However, if `xmin = xmax`, then they; are right adjusted. - `chopt = 'R'`: labels are right adjusted on tick mark (default is; centered). - `chopt = 'L'`: labels are left adjusted on tick mark. - `chopt = 'C'`: labels are centered on tick mark. - `",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:68963,Modifiability,inherit,inherits,68963,"1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; ```. ## Graphical Objects Attributes. ### Text Attributes. When a class contains text or derives from a text class, it needs to be; able to set text attributes like font type, size, and color. To do so,; the class inherits from the **`TAttText`** class (a secondary; inheritance), which defines text attributes. **`TLatex`** and; **`TText`** inherit from **`TAttText`**. #### Setting Text Alignment. Text alignment may be set by a method call. What is said here applies to; all objects deriving from **`TAttText`**, and there are many. We will; take an example that may be transposed to other types. Suppose ""`la`"" is; a **`TLatex`** object. The alignment is set with:. ``` {.cpp}; root[] la->SetTextAlign(align); ```. The parameter `align` is a `short` describing the alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horiz",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:69016,Modifiability,inherit,inheritance,69016,"1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; ```. ## Graphical Objects Attributes. ### Text Attributes. When a class contains text or derives from a text class, it needs to be; able to set text attributes like font type, size, and color. To do so,; the class inherits from the **`TAttText`** class (a secondary; inheritance), which defines text attributes. **`TLatex`** and; **`TText`** inherit from **`TAttText`**. #### Setting Text Alignment. Text alignment may be set by a method call. What is said here applies to; all objects deriving from **`TAttText`**, and there are many. We will; take an example that may be transposed to other types. Suppose ""`la`"" is; a **`TLatex`** object. The alignment is set with:. ``` {.cpp}; root[] la->SetTextAlign(align); ```. The parameter `align` is a `short` describing the alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horiz",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:69091,Modifiability,inherit,inherit,69091,"le; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; ```. ## Graphical Objects Attributes. ### Text Attributes. When a class contains text or derives from a text class, it needs to be; able to set text attributes like font type, size, and color. To do so,; the class inherits from the **`TAttText`** class (a secondary; inheritance), which defines text attributes. **`TLatex`** and; **`TText`** inherit from **`TAttText`**. #### Setting Text Alignment. Text alignment may be set by a method call. What is said here applies to; all objects deriving from **`TAttText`**, and there are many. We will; take an example that may be transposed to other types. Suppose ""`la`"" is; a **`TLatex`** object. The alignment is set with:. ``` {.cpp}; root[] la->SetTextAlign(align); ```. The parameter `align` is a `short` describing the alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horizontal. ``` {.cpp}; root[] la->SetTextAngle(angle); ```. #### Setting Text Color. Use `TAt",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:75563,Modifiability,inherit,inherits,75563,"Fonts. You can activate the True Type Fonts by adding the following line in; your `.rootrc` file. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; ```. You can check that you indeed use the `TTF` in your Root session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set by a method call. What; is said here applies to all objects deriving from **`TAttLine`**, and; there are many (histograms, plots). We will take an example that may be; transposed to other types. Suppose ""`li`"" is a **`TLine`** object. The; line color is set with:. ``` {.cpp}; root[] li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:75743,Modifiability,inherit,inheritance,75743,"ot session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set by a method call. What; is said here applies to all objects deriving from **`TAttLine`**, and; there are many (histograms, plots). We will take an example that may be; transposed to other types. Suppose ""`li`"" is a **`TLine`** object. The; line color is set with:. ``` {.cpp}; root[] li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:77214,Modifiability,inherit,inherits,77214,"r and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line width is; set with:. ``` {.cpp}; root[] li->SetLineWidth(width); ```. The `width` is the width expressed in pixel units. ![](pictures/030000D1.png) The user interface for changing the line; color, line width and style looks like shown in this picture. It takes; place in the editor frame anytime the selected object inherits the class; **`TAttLine`**. ### Fill Attributes. Almost all graphics classes have a fill area somewhere. These classes; have to deal with fill attributes. This is done by using secondary; inheritance of the class **`TAttFill`**. Fill color may be set by a; method call. What is said here applies to all objects deriving from; **`TAttFill`**, and there are many (histograms, plots). We will take an; example that may be transposed to other types. Suppose ""`h`"" is a; **`TH1F`** (1 dim histogram) object. The histogram fill color is set; with:. ``` {.cpp}; root[] h->SetFillColor(color); ```. The color is a color number. The colors are described in ""Color and; color palettes"". Fill style may be set by a method call. What is said here applies to all; objects deriving from `TAttFill`, and there are many (histograms,; plots). We will take an example that may be transposed to other types.; Suppose ""`h`"" is a **TH1F** (1 dim histogram) object. The histogram fill; style is set ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:77410,Modifiability,inherit,inheritance,77410,"e transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line width is; set with:. ``` {.cpp}; root[] li->SetLineWidth(width); ```. The `width` is the width expressed in pixel units. ![](pictures/030000D1.png) The user interface for changing the line; color, line width and style looks like shown in this picture. It takes; place in the editor frame anytime the selected object inherits the class; **`TAttLine`**. ### Fill Attributes. Almost all graphics classes have a fill area somewhere. These classes; have to deal with fill attributes. This is done by using secondary; inheritance of the class **`TAttFill`**. Fill color may be set by a; method call. What is said here applies to all objects deriving from; **`TAttFill`**, and there are many (histograms, plots). We will take an; example that may be transposed to other types. Suppose ""`h`"" is a; **`TH1F`** (1 dim histogram) object. The histogram fill color is set; with:. ``` {.cpp}; root[] h->SetFillColor(color); ```. The color is a color number. The colors are described in ""Color and; color palettes"". Fill style may be set by a method call. What is said here applies to all; objects deriving from `TAttFill`, and there are many (histograms,; plots). We will take an example that may be transposed to other types.; Suppose ""`h`"" is a **TH1F** (1 dim histogram) object. The histogram fill; style is set with:. ``` {.cpp}; root[] h->SetFillStyle(style); ```. The convention for style is: 0:hollow, 1001:solid, 2001:hatch style,; 3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully; transparent, 4100: f",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:81288,Modifiability,inherit,inherits,81288,"ure above, can be viewed by selecting the; menu entry Colors in the View canvas menu. The user may define other; colors. To do this, one has to build a new **`TColor`**:. ``` {.cpp}; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); ```. One has to give the color number and the three Red, Green, Blue values,; each being defined from 0 (min) to 1(max). An optional name may be; given. When built, this color is automatically added to the existing; list of colors. If the color number already exists, one has to extract; it from the list and redefine the RGB values. This may be done for; example with:. ``` {.cpp}; root[] color=(TColor*)(gROOT->GetListOfColors()->At(index_color)); root[] color->SetRGB(r,g,b); ```. Where `r`, `g` and `b` go from 0 to 1 and `index_color` is the color; number you wish to change. ![](pictures/030000D4.png) The user interface for changing the fill; color and style looks like shown in this picture. It takes place in the; editor frame anytime the selected object inherits the class; **`TAttFill`**. #### Color Palette (for Histograms). Defining one color at a time may be tedious. The histogram classes (see; Draw Options) use the color palette. For example, `TH1::Draw(""col"")`; draws a 2-D histogram with cells represented by a box filled with a; color `CI` function of the cell content. If the cell content is `N`, the; color `CI` used will be the color number in `colors[N]`. If the maximum; cell content is `>ncolors`, all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette are good for; coloring pads, labels, and other graphic objects. If `ncolors > 0` and; `colors = 0",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:82739,Modifiability,adapt,adapt,82739,"all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette are good for; coloring pads, labels, and other graphic objects. If `ncolors > 0` and; `colors = 0`, the default palette is used with a maximum of `ncolors`.; If `ncolors == 1 && colors == 0`, then a pretty palette with a spectrum; `Violet->Red` is created. It is recommended to use this pretty palette; when drawing lego(s), surfaces or contours. For example, to set the; current palette to the ""`pretty`"" one, do:. ``` {.cpp}; root[] gStyle->SetPalette(1); ```. A more complete example is shown below. It illustrates the definition of; a custom palette. You can adapt it to suit your needs. In case you use; it for contour coloring, with the current color/contour algorithm,; always define two more colors than the number of contours. ``` {.cpp}; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""f",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:85997,Modifiability,inherit,inherit,85997,"sition, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You can make a copy of a canvas using `TCanvas::DrawClonePad`. This; method is unique to **`TCanvas`**. It clones the entire canvas to the; active pad. There is a more general method `TObject::DrawClone`, which; all objects descendent of **`TObject`**, specifically all graphic; objects inherit. Below are two examples, one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/03",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:87081,Modifiability,inherit,inherited,87081,", one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/030000D7.png). If you want to copy and paste a graphic object from one canvas or pad to; another canvas or pad, you can do so with `DrawClone` method inherited; from **`TObject`**. All graphics objects inherit the; `TObject::DrawClone` method. In this example, we create a new canvas; with one histogram from each of the canvases from the script; `draw2dopt.C`. - Start a new ROOT session and execute the script `draw2dopt.C`. - Select a canvas displayed by the script, and create a new canvas; `c1` from the File menu. - Make sure that the target canvas (`c1`) is the active one by middle; clicking on it. If you do this step right after step 2, c1 will be; active. - Select the pad with the first histogram you want to copy and paste. - Right click on it to show the context menu, and select `DrawClone`. - Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by; the script, until you have one pad from each type. If you wanted to put; the same annotation on each of the sub pads in the new canvas, you could; use `DrawClone` to do so. Here we",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:87133,Modifiability,inherit,inherit,87133,"example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/030000D7.png). If you want to copy and paste a graphic object from one canvas or pad to; another canvas or pad, you can do so with `DrawClone` method inherited; from **`TObject`**. All graphics objects inherit the; `TObject::DrawClone` method. In this example, we create a new canvas; with one histogram from each of the canvases from the script; `draw2dopt.C`. - Start a new ROOT session and execute the script `draw2dopt.C`. - Select a canvas displayed by the script, and create a new canvas; `c1` from the File menu. - Make sure that the target canvas (`c1`) is the active one by middle; clicking on it. If you do this step right after step 2, c1 will be; active. - Select the pad with the first histogram you want to copy and paste. - Right click on it to show the context menu, and select `DrawClone`. - Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by; the script, until you have one pad from each type. If you wanted to put; the same annotation on each of the sub pads in the new canvas, you could; use `DrawClone` to do so. Here we added the date to each pad. The steps; to this are:. - Create the label in on of the pads with the graphics editor",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:90862,Modifiability,inherit,inherits,90862,"rdinates, border size and option.; The legend coordinates (NDC) in the current pad are `x1`, `y1`, `x2`,; `y2`. The default text attributes for the legend are:. - Alignment = 12 left adjusted and vertically centered. - Angle = 0 (degrees). - Color = 1 (black). - Size = calculate when number of entries is known. - Font = helvetica-medium-r-normal scalable font = 42, and bold = 62; for title. The title is a regular entry and supports **`TLatex`**. The default is; no title (`header = 0`). The options are the same as for **`TPave`**; by; default, they are ""`brand`"". Once the legend box is created, one has to; add the text with the `AddEntry()` method:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); ```. The parameters are:. - `*obj `is a pointer to an object having marker, line, or fill; attributes (a histogram, or a graph). - `label` is the label to be associated to the object. - `option`:. - ""L"" draw line associated with line attributes of `obj`, if `obj`; inherits from **`TAttLine`**. - ""P"" draw poly-marker associated with marker attributes of `obj`, if; `obj` inherits **`TAttMarker`**. - ""F"" draw a box with fill associated with fill attributes of `obj`,; if `obj` inherits **`TAttFill`**. One may also use the other form of the method `AddEntry`:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); ```. Here `name` is the name of the object in the pad. Other parameters are; as in the previous case. Next example shows how to create a legend:. ``` {.cpp}; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; ```. Here `fun1`, `fun2`, `fun3` ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:90969,Modifiability,inherit,inherits,90969,"2`,; `y2`. The default text attributes for the legend are:. - Alignment = 12 left adjusted and vertically centered. - Angle = 0 (degrees). - Color = 1 (black). - Size = calculate when number of entries is known. - Font = helvetica-medium-r-normal scalable font = 42, and bold = 62; for title. The title is a regular entry and supports **`TLatex`**. The default is; no title (`header = 0`). The options are the same as for **`TPave`**; by; default, they are ""`brand`"". Once the legend box is created, one has to; add the text with the `AddEntry()` method:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); ```. The parameters are:. - `*obj `is a pointer to an object having marker, line, or fill; attributes (a histogram, or a graph). - `label` is the label to be associated to the object. - `option`:. - ""L"" draw line associated with line attributes of `obj`, if `obj`; inherits from **`TAttLine`**. - ""P"" draw poly-marker associated with marker attributes of `obj`, if; `obj` inherits **`TAttMarker`**. - ""F"" draw a box with fill associated with fill attributes of `obj`,; if `obj` inherits **`TAttFill`**. One may also use the other form of the method `AddEntry`:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); ```. Here `name` is the name of the object in the pad. Other parameters are; as in the previous case. Next example shows how to create a legend:. ``` {.cpp}; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; ```. Here `fun1`, `fun2`, `fun3` and `gr` are pre-existing functions and; graphs. You can edit the **`TLegend`** by right clicking on ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:91075,Modifiability,inherit,inherits,91075,"y centered. - Angle = 0 (degrees). - Color = 1 (black). - Size = calculate when number of entries is known. - Font = helvetica-medium-r-normal scalable font = 42, and bold = 62; for title. The title is a regular entry and supports **`TLatex`**. The default is; no title (`header = 0`). The options are the same as for **`TPave`**; by; default, they are ""`brand`"". Once the legend box is created, one has to; add the text with the `AddEntry()` method:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); ```. The parameters are:. - `*obj `is a pointer to an object having marker, line, or fill; attributes (a histogram, or a graph). - `label` is the label to be associated to the object. - `option`:. - ""L"" draw line associated with line attributes of `obj`, if `obj`; inherits from **`TAttLine`**. - ""P"" draw poly-marker associated with marker attributes of `obj`, if; `obj` inherits **`TAttMarker`**. - ""F"" draw a box with fill associated with fill attributes of `obj`,; if `obj` inherits **`TAttFill`**. One may also use the other form of the method `AddEntry`:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); ```. Here `name` is the name of the object in the pad. Other parameters are; as in the previous case. Next example shows how to create a legend:. ``` {.cpp}; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; ```. Here `fun1`, `fun2`, `fun3` and `gr` are pre-existing functions and; graphs. You can edit the **`TLegend`** by right clicking on it. ![A legend example](pictures/030000D8.png). ## The PostScript Interface. To generate a PostScript (o",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:101387,Modifiability,inherit,inherit,101387,"PDF files are usually smaller because; some parts of them can be compressed. PDF also allows to define table of contents. This facility can be used; in ROOT. The following example shows how to proceed:. ``` {.cpp}; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the global variable; ***`gStyle`*** (in `TStyle.h`). See the class **`TStyle`** for a; complete list of the attributes that can be set in one style. ROOT provides several styles called:. - ""`Default`"" - the default style. - ""`Plain`"" - the simple style (black and white). - ""`Bold`"" - bolder lines. - ""`Video`"" - suitable for html output or screen viewing. The ""`Default`"" style is created by:. ``` {.cpp}; TStyle *default = new TStyle(""Default"",""Default Style"");; ```. The ""`Plain`"" style can be used if you want to get a ""conventional""; PostScript output or if you are working on a monochrome display. The; following example shows how to create it. ``` {.cpp}; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCan",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:101684,Modifiability,variab,variable,101684,"vas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the global variable; ***`gStyle`*** (in `TStyle.h`). See the class **`TStyle`** for a; complete list of the attributes that can be set in one style. ROOT provides several styles called:. - ""`Default`"" - the default style. - ""`Plain`"" - the simple style (black and white). - ""`Bold`"" - bolder lines. - ""`Video`"" - suitable for html output or screen viewing. The ""`Default`"" style is created by:. ``` {.cpp}; TStyle *default = new TStyle(""Default"",""Default Style"");; ```. The ""`Plain`"" style can be used if you want to get a ""conventional""; PostScript output or if you are working on a monochrome display. The; following example shows how to create it. ``` {.cpp}; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; plain->SetCanvasColor(0);; plain->SetTitleColor(0);; plain->SetStatColor(0);; ```. You can set the current style by:. ``` {.cpp}; gROOT->SetStyle(style_name);",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:104233,Modifiability,extend,extended,104233,"e. For example, you may have created a histogram in a; previous session and saved it in a file. Meanwhile, if you have changed; the style, the histogram will be drawn with the old attributes. You can; force the current style attributes to be set when you read an object; from a file by calling `ForceStyle` before reading the objects from the; file. ``` {.cpp}; gROOT->ForceStyle();; ```. When you call `gROOT->ForceStyle()` and read an object from a ROOT file,; the object's method `UseCurrentStyle` is called. The attributes saved; with the object are replaced by the current style attributes. You call; also call `myObject->UseCurrentStyle()` directly. For example if you; have a canvas or pad with your histogram or any other object, you can; force these objects to get the attributes of the current style by:. ``` {.cpp}; canvas->UseCurrentStyle();; ```. The description of the style functions should be clear from the name of; the **`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer -",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:112357,Modifiability,config,configure,112357,"ed. However the movement can result in objects coming; ‘through the front' of the camera and disappearing. - When you zoom, the camera does not move - hence clipping of near; objects is unaffected. However with extremely small zooms (FOV; large/focal length short) noticeable distortions, causing straight; lines to become curved, can be seen with objects near the camera -; the ‘fisheye' lens effect. - Generally dollying is more ‘natural', but you may need to use both; to achieve the desired perspective and eye position - particularly; when you are working inside or very close to 3D objects. Configure the camera by calling the methods `SetPerspectiveCamera(`) or; `SetOrthographicCamera()` of **`TGLViewer`**:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; v->SetOrthoCamera(TGLViewer::kCameraOrthoXOY,; left,right,top,bottom);; ...; v->SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);; ```. Note - you can configure any of the six cameras in the viewer at any; time, but you will not see the result until the camera is made current. #### Draw Styles. The GL Viewer supports three different rendering modes, which are; applied to all the objects in your scene, but not Clip Shapes and Guides; (See ""Clipping"" and ""Manipulators""). These are shown below, along with; the key used to activate the style. ![GL Viewer draw styles](pictures/020000DC.jpg). **Filled Polygons** **Wireframe** **Outline** Enable with ‘r' key Enable; with ‘w' key Enable with ‘t' key Solid polygons, with hidden surface; Object edges in color, with Combination of Filled Polygons removal,; color surface materials, no surface filling/hiding. and Outline styles.; Solid opacity, specular reflection etc. shapes with edges. Black; background. Black background. White background. Call method `TGLViewer::SetStyle` with one of; **`TGLRnrCtx::EDrawStyle `flags `kFill`, `kOutline`, `kWireFrame`:**. ``` {.cpp}; v->SetStyle(TGLRnrCtx::kFill);; ```. #### Lighting / Style. The GL viewer creates f",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:116034,Modifiability,config,configured,116034," is described by its center position, entered in the ‘Center; X', ‘Center Y' and ‘Center Z' edit boxes, and its lengths (extents); entered in the ‘Length X', ‘Length Y' and ‘Length Z' edit boxes. This clipping is achieved using OpenGL clip plane support; as such,; there are certain limitations:. - Solid shapes are not capped - they appear hollow. - Only shapes, which can be described with combination of planes, can; be rendered in this fashion - e.g. a clipping tube is not possible. - Each additional clipping plane requires an additional render pass -; so the more active planes the more time the render will take. Set the current clip object with **`TGLClipSet::SetClipType`**. ``` {.cpp}; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; ```. Configure the clip object with **`TGLClipSet::SetClipState`**. ``` {.cpp}; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; ```. As with cameras, any clip can be configured at any time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:3403,Performance,perform,performance,3403,"e left; mouse button. The cursor changes its shape to indicate what may be done:. Point the object or one part of it: ![](pictures/02000095.jpg); ![](pictures/02000096.jpg). Rotate: ![](pictures/02000097.jpg). Resize (exists also for the other directions):; ![](pictures/02000098.jpg) ![](pictures/02000099.jpg). Enlarge (used for text): ![](pictures/0200009A.jpg). Move: ![](pictures/0200009B.jpg). Here are some examples of:. Moving: ![](pictures/0200009C.jpg) Resizing: ![](pictures/0200009D.jpg). Rotating: ![](pictures/0200009E.jpg) ![](pictures/0300009F.png). #### With C++ Statements (Programmatically). How would one move an object in a script? Since there is a tight; correspondence between what is seen on the screen and the object in; memory, changing the object changes it on the screen. For example, try; to do:. ``` {.cpp}; root[] a.SetX1(0.9); ```. This should change one of the coordinates of our line, but nothing; happens on the screen. Why is that? In short, the canvas is not updated; with each change for performance reasons. See ""Updating the Pad"". ### Selecting Objects. #### The Middle Mouse Button. Objects in a canvas, as well as in a pad, are stacked on top of each; other in the order they were drawn. Some objects may become ""active""; objects, which mean they are reordered to be on top of the others. To; interactively make an object ""active"", you can use the middle mouse; button. In case of canvases or pads, the border becomes highlighted when; it is active. #### With C++ Statements (Programmatically). Frequently we want to draw in different canvases or pads. By default,; the objects are drawn in the active canvas. To activate a canvas you can; use the `TPad::cd()` method. ``` {.cpp}; root[] c1->cd(); ```. ### Context Menus: the Right Mouse Button. The context menus are a way to interactively call certain methods of an; object. When designing a class, the programmer can add methods to the; context menu of the object by making minor changes to the header fil",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:11715,Performance,perform,performed,11715,"ctually; does the event reaction. Its prototype is where `px` and `py` are the; coordinates at which the event occurred, except if the event is a key; press, in which case `px` contains the key code. ``` {.cpp}; void ExecuteEvent(Int_t event, Int_t px, Int_t py);; ```. Where `event` is the event that occurs and is one of the following; (defined in `Buttons.h`):. ``` {.cpp}; kNoEvent, kButton1Down, kButton2Down,; kButton3Down, kKeyDown, kButton1Up,; kButton2Up, kButton3Up, kButton1Motion,; kButton2Motion, kButton3Motion, kKeyPress,; kButton1Locate, kButton2Locate, kButton3Locate,; kKeyUp, kButton1Double, kButton2Double,; kButton3Double, kMouseMotion, kMouseEnter,; kMouseLeave; ```. We hope the names are self-explanatory. Designing an `ExecuteEvent` method is not very easy, except if one wants; very basic treatment. We will not go into that and let the reader refer; to the sources of classes like **`TLine`** or **`TBox`**. Go and look at; their `ExecuteEvent` method! We can nevertheless give some reference to; the various actions that may be performed. For example, one often wants; to change the shape of the cursor when passing on top of an object. This; is done with the `SetCursor` method:. ``` {.cpp}; gPad->SetCursor(cursor); ```. The argument `cursor` is the type of cursor. It may be:. ``` {.cpp}; kBottomLeft, kBottomRight, kTopLeft,; kTopRight, kBottomSide, kLeftSide,; kTopSide, kRightSide, kMove,; kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer,; kArrowRight, kCaret, kWatch; ```. They are defined in `TVirtualX.h` and again we hope the names are; self-explanatory. If not, try them by designing a small class. It may; derive from something already known like **`TLine`**. Note that the `ExecuteEvent()` functions may in turn; invoke such; functions for other objects, in case an object is drawn using other; objects. You can also exploit at best the virtues of inheritance. See; for example how the class **`TArrow`** (derived from **`TLine`**) use or; redefine th",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:14999,Performance,perform,performed,14999,"is `AppendPad()`. This statement calls method; of **`TObject`** that just adds the pointer of the object, here a; histogram, to the list of objects attached to the current pad. Since; this is a **`TObject`**'s method, every object may be ""drawn"", which; means attached to a pad. When is the painting done then ? The answer is: when needed. Every object; that derives from **`TObject`** has a `Paint()` method. It may be empty,; but for graphical objects, this routine contains all the instructions to; paint effectively it in the active pad. Since a Pad has the list of; objects it owns, it will call successively the `Paint()` method of each; object, thus re-painting the whole pad on the screen. If the object is a; sub-pad, its `Paint()` method will call the `Paint()` method of the; objects attached, recursively calling `Paint()` for all the objects. ![Pad painting](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:26188,Performance,perform,performance,26188,"](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for example the; name and title of an object. - You can also set the ""bit-modified"" explicitly with the `Modified`; method:. ``` {.cpp}; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. I",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:36707,Performance,scalab,scalable,36707,"2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(); ```. ![A rectangle with a border](pictures/020000AF.jpg). A **`TWbox`** is a rectangle (**`TBox`**) with a border size and a; border mode. The attributes of the outline line and of the fill area are; described in ""Graphical Objects Attributes"". ### Markers. A marker is a point with a fancy shape! The possible markers are shown; in the next figure. ![Markers](pictures/030000B0.png). The marker constructor is:. ``` {.cpp}; TMarker(Double_t x,Double_t y,Int_t marker); ```. The parameters `x` and `y` are the marker coordinates and `marker` is; the marker type, shown in the previous figure. Suppose the pointer `ma`; is a valid marker. The marker size is set via `ma->SetMarkerSize(size)`,; where `size` is the desired size. Note, that the marker types 1, 6 and 7; (the dots) cannot be scaled. They are always drawn with the same number; of pixels. `SetMarkerSize` does not apply on them. To have a ""scalable; dot"" a circle shape should be used instead, for example, the marker type; 20. The default marker type is 1, if `SetMarkerStyle` is not specified.; It is the most common one to draw scatter plots. ![Different marker sizes](pictures/030000B1.png). ![Different marker sizes](pictures/030000B2.png). The user interface for changing the marker color, style and size looks; like shown in this picture. It takes place in the editor frame anytime; the selected object inherits the class **`TAttMarker`**. Non-symmetric symbols should be used carefully in plotting. The next two; graphs show how the misleading a careless use of symbols can be. The two; plots represent the same data sets but because of a bad symbol choice,; the two on the top appear further apart from the next example. ![The use of non-symmetric markers](pictures/030000B3.png). A **`TPolyMaker`** is defined by an array on N points in a 2D space. At; each point `x[i]`, `y[i]` a marker is drawn. The list of marker types is; shown in the previous paragraph. The mark",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:51767,Performance,optimiz,optimized,51767,"_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 100*N2 + 10000*N3`. - `N1 =` number of first divisions. - `N2 =` number of secondary divisions. - `N3 =` number of tertiary divisions. - `optim = kTRUE ` (default), the divisions' number will be optimized; around the specified value. - `optim = kFALSE, ` or n \< 0, the axis will be forced to use exactly; n divisions. For example:. `ndiv = 0`: no tick marks. `ndiv = 2`: 2 divisions, one tick mark in the middle of the axis. `ndiv = 510`: 10 primary divisions, 5 secondary divisions. `ndiv = -10`: exactly 10 primary divisions. ### Zooming the Axis. You can use `TAxis::SetRange` or `TAxis::SetRangeUser` to zoom the axis. ``` {.cpp}; TAxis::SetRange(Int_t binfirst,Int_t binlast); ```. The `SetRange` method parameters are bin numbers. They are not axis. For; example if a histogram plots the values from 0 to 500 and has 100 bins,; `SetRange(0,10)` will cover the values 0 to 50. The parameters for; `SetRangeUser` are user coordinates. If the start or end is in the; middle of a bin the resulting range is approximation. It finds the low; edge bin for the start and the high edge bin for the high. ``` {.cpp}; TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast); ```. Both methods, `S",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:58176,Performance,optimiz,optimized,58176,"if last character of the string, is also stripped. In the; following, we have some parameters, like tick marks length and; characters height (in percentage of the length of the axis, in user; coordinates). The default values are as follows:. - Primary tick marks: 3.0 %. - Secondary tick marks: 1.5 %. - Third order tick marks: .75 %. - Characters height for labels: 4%. - Labels offset: 1.0 %. #### Stripping Decimals. Use the `TStyle::SetStripDecimals` to strip decimals when drawing axis; labels. By default, the option is set to true, and `TGaxis::PaintAxis`; removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5,; 1, 1.5, 2, 2.5, etc.}. ``` {.cpp}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); ```. If this function is called with `strip=kFALSE`, `TGaxis::PaintAxis()`; will draw labels with the same number of digits after the dot, e.g.; {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}. #### Optional Grid. `chopt = 'W'`: cross-Wire. #### Axis Binning Optimization. By default, the axis binning is optimized. - `chopt = 'N'`: No binning optimization. - `chopt = 'I'`: Integer labeling. ### Axis with Time Units. Histograms' axis can be defined as ""time axis"". To do that it is enough; to activate the `SetTimeDisplay` attribute on a given axis. If `h` is a; histogram, it is done the following way:. ``` {.cpp}; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; ```. Two parameters can be adjusted in order to define time axis: the time; format and the time offset. #### Time Format. It defines the format of the labels along the time axis. It can be; changed using the **`TAxis`** method `SetTimeFormat`. The time format is; the one used by the C function `strftime()`. It is a string containing; the following formatting characters:. +-----------------+----------------------------------------------------------+; | For the date: | %a abbreviated weekday name |; | | |; | | %b abbreviated month name |; | | |; | | %d day of the month (01-31) |; | | |; | | %m month (01-12) |;",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:58215,Performance,optimiz,optimization,58215,"ripped. In the; following, we have some parameters, like tick marks length and; characters height (in percentage of the length of the axis, in user; coordinates). The default values are as follows:. - Primary tick marks: 3.0 %. - Secondary tick marks: 1.5 %. - Third order tick marks: .75 %. - Characters height for labels: 4%. - Labels offset: 1.0 %. #### Stripping Decimals. Use the `TStyle::SetStripDecimals` to strip decimals when drawing axis; labels. By default, the option is set to true, and `TGaxis::PaintAxis`; removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5,; 1, 1.5, 2, 2.5, etc.}. ``` {.cpp}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); ```. If this function is called with `strip=kFALSE`, `TGaxis::PaintAxis()`; will draw labels with the same number of digits after the dot, e.g.; {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}. #### Optional Grid. `chopt = 'W'`: cross-Wire. #### Axis Binning Optimization. By default, the axis binning is optimized. - `chopt = 'N'`: No binning optimization. - `chopt = 'I'`: Integer labeling. ### Axis with Time Units. Histograms' axis can be defined as ""time axis"". To do that it is enough; to activate the `SetTimeDisplay` attribute on a given axis. If `h` is a; histogram, it is done the following way:. ``` {.cpp}; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; ```. Two parameters can be adjusted in order to define time axis: the time; format and the time offset. #### Time Format. It defines the format of the labels along the time axis. It can be; changed using the **`TAxis`** method `SetTimeFormat`. The time format is; the one used by the C function `strftime()`. It is a string containing; the following formatting characters:. +-----------------+----------------------------------------------------------+; | For the date: | %a abbreviated weekday name |; | | |; | | %b abbreviated month name |; | | |; | | %d day of the month (01-31) |; | | |; | | %m month (01-12) |; | | |; | | %y year without century |; | |",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:70674,Performance,scalab,scalable,70674,"alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horizontal. ``` {.cpp}; root[] la->SetTextAngle(angle); ```. #### Setting Text Color. Use `TAttText::SetTextColor` to set the text color. The `color` is the; color index. The colors are described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `fo",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:70743,Performance,scalab,scalable,70743," = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horizontal. ``` {.cpp}; root[] la->SetTextAngle(angle); ```. #### Setting Text Color. Use `TAttText::SetTextColor` to set the text color. The `color` is the; color index. The colors are described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `font = 62` is the font with ID `6` and precision `2`. ![Font's ex",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:71190,Performance,scalab,scalable,71190,"e described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `font = 62` is the font with ID `6` and precision `2`. ![Font's examples](pictures/030000CF.png). The available fonts are:. +-----------+--------------------------+-----------------------+---------+------------+; | Font ID | X11 | True Type name | Is | ""boldness"" |; | | | | italic | |; +-----------+--------------------------+-----------------------+---------+------------+; | 1 | times-medium-i-normal | ""Times New Roman"" | Yes | 4 |; +-----------+--------------------------+--------------",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84737,Performance,optimiz,optimized,84737,".txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You ca",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:90190,Performance,scalab,scalable,90190,"o the top left corner of the target canvas you would have to reset the; coordinates of the cloned pad. ## Legends. Legends for a graph are obtained with a **`TLegend`** object. This; object points to markers, lines, boxes, histograms, graphs and represent; their marker, line, fill attributes. Any object that has a marker or; line or fill attribute may have an associated legend. A **`TLegend`** is; a panel with several entries (class **`TLegendEntry`**) and is created; by the constructor. ``` {.cpp}; TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; const char *header, Option_t *option); ```. The legend is defined with default coordinates, border size and option.; The legend coordinates (NDC) in the current pad are `x1`, `y1`, `x2`,; `y2`. The default text attributes for the legend are:. - Alignment = 12 left adjusted and vertically centered. - Angle = 0 (degrees). - Color = 1 (black). - Size = calculate when number of entries is known. - Font = helvetica-medium-r-normal scalable font = 42, and bold = 62; for title. The title is a regular entry and supports **`TLatex`**. The default is; no title (`header = 0`). The options are the same as for **`TPave`**; by; default, they are ""`brand`"". Once the legend box is created, one has to; add the text with the `AddEntry()` method:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); ```. The parameters are:. - `*obj `is a pointer to an object having marker, line, or fill; attributes (a histogram, or a graph). - `label` is the label to be associated to the object. - `option`:. - ""L"" draw line associated with line attributes of `obj`, if `obj`; inherits from **`TAttLine`**. - ""P"" draw poly-marker associated with marker attributes of `obj`, if; `obj` inherits **`TAttMarker`**. - ""F"" draw a box with fill associated with fill attributes of `obj`,; if `obj` inherits **`TAttFill`**. One may also use the other form of the method `AddEntry`:. ``` {.cpp}; TLegendEntry* TLegend::A",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105258,Performance,perform,performance,105258,"icular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in your chosen viewer. ### Invoking a 3D viewer. A 3D viewer can be created in a script b",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:107265,Performance,perform,performance,107265," passing the appropriate option; to `Draw() `when attaching the drawn object(s) to a pad. For a fuller; explanation of pads, attaching objects with `Draw()` etc. refer to; ""Graphical Containers: Canvas and Pad"". ``` {.cpp}; root[] myShapes->Draw(""ogl"");; ```. Valid option strings are:. - ""`ogl`"" : external GL viewer. - ""`x3d`"": external X3D viewer. - ""`pad`"": pad viewer. If no option is passed to `Draw()` then the ""`pad`"" is used by default.; If you already have content in a pad, which you would like to display in; one of the external viewers you can select from the canvas View menu /; View With, and pick the viewer type. ![Invoking external 3D viewers from canvas menus](pictures/030000D9.png). Note: A current limitation means that when an external viewer is created; the pad is no longer redrawn. When the external viewer is closed,; clicking in the pad will refresh. ### The GL Viewer. The GL Viewer uses <OpenGL®> (or compliant libraries such as <Mesa3D>); to generate high quality, high-performance 3D renderings, with; sophisticated lighting, materials and rendering styles for 3D scenes.; Many users will be able to take advantage of hardware acceleration of; the underlying OpenGL commands by their computer's video card, resulting; is considerable performance gains - up to interactive manipulation of; 1000's of complex shapes in real-time. The GL Viewer is supported on all official ROOT platforms (assuming you; have suitable <OpenGL®> libraries), and is the main 3D viewer, which; development effort is concentrated upon. As OpenGL® is a trademark we; refer to our viewer built on this technology as the ‘GL Viewer'. The; code for it can be found under `$ROOTSYS/gl`. ![The GL 3D Viewer](pictures/020000DA.jpg). You can manipulate the viewer via the GUI or via the base; **`TGLViewer`** object behind the interface. These are detailed below -; see also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Projections Modes (Cameras). The GL Viewer supports two basic types of camer",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:107530,Performance,perform,performance,107530,"myShapes->Draw(""ogl"");; ```. Valid option strings are:. - ""`ogl`"" : external GL viewer. - ""`x3d`"": external X3D viewer. - ""`pad`"": pad viewer. If no option is passed to `Draw()` then the ""`pad`"" is used by default.; If you already have content in a pad, which you would like to display in; one of the external viewers you can select from the canvas View menu /; View With, and pick the viewer type. ![Invoking external 3D viewers from canvas menus](pictures/030000D9.png). Note: A current limitation means that when an external viewer is created; the pad is no longer redrawn. When the external viewer is closed,; clicking in the pad will refresh. ### The GL Viewer. The GL Viewer uses <OpenGL®> (or compliant libraries such as <Mesa3D>); to generate high quality, high-performance 3D renderings, with; sophisticated lighting, materials and rendering styles for 3D scenes.; Many users will be able to take advantage of hardware acceleration of; the underlying OpenGL commands by their computer's video card, resulting; is considerable performance gains - up to interactive manipulation of; 1000's of complex shapes in real-time. The GL Viewer is supported on all official ROOT platforms (assuming you; have suitable <OpenGL®> libraries), and is the main 3D viewer, which; development effort is concentrated upon. As OpenGL® is a trademark we; refer to our viewer built on this technology as the ‘GL Viewer'. The; code for it can be found under `$ROOTSYS/gl`. ![The GL 3D Viewer](pictures/020000DA.jpg). You can manipulate the viewer via the GUI or via the base; **`TGLViewer`** object behind the interface. These are detailed below -; see also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Projections Modes (Cameras). The GL Viewer supports two basic types of camera, which affect how the; 3D world is projected onto the 2D render area:. - Perspective: Objects are drawn with characteristic ‘foreshortening'; effect, where distant objects appear smaller than near ones. This is; useful for obtain",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:116752,Performance,perform,perform,116752,"`**. ``` {.cpp}; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; ```. Configure the clip object with **`TGLClipSet::SetClipState`**. ``` {.cpp}; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; ```. As with cameras, any clip can be configured at any time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under the ""Guides"" tab:. Viewer Controls Pane Guides Tab. Axes show the world (global) frame *coordinate*directions: X (red), Y; (green) and Z (blue). The negative portion of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121198,Performance,perform,performance,121198," green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects f",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:124545,Performance,perform,perform,124545," // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; viewers free of viewer specific drawing code. They allow our simple x3d; viewer, and considerably more sophisticated OpenGL one to both work with; both geometry libraries (`g3d` and `geom`) efficiently. In addition to external viewers, created in separate windows, this; architecture is also used by internal **`TPad`** drawing when it; requires 3D projections. Publishing to a viewer consists of the; following steps:. 1- Create / obtain viewer handle. 2- Begin scene on viewer. 3- Fill mandatory parts of TBuffer3D describing object. 4- Add to viewer. 5- Fill optional parts of TBuffer3D as requested by viewer. [ .... repeat 3/4/5 as required for other/child objects]. 6- End scene on viewer. You should attach the top-level node of your external geometry (or the; manager) to a **`TPad`** object using **`TObject::Draw()`, and perform; the publishing to the viewer in your object's `TObject::Paint()`; overloaded method. See ""Scene Rebuilds"", and example scripts, for more; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in the future). You can create or obtain the current; viewer handle via the method:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; ```. Here the ""type"" string defines the viewer type - currently one of:. - ""`ogl`"" : External GL viewer. - ""`x3d`"": External X3D viewer. - ""`pad`"": Pad viewer. If no type is passed (null string), and there is no current viewer, then; the type is defaulted to ""`pad`"". If no type is passed and there is a; current viewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer betwee",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:125702,Performance,perform,perform,125702,"; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in the future). You can create or obtain the current; viewer handle via the method:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; ```. Here the ""type"" string defines the viewer type - currently one of:. - ""`ogl`"" : External GL viewer. - ""`x3d`"": External X3D viewer. - ""`pad`"": Pad viewer. If no type is passed (null string), and there is no current viewer, then; the type is defaulted to ""`pad`"". If no type is passed and there is a; current viewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:128926,Performance,perform,perform,128926,"ved classes, allowing a more; abstract shape description (""a sphere of inner radius x, outer radius; y""). This enables a viewer, which knows how to draw (tessellate) the; shape itself to do so, while providing a generic fallback suitable for; all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized **`TBuffer3D`** class exists, use it,; otherwise use **`TBuffer3D`**. - Complete the mandatory `kCore` section. - Complete the `kShapeSpecific` section if applicable. - Complete the `kBoundingBox` if you can. - Pass this buffer to the viewer using one of the; `TBuffer3D::AddObject()` methods. If the viewer requires more sections to be completed (`kRaw/kRawSizes`); `TBuffer3D::AddObject()` will return flags indicating which ones,; otherwise it returns `kNone`. If requested, you must fill the buffer,; mark these sections valid, and call `TBuffer3D::AddObject` again, to; complete adding the object. For example, in out **`TGeo`** geometry; package, in `TGeoPainter::PaintShape`, we perform the negotiation with; viewer:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; if (shape.IsA() != TGeoCompositeShape::Class()) {; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and adding; // it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific, localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; // If the viewer requires additional sections fetch from the; // shape (if possible) and add again; if (reqSections != TBuffer3D::kNone) {; shape.GetBuffer3D(reqSections, localFrame);; viewer->AddObject(buffer, &addDaughters);; }; }; ```. The buffer is supplied/filled by the appropriate `TShape::GetBuffer3D()`; and **`TShape::FillBuffer3D` overloads e.g. for a sphere in; `TGeoSphere`**. ``` {.cpp}; const TBuffer3D &TGeoSphere::GetBuffer3D(Int_t reqSe",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135054,Performance,cache,cached,135054,"buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logica",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135152,Performance,perform,perform,135152,"gical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **ea",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135224,Performance,perform,performance,135224,"gical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **ea",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:136706,Performance,cache,cached,136706,"ort local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **each** physical object. As **a minimum requirement** all clients must be capable of filling the; raw tessellation of the object buffer, in the master reference frame.; Conversely viewers must always be capable of displaying the object; described by this buffer. If either does not meet this requirement the; object may not be displayed. #### Scene Rebuilds. `TBuffer3D::AddObject` is not an explicit command to the viewer - it may; for various reasons decide to ignore it:. - It already has the object internally cached. - The object falls outside some 'interest' limits of the viewer; camera. - The object is too small to be worth drawing. In all these cases `TBuffer3D::AddObject()` returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * a",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:137459,Performance,perform,perform,137459,"laying the object; described by this buffer. If either does not meet this requirement the; object may not be displayed. #### Scene Rebuilds. `TBuffer3D::AddObject` is not an explicit command to the viewer - it may; for various reasons decide to ignore it:. - It already has the object internally cached. - The object falls outside some 'interest' limits of the viewer; camera. - The object is too small to be worth drawing. In all these cases `TBuffer3D::AddObject()` returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:138295,Performance,cache,cache,138295," repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, e",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:139508,Performance,perform,performed,139508,"ct::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, examine the code under; `$ROOTSYS/geom` - in particular **`TGeoShape`** hierarchy, and the; painter object **`TGeoPainter`** (under geopainter) where the; negotiation with the viewer is performed.; ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7623,Safety,safe,safe,7623,"o use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog di",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:30946,Safety,avoid,avoid,30946,"x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphica",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:34945,Safety,avoid,avoided,34945,"ints in a 2D space. Its constructor is:. ``` {.cpp}; TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option); ```. Where `n` is the number of points, and `x` and `y` are arrays of `n`; elements with the coordinates of the points. **`TPolyLine`** can be used; by it self, but is also a base class for other objects, such as curly; arcs. ### Circles and Ellipses. An ellipse can be truncated and rotated. It is defined by its center; `(x1,y1)` and two radii `r1` and `r2`. A minimum and maximum angle may; be specified `(phimin,phimax)`. The ellipse may be rotated with an angle; `theta`. All these angles are in degrees. The attributes of the outline; line are set via **`TAttLine`**, of the fill area - via **`TAttFill`**; class. They are described in ""Graphical Objects Attributes"". ![Different types of ellipses](pictures/030000AE.png). When an ellipse sector is drawn only, the lines between the center and; the end points of the sector are drawn by default. By specifying the; drawn option ""`only`"", these lines can be avoided. Alternatively, the; method `SetNoEdges()` can be called. To remove completely the ellipse; outline, specify zero (0) as a line style. The **`TEllipse`** constructor is:. ``` {.cpp}; TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,; Double_t phimin, Double_t phimax, Double_t theta); ```. An ellipse may be created with:. ``` {.cpp}; root[] e = new TEllipse(0.2,0.2,0.8,0.3); root[] e->Draw(); ```. ### Rectangles. The class **`TBox`** defines a rectangle. It is a base class for many; different higher-level graphical primitives. Its bottom left coordinates; `x1`, `y1` and its top right coordinates `x2`, `y2`, defines a box. The; constructor is:. ``` {.cpp}; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. It may be used as in:. ``` {.cpp}; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(); ```. ![A rectangle with a border](pictures/020000AF.jpg). A **`TWbox`** is a rectangle (**`TBox`**) with a border",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:96512,Safety,detect,detect,96512,"ustrated in several scripts referenced by the **`TPostScript`**; constructor. ### Writing Several Canvases to the Same PostScript File. The following sequence writes the canvas to ""`c1.ps`"" and closes the; postscript file:. ``` {.cpp}; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; ```. If the Postscript file name finishes with ""`(`"", the file remains opened; (it is not closed). If the Postscript file name finishes with ""`)`"" and; the file has been opened with ""`(`"", the file is closed. ``` {.cpp}; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; ```. The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated; in some loop, one needs to detect the special cases of first and last; page. The ""`[`"" and ""`]`"" can be used instead of ""`(`"" and ""`)`"" as; shown in the next example. ``` {.cpp}; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; ```. The following script illustrates how to open a postscript file and draw; several pictures. The generation of a new postscript page is automatic; when **`TCanvas::Clear` is called by `object->Draw()`.**. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:131438,Safety,avoid,avoids,131438,"uffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; }; // Complete kRaw tesselation section; if ((reqSections & TBuffer3D::kRaw) &&; buffer.SectionsValid(TBuffer3D::kRawSizes)) {; SetPoints(buffer.fPnts);; // Transform points to master frame if viewer requires it; // The fLocalFrame flag and translation matrix will have; // already been set in TGeoShape::FillBuffer3D() as required; if (!buffer.fLocalFrame); TransformPoints(buffer.fPnts, buffer.NbPnts());; SetSegsAndPols(buffer);; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; return buffer;; }; ```. Note:. - we use a static **`TBuffer3D`** derived object for efficiency - once; the object is added the buffer can be reused. - `kRawSize` (the calculation of tessellation sizing required in; buffer) and `kRaw` (the actual filling of tessellation) is split, as; the X3D viewer requires two publication passes - one to establish; the full tessellation capacity for all shapes, and another to; actually add them. Splitting avoids having to do the expensive; tessellation on the first pass. #### Shape Specific TBuffer3D Derived Classes. Currently we provide the following shape specific classes, which the GL; Viewer can take advantage of (see `TBuffer3D.h` and `TBuffer3DTypes.h`). - **`TBuffer3DSphere`** - solid, hollow and cut spheres (GL Viewer; only supports solid spheres at present - cut / hollow ones will be; requested as tessellated objects by client.). - **`TBuffer3DTube`** - basic tube with inner/outer radius and length. - **`TBuffer3DTubeSeg`** - angle tube segment. - **`TBuffer3DCutTube`** - angle tube segment with plane cut ends. See the above example from `TGeoSphere::GetBuffer3D` and also equivalent; functions in **`TGeoTube`**, **`TGeoTubeSeg`** and **`TGeoCtub`**.; Anyone is free to add new **`TBuffer3D`** classes, but it should be; clear that one or more viewers will require updating to be able to take; advantage of them. Hence we only provide classes which existing viewers; can benefit from. The number of native shape",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:138288,Safety,safe,safely,138288," repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, e",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:15253,Security,access,access,15253,"When is the painting done then ? The answer is: when needed. Every object; that derives from **`TObject`** has a `Paint()` method. It may be empty,; but for graphical objects, this routine contains all the instructions to; paint effectively it in the active pad. Since a Pad has the list of; objects it owns, it will call successively the `Paint()` method of each; object, thus re-painting the whole pad on the screen. If the object is a; sub-pad, its `Paint()` method will call the `Paint()` method of the; objects attached, recursively calling `Paint()` for all the objects. ![Pad painting](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e. `TPad::GetPrimitive(const char* name)` does exactly this. Since; most of the objects that a pad contains derive from **`TObject`**, they; have a name. The following statement will return a pointer to the object; `myobjectname` and put that pointer into the variable `obj`. As y",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:15891,Security,access,access,15891,"ing](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e. `TPad::GetPrimitive(const char* name)` does exactly this. Since; most of the objects that a pad contains derive from **`TObject`**, they; have a name. The following statement will return a pointer to the object; `myobjectname` and put that pointer into the variable `obj`. As you can; see, the type of returned pointer is `TObject*`. ``` {.cpp}; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; ```. Even if your object is something more complicated, like a histogram; **`TH1F`**, this is normal. A function cannot return more than one type.; So the one chosen was the lowest common denominator to all possible; classes, the class from which everything derives, **`TObject`**. How do; we get the right pointer then? Simply do a cast of the function output; that will transform the output (pointer) into the right type. For; example if th",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:17815,Security,access,accessible,17815,"ct is a **`TPaveLabel`**:. ``` {.cpp}; root[] obj = (TPaveLabel*)(gPad->GetPrimitive(""myobjectname"")); (class TPaveLabel*)0x1063cba8; ```. This works for all objects deriving from **`TObject`**. However, a; question remains. An object has a name if it derives from **`TNamed`**,; not from **`TObject`**. For example, an arrow (**`TArrow`**) doesn't; have a name. In that case, the ""name"" is the name of the class. To know; the name of an object, just click with the right button on it. The name; appears at the top of the context menu. In case of multiple unnamed; objects, a call to `GetPrimitive(""className"")` returns the instance of; the class that was first created. To retrieve a later instance you can; use `GetListOfPrimitives()`, which returns a list of all the objects on; the pad. From the list you can select the object you need. #### Hiding an Object. Hiding an object in a pad can be made by removing it from the list of; objects owned by that pad. This list is accessible by the; `GetListOfPrimitives()` method of **`TPad`**. This method returns a; pointer to a **`TList`**. Suppose we get the pointer to the object, we; want to hide, call it `obj` (see paragraph above). We get the pointer to; the list:. ``` {.cpp}; root[] li = gPad->GetListOfPrimitives(); ```. Then remove the object from this list:. ``` {.cpp}; root[] li->Remove(obj); ```. The object will disappear from the pad as soon as the pad is updated; (try to resize it for example). If one wants to make the object; reappear:. ``` {.cpp}; root[] obj->Draw(); ```. Caution, this will not work with composed objects, for example many; histograms drawn on the same plot (with the option ""`same`""). There are; other ways! Try to use the method described here for simple objects. ### The Coordinate Systems of a Pad. There are coordinate systems in a **`TPad`**: user coordinates,; normalized coordinates (NDC), and pixel coordinates. ![Pad coordinate systems](pictures/080000A3.png). #### The User Coordinate System. The most ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25621,Security,access,access,25621,"s system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for exa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:27019,Security,access,access,27019,"ich are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for example the; name and title of an object. - You can also set the ""bit-modified"" explicitly with the `Modified`; method:. ``` {.cpp}; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modified()`, and follow it with a; `canvas->Update()`. If you use `canvas->Modified()`, followed by a call; to `canvas->Update()`, the sub pad has not been declared modified and it; will not be updated. Also note that a call to `pa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:49469,Security,access,access,49469,"e; following constructor: By default, the number of stacked panels is 5,; `option=`""`br`"". ``` {.cpp}; TPavesText(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; Int_t npaves, Option_t* option); ```. ![A PaveText example](pictures/030000C6.png). ### The TeX Processor TMathText. TMathText's purpose is to write mathematical equations, exactly as TeX; would do it. The syntax is the same as the TeX's one. The script `$ROOTSYS/tutorials/graphics/tmathtex.C`:. gives the following output:. ![A TMathText example](pictures/mathtext.png). `TMathText` uses plain TeX syntax and uses ""\\"" as control instead of; ""\#"". If a piece of text containing ""\\"" is given to `TLatex` then; `TMathText` is automatically invoked. Therefore, as histograms' titles,; axis titles, labels etc ... are drawn using `TLatex`, the `TMathText`; syntax can be used for them also. ## Axis. The axis objects are automatically built by various high level objects; such as histograms or graphs. Once build, one may access them and change; their characteristics. It is also possible, for some particular purposes; to build axis on their own. This may be useful for example in the case; one wants to draw two axis for the same plot, one on the left and one on; the right. For historical reasons, there are two classes representing axis.; **`TAxis`** \* `axis` is the axis object, which will be returned when; calling the `TH1::GetAxis()` method. ``` {.cpp}; TAxis *axis = histo->GetXaxis(); ```. Of course, you may do the same for `Y` and `Z`-axis. The graphical; representation of an axis is done with the **`TGaxis`** class. The; histogram classes and **`TGraph`** generate instances of this class.; This is internal and the user should not have to see it. ### Axis Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""What",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:79269,Security,access,accessed,79269,"0:hollow, 1001:solid, 2001:hatch style,; 3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully; transparent, 4100: fully opaque. Fill styles \>3100 and \<3999 are hatches. They are defined according to; the `FillStyle=3ijk` value as follows:. - `i(1-9)` specifies the space between each hatch `(1=minimum space`,; `9=maximum)`. The final spacing is set by `SetHatchesSpacing()`; method and it is`*GetHatchesSpacing()`. - `j(0-9)` specifies the angle between 0 and 90 degres as follows:; `0=0`, `1=10`, `2=20`, `3=30`, `4=45`, `5=not drawn`, `6=60`,; `7=70`, `8=80` and `9=90`. - `k(0-9)` specifies the angle between 0 and 90 degres as follows:; `0=180`, `1=170`, `2=160`, `3=150`, `4=135`, `5=not drawn`, `6=120`,; `7=110`, `8=100` and `9=90`. ![The various patterns](pictures/030000D2.png). ### Color and Color Palettes. At initialization time, a table of basic colors is generated when the; first Canvas constructor is called. This table is a linked list, which; can be accessed from the ***`gROOT`*** object (see; `TROOT::GetListOfColors()`). Each color has an index and when a basic; color is defined, two ""companion"" colors are defined: the dark version and the bright version.; Two static functions are available that return the bright or dark color number corresponding; to a given color index. If these variants don't already exist, they are created as needed:; ```; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; ```. The dark and bright colors are used to give 3-D effects when drawing; various boxes (see **`TWbox`**, **`TPave`**, **`TPaveText`**,; **`TPaveLabel`**, etc). If you have a black and white copy of the; manual, here are the basic colors and their indices. ![The basic ROOT colors](pictures/030000D3.png). ![](pictures/image212.jpg). The list of currently supported basic colors (here dark and bright; colors are not shown) are shown. The color numbers specified in the; basic palette, and the picture above, ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:6736,Testability,stub,stub,6736,"s methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:20472,Testability,log,log,20472,"ly created blank pad, one may use `TPad::Range` to set the user; coordinate system. This function is defined as:. ``` {.cpp}; void Range(float x1,float y1,float x2,float y2); ```. The arguments `x1`, `x2` defines the new range in the x direction, and; the `y1`, `y2` define the new range in the y-direction. ``` {.cpp}; root[] TCanvas MyCanvas (""MyCanvas""); root[] gPad->Range(-100,-100,100,100); ```. This will set the active pad to have both coordinates to go from -100 to; 100, with the center of the pad at (0,0). You can visually check the; coordinates by viewing the status bar in the canvas. To display the; status bar select Event Status entry in the View canvas menu. ![The status bar](pictures/020000A4.jpg). #### The Normalized Coordinate System (NDC). Normalized coordinates are independent of the window size and of the; user system. The coordinates range from 0 to 1 and (0, 0) corresponds to; the bottom-left corner of the pad. Several internal ROOT functions use; the NDC system (3D primitives, PostScript, log scale mapping to linear; scale). You may want to use this system if the user coordinates are not; known ahead of time. #### The Pixel Coordinate System. The least common is the pixel coordinate system, used by functions such; as `DistancetoPrimitive()` and `ExecuteEvent()`. Its primary use is for; cursor position, which is always given in pixel coordinates. If; (`px,py`) is the cursor position, `px=0` and `py=0` corresponds to the; top-left corner of the pad, which is the standard convention in; windowing systems. #### Using NDC for a particular Object. Most of the time, you will be using the user coordinate system. But; sometimes, you will want to use NDC. For example, if you want to draw; text always at the same place over a histogram, no matter what the; histogram coordinates are. There are two ways to do this. You can set; the NDC for one object or may convert NDC to user coordinates. Most; graphical objects offer an option to be drawn in NDC. For instance",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:29142,Testability,log,logarithmic,29142,"t. As we will see in the paragraph ""Fill Attributes"", a fill style (type of; hatching) may be set for a pad. ``` {.cpp}; root[] pad1->SetFillStyle(istyle); ```. This is done with the `SetFillStyle` method where `istyle` is a style; number, defined in ""Fill Attributes"". A special set of styles allows; handling of various levels of transparency. These are styles number 4000; to 4100, 4000 being fully transparent and 4100 fully opaque. So, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *newpad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:29345,Testability,log,log,29345,"[] pad1->SetFillStyle(istyle); ```. This is done with the `SetFillStyle` method where `istyle` is a style; number, defined in ""Fill Attributes"". A special set of styles allows; handling of various levels of transparency. These are styles number 4000; to 4100, 4000 being fully transparent and 4100 fully opaque. So, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *newpad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:29555,Testability,log,logic,29555,"o, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *newpad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); roo",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:29677,Testability,test,tested,29677,"o, suppose; you have an existing canvas with several pads. You create a new pad; (transparent) covering for example the entire canvas. Then you draw your; primitives in this pad. The same can be achieved with the graphics; editor. For example:. ``` {.cpp}; root[] .x tutorials/hist/h1draw.C; root[] TPad *newpad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); roo",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:29895,Testability,log,log,29895,"ansparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:30037,Testability,log,log,30037,"] // create some primitives, etc; ```. ### Setting the Log Scale. Setting the scale to logarithmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements l",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:30141,Testability,log,log,30141,"thmic or linear is an attribute of the pad,; not the axis or the histogram. The scale is an attribute of the pad; because you may want to draw the same histogram in linear scale in one; pad and in log scale in another pad. Frequently, we see several; histograms on top of each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running ma",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:30408,Testability,log,log,30408,"f each other in the same pad. It would be very; inconvenient to set the scale attribute for each histogram in a pad. Furthermore, if the logic was set in the histogram class (or each; object) the scale setting in each `Paint` method of all objects should; be tested. If you have a pad with a histogram, a right-click on the pad, outside of; the histograms frame will convince you. The `SetLogx()`, `SetLogy()` and; `SetLogz()` methods are there. As you see, **`TPad`** defines log scale; for the two directions `x` and `y` plus `z` if you want to draw a 3D; representation of some function or histogram. The way to set log scale in the x direction for the active pad is:. ``` {.cpp}; root[] gPad->SetLogx(1); ```. To reset log in the z direction:. ``` {.cpp}; root[] gPad->SetLogz(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects a",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:53909,Testability,log,logarithmic,53909,"is on the start, drag the cursor to; the end, and release the mouse button. ### Drawing Axis Independently of Graphs or Histograms. An axis may be drawn independently of a histogram or a graph. This may; be useful to draw for example a supplementary axis for a graph. In this; case, one has to use the **`TGaxis`** class, the graphical; representation of an axis. One may use the standard constructor for this; kind of objects:. ``` {.cpp}; TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; Double_t wmin, Double_t wmax, Int_t ndiv = 510,; Option_t* chopt,Double_t gridlength = 0); ```. The arguments `xmin, ymin` are the coordinates of the axis' start in the; user coordinates system, `and xmax, ymax` are the end coordinates. The; arguments `wmin` and `wmax` are the minimum (at the start) and maximum; (at the end) values to be represented on the axis; `ndiv` is the number; of divisions. The options, given by the ""`chopt`"" string are the; following:. - `chopt = 'G'`: logarithmic scale, default is linear. - `chopt = 'B'`: Blank axis (it is useful to superpose the axis). Instead of the `wmin,wmax` arguments of the normal constructor, i.e. the; limits of the axis, the name of a **`TF1`** function can be specified.; This function will be used to map the user coordinates to the axis; values and ticks. The constructor is the following:. ``` {.cpp}; TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; const char* funcname, Int_t ndiv=510,; Option_t* chopt, Double_t gridlength=0); ```. In such a way, it is possible to obtain exponential evolution of the; tick marks position, or even decreasing. In fact, anything you like. ### Orientation of Tick Marks on Axis. Tick marks are normally drawn on the positive side of the axis, however,; if `xmin = xmax`, then negative. - `chopt = '+': ` tick marks are drawn on Positive side. (Default). - `chopt = '-': ` tick marks are drawn on the negative side. - `chopt = '+-':` tick marks are drawn on both sides of the ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:63298,Testability,test,test,63298,"h.Convert());; ht3->Draw();; }; ```. The output is shown in the figure below. If a time axis has no specified; time offset, the global time offset will be stored in the axis data; structure. The histogram limits are in seconds. If `wmin` and `wmax` are; the histogram limits, the time axis will spread around the time offset; value from `TimeOffset+wmin` to `TimeOffset+wmax`. Until now all; examples had a lowest value equal to 0. The following example; demonstrates how to define the histogram limits relatively to the time; offset value. ![Time axis examples](pictures/030000C8.png). ``` {.cpp}; {; // Define the time offset as 2003, January 1st; TDatime T0(2003,01,01,00,00,00);; int X0 = T0.Convert();; gStyle->SetTimeOffset(X0);. // Define the lowest histogram limit as 2002,September 23rd; TDatime T1(2002,09,23,00,00,00);; int X1 = T1.Convert()-X0;. // Define the highest histogram limit as 2003, March 7th; TDatime T2(2003,03,07,00,00,00);; int X2 = T2.Convert(1)-X0;. TH1F * h1 = new TH1F(""h1"",""test"",100,X1,X2);. TRandom r;; for (Int_t i=0;i<30000;i++) {; Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));; h1->Fill(noise);; }. h1->GetXaxis()->SetTimeDisplay(1);; h1->GetXaxis()->SetLabelSize(0.03);; h1->GetXaxis()->SetTimeFormat(""%Y/%m/%d"");; h1->Draw();; }; ```. The output is shown in the next figure. Usually time axes are created; automatically via histograms, but one may also want to draw a time axis; outside a ""histogram context"". Therefore, it is useful to understand how; **`TGaxis`** works for such axis. The time offset can be defined using; one of the three methods described before. The time axis will spread; around the time offset value. Actually, it will go from; `TimeOffset+wmin` to `TimeOffset+wmax` where `wmin` and `wmax` are the; minimum and maximum values (in seconds) of the axis. Let us take again; an example. Having defined ""2003, February 28 at 12h"", we would like to; see the axis a day before and a day after. ![A histogram with time axis X](pictures/03000",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:67549,Testability,log,logarithmic,67549,"etName(""axis7"");; axis7->SetLabelOffset(0.01);; axis7->Draw();. // one can make axis top->bottom. However because of a problem,; // the two x values should not be equal; TGaxis *axis8 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis8->SetName(""axis8"");; axis8->Draw();; }; ```. ![The second axis example](pictures/030000CD.png). The second example shows the use of the second form of the constructor,; with axis ticks position determined by a function **`TF1`**:. ``` {.cpp}; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",2,0,10,2,-2,2);; h2->Draw();; TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",0,800);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505);; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }; ```. ![An axis example with time display](pictures/030000CE.png). ``` {.cpp}; // strip chart example; void seism() {. TStopwatch sw; sw.Start();; //set time offset; TDatime dtime;; gStyle->SetTimeOffset(dtime.Convert());; TCanvas *c1 = new TCanvas(""c1"",""Time on axis"",10,10,1000,500);; c1->SetFillColor(42);; c1->SetFrameFillColor(33);; c1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp(",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84666,Testability,log,logarithmic,84666,".txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You ca",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84755,Testability,log,logarithmic,84755,".txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You ca",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:97402,Testability,test,test,97402,"he action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated; in some loop, one needs to detect the special cases of first and last; page. The ""`[`"" and ""`]`"" can be used instead of ""`(`"" and ""`)`"" as; shown in the next example. ``` {.cpp}; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; ```. The following script illustrates how to open a postscript file and draw; several pictures. The generation of a new postscript page is automatic; when **`TCanvas::Clear` is called by `object->Draw()`.**. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows two pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new picture.; `object->Draw` does not clear the canvas in this case because we clear; only the pads and not the main canvas. Note that `c1->Update` must be; called at the end of the first picture. ``` {.cpp}; {",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:100716,Testability,test,test,100716,";; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);; ```. ``CMYK`` add the black component which allows to have a better quality; for black printing. `TPostScript` (and `TPDF`) support the ``CMYK`` model.; To change the color model use:. ``` {.cpp}; gStyle->SetColorModelPS(c);; ```. - `c = 0` means TPostScript will use RGB color model (default); - `c = 1` means TPostScript will use CMYK color model. ## The PDF Interface. Like PostScript, PDF is a vector graphics output format allowing a very; high graphics output quality. The functionalities provided by this class; are very similar to those provided by `TPostScript`. Compare to PostScript output, the PDF files are usually smaller because; some parts of them can be compressed. PDF also allows to define table of contents. This facility can be used; in ROOT. The following example shows how to proceed:. ``` {.cpp}; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the glob",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:122597,Testability,log,logical,122597," b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kN",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:122757,Testability,test,test,122757,"6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; vi",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:125906,Testability,test,test,125906,"}; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; ```. Here the ""type"" string defines the viewer type - currently one of:. - ""`ogl`"" : External GL viewer. - ""`x3d`"": External X3D viewer. - ""`pad`"": Pad viewer. If no type is passed (null string), and there is no current viewer, then; the type is defaulted to ""`pad`"". If no type is passed and there is a; current viewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Addition",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:127482,Testability,test,test,127482,"ription. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`, `kRaw` - see the class diagram and; the file `TBuffer3D.h` for more details. The **`TBuffer3D`** methods; `SectionsValid()`, `SetSectionsValid()`, `ClearSectionsValid()` are used; to test, set, clear these section validity flags e.g. ``` {.cpp}; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; ...; if (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {; ...; }; ```. The sections found in the base **`TBuffer3D`**; (`kCore/kBoundingBox/kRawSizes/kRaw`) are sufficient to describe any; tessellated shape in a generic fashion. An additional `kShapeSpecific`; section is added in **`TBuffer3D`** derived classes, allowing a more; abstract shape description (""a sphere of inner radius x, outer radius; y""). This enables a viewer, which knows how to draw (tessellate) the; shape itself to do so, while providing a generic fallback suitable for; all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized **`TBuffer3D`** class exists, use it,; otherwise use **`TBuffer3D`**. - Complete the mandatory `kCore` section. - Complete the `kShapeSpecific` section if applicable. - Complete the `kBoundingBox` if you can. - Pa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:134922,Testability,log,logical,134922," {.cpp}; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:134952,Testability,log,logical,134952," {.cpp}; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135290,Testability,log,logical,135290,"rence; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **each** physical object. As **a minimum requirement** all clients must be capable of filling the; raw tessellation of the object buffer, in the mast",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:135974,Testability,log,logical,135974,"e `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **each** physical object. As **a minimum requirement** all clients must be capable of filling the; raw tessellation of the object buffer, in the master reference frame.; Conversely viewers must always be capable of displaying the object; described by this buffer. If either does not meet this requirement the; object may not be displayed. #### Scene Rebuilds. `TBuffer3D::AddObject` is not an explicit command to the viewer - it may; for various reasons decide to ignore it:. - It already has the object internally cached. - The object falls outside some 'interest' limits of the viewer; camera. - The object is too small to be worth drawing. In all these cases `TBuffer3D::AddObject()` returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:136055,Testability,log,logical,136055,"e `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID`, and different `fLocalMaster`; placements. For viewers supporting logical/physical objects, the TBuffer3D content; refers to the properties of the logical object, with the exception of:. - `fLocalMaster` transform. - `fColor `. - `fTransparency`. attributes, which can be varied for **each** physical object. As **a minimum requirement** all clients must be capable of filling the; raw tessellation of the object buffer, in the master reference frame.; Conversely viewers must always be capable of displaying the object; described by this buffer. If either does not meet this requirement the; object may not be displayed. #### Scene Rebuilds. `TBuffer3D::AddObject` is not an explicit command to the viewer - it may; for various reasons decide to ignore it:. - It already has the object internally cached. - The object falls outside some 'interest' limits of the viewer; camera. - The object is too small to be worth drawing. In all these cases `TBuffer3D::AddObject()` returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:137859,Testability,log,logical,137859,"returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has b",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:139260,Testability,log,logical,139260,"ct::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, examine the code under; `$ROOTSYS/geom` - in particular **`TGeoShape`** hierarchy, and the; painter object **`TGeoPainter`** (under geopainter) where the; negotiation with the viewer is performed.; ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:4649,Usability,simpl,simple,4649,"ean they are reordered to be on top of the others. To; interactively make an object ""active"", you can use the middle mouse; button. In case of canvases or pads, the border becomes highlighted when; it is active. #### With C++ Statements (Programmatically). Frequently we want to draw in different canvases or pads. By default,; the objects are drawn in the active canvas. To activate a canvas you can; use the `TPad::cd()` method. ``` {.cpp}; root[] c1->cd(); ```. ### Context Menus: the Right Mouse Button. The context menus are a way to interactively call certain methods of an; object. When designing a class, the programmer can add methods to the; context menu of the object by making minor changes to the header file. #### Using Context Menus. On a ROOT canvas, you can right-click on any object and see the context; menu for it. The script `hsimple.C` draws a histogram. The image below; shows the context menus for some of the objects on the canvas. Next; picture shows that drawing a simple histogram involves as many as seven; objects. When selecting a method from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:18577,Usability,simpl,simple,18577," `GetListOfPrimitives()`, which returns a list of all the objects on; the pad. From the list you can select the object you need. #### Hiding an Object. Hiding an object in a pad can be made by removing it from the list of; objects owned by that pad. This list is accessible by the; `GetListOfPrimitives()` method of **`TPad`**. This method returns a; pointer to a **`TList`**. Suppose we get the pointer to the object, we; want to hide, call it `obj` (see paragraph above). We get the pointer to; the list:. ``` {.cpp}; root[] li = gPad->GetListOfPrimitives(); ```. Then remove the object from this list:. ``` {.cpp}; root[] li->Remove(obj); ```. The object will disappear from the pad as soon as the pad is updated; (try to resize it for example). If one wants to make the object; reappear:. ``` {.cpp}; root[] obj->Draw(); ```. Caution, this will not work with composed objects, for example many; histograms drawn on the same plot (with the option ""`same`""). There are; other ways! Try to use the method described here for simple objects. ### The Coordinate Systems of a Pad. There are coordinate systems in a **`TPad`**: user coordinates,; normalized coordinates (NDC), and pixel coordinates. ![Pad coordinate systems](pictures/080000A3.png). #### The User Coordinate System. The most common is the user coordinate system. Most methods of; **`TPad`** use the user coordinates, and all graphic primitives have; their parameters defined in terms of user coordinates. By default, when; an empty pad is drawn, the user coordinates are set to a range from 0 to; 1 starting at the lower left corner. At this point they are equivalent; of the NDC coordinates (see below). If you draw a high level graphical; object, such as a histogram or a function, the user coordinates are set; to the coordinates of the histogram. Therefore, when you set a point it; will be in the histogram coordinates. For a newly created blank pad, one may use `TPad::Range` to set the user; coordinate system. This function is de",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:24048,Usability,simpl,simplest,24048,"eltoX(apx)` | Double\_t |; | user | | |; | | `AbsPixeltoY(apy)` | Double\_t |; | | | |; | | `AbsPixeltoXY(apx,apy,&ux,&uy)` | Double\_t ux,uy |; +-----------------------+----------------------------------+--------------------+. Note: all the pixel conversion functions along the Y axis consider that; `py=0` is at the top of the pad except `PixeltoY()` which assume that; the position `py=0` is at the bottom of the pad. To make `PixeltoY()`; converting the same way as the other conversion functions, it should be; used the following way (`p` is a pointer to a **`TPad`**):. ``` {.cpp}; p->PixeltoY(py - p->GetWh());; ```. ### Dividing a Pad into Sub-pads. Dividing a pad into sub pads in order for instance to draw a few; histograms, may be done in two ways. The first is to build pad objects; and to draw them into a parent pad, which may be a canvas. The second is; to automatically divide a pad into horizontal and vertical sub pads. #### Creating a Single Sub-pad. The simplest way to divide a pad is to build sub-pads in it. However,; this forces the user to explicitly indicate the size and position of; those sub-pads. Suppose we want to build a sub-pad in the active pad; (pointed by ***`gPad`***). First, we build it, using a **`TPad`**; constructor:. ``` {.cpp}; root[] spad1 = new TPad(""spad1"",""The first subpad"",.1,.1,.5,.5); ```. One gives the coordinates of the lower left point (0.1, 0.1) and of the; upper right one (0.5, 0.5). These coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a giv",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31236,Usability,resume,resume,31236,"(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By defa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31633,Usability,simpl,simple,31633,"t[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By default 2D graphical objects; are created in User Coordinates with (0, 0) in the lower left corner. ### Lines, Arrows and Polylines. The simplest graphical object is a line. It is implemented in the; **`TLine`** class. The line constructor is:. ``` {.cpp}; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. The arguments `x1`, `y1`, `x2`, `y2` are the coordinates of the first; and second point. It can be used:. ``` {.cpp}; root",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:32331,Usability,simpl,simplest,32331,"-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By default 2D graphical objects; are created in User Coordinates with (0, 0) in the lower left corner. ### Lines, Arrows and Polylines. The simplest graphical object is a line. It is implemented in the; **`TLine`** class. The line constructor is:. ``` {.cpp}; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. The arguments `x1`, `y1`, `x2`, `y2` are the coordinates of the first; and second point. It can be used:. ``` {.cpp}; root[] l = new TLine(0.2,0.2,0.8,0.3); root[] l->Draw(); ```. The arrow constructor is:. ``` {.cpp}; TArrow(Double_t x1, Double_t y1,; Double_t x2, Double_t y2,; Float_t arrowsize, Option_t *option); ```. It defines an arrow between points `x1,y1` and `x2,y2`. The arrow size; is in percentage of the pad height. The `option` parameter has the; following meanings:. ![](pictures/020000A7.jpg) ""\>"". ![](pictures/020000A8.jpg) ""\<|"". ![](pictures/020000A9.jpg) ""\<"". ![](pictures/020000AA.jpg) ""|\>"". ![](pictures/020000AB.jpg) ""\<\>"". ![](pictures/020000AC.jpg) ""\<|\>"". Once an arrow is drawn on the screen, one can:. - click on one of the edges and move this edge. - click on any other arrow part to move the entire",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:50574,Usability,simpl,simply,50574,"d axis on their own. This may be useful for example in the case; one wants to draw two axis for the same plot, one on the left and one on; the right. For historical reasons, there are two classes representing axis.; **`TAxis`** \* `axis` is the axis object, which will be returned when; calling the `TH1::GetAxis()` method. ``` {.cpp}; TAxis *axis = histo->GetXaxis(); ```. Of course, you may do the same for `Y` and `Z`-axis. The graphical; representation of an axis is done with the **`TGaxis`** class. The; histogram classes and **`TGraph`** generate instances of this class.; This is internal and the user should not have to see it. ### Axis Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""Whatever title you want""); ```. ### Axis Options and Characteristics. The axis options are most simply set with the styles. The available; style options controlling specific axis options are the following:. ``` {.cpp}; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 10",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:94639,Usability,resume,resume,94639," Map Format. - ""`svg`"" a Scalable Vector Graphics file. - ""`tiff`"" a Tagged-Image File Format. - ""`root`""a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by; the filename extension what format you want to save a canvas in (i.e.; `canvas.ps`, `canvas.gif`, `canvas.C`, etc). The size of the PostScript picture, by default, is computed to keep the; aspect ratio of the picture on the screen, where the size along `x` is; always 20 cm. You can set the size of the PostScript picture before; generating the picture with a command such as:. ``` {.cpp}; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; ```. The first parameter in the **`TPostScript`** constructor is the name of; the file; the second one is the format option:. - 111 - `ps portrait`. - 112 - `ps landscape`. - 113 - `eps`. You can set the default paper size with:. ``` {.cpp}; gStyle->SetPaperSize(xsize,ysize);; ```. You can resume writing again in this file with `myps.Open()`. Note that; you may have several Post Script files opened simultaneously. Use; `TPostScript::Text(x,y,""string"")` to add text to a postscript file. This; method writes the string in quotes into a PostScript file at position; `x, y` in world coordinates. ### Special Characters. The following characters have a special action on the PostScript file:. - `` ` `` - go to Greek. - `'` - go to special. - `~` - go to Zapf Dingbats. - `?` - go to subscript. - `^` - go to superscript. - `!` - go to normal level of script. - `&` - backspace one character. - `#` - end of Greek or end of ZapfDingbats. These special characters are printed as such on the screen. To generate; one of these characters on the PostScript file, you must escape it with; the escape character ""@"". The use of these special characters is; illustrated in several scripts referenced by the **`TPostScript`**; constructor. ### Writing Several Canvases to the Same PostScript File. The following sequen",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:98199,Usability,clear,clear,98199,"t type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows two pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new picture.; `object->Draw` does not clear the canvas in this case because we clear; only the pads and not the main canvas. Note that `c1->Update` must be; called at the end of the first picture. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);. // picture 1; c1->Divide(2,1);; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();. // picture 2; c1->Update();; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke PostScript viewer; gSystem->Exec(""gs file.ps"");; }; ```. The next one does the same:. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; c1->Divide(2,1);. // picture 1; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Print(""test2.ps("", ""Landscape"");. // picture 2; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Print(""test2.ps)"");; gSystem->Exec(""gs file.ps""); // invoke PostScript viewer; }; ```; ### The Color Model",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:98240,Usability,clear,clear,98240,"t type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows two pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new picture.; `object->Draw` does not clear the canvas in this case because we clear; only the pads and not the main canvas. Note that `c1->Update` must be; called at the end of the first picture. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);. // picture 1; c1->Divide(2,1);; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();. // picture 2; c1->Update();; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke PostScript viewer; gSystem->Exec(""gs file.ps"");; }; ```. The next one does the same:. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; c1->Divide(2,1);. // picture 1; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Print(""test2.ps("", ""Landscape"");. // picture 2; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Print(""test2.ps)"");; gSystem->Exec(""gs file.ps""); // invoke PostScript viewer; }; ```; ### The Color Model",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:101913,Usability,simpl,simple,101913," bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the global variable; ***`gStyle`*** (in `TStyle.h`). See the class **`TStyle`** for a; complete list of the attributes that can be set in one style. ROOT provides several styles called:. - ""`Default`"" - the default style. - ""`Plain`"" - the simple style (black and white). - ""`Bold`"" - bolder lines. - ""`Video`"" - suitable for html output or screen viewing. The ""`Default`"" style is created by:. ``` {.cpp}; TStyle *default = new TStyle(""Default"",""Default Style"");; ```. The ""`Plain`"" style can be used if you want to get a ""conventional""; PostScript output or if you are working on a monochrome display. The; following example shows how to create it. ``` {.cpp}; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; plain->SetCanvasColor(0);; plain->SetTitleColor(0);; plain->SetStatColor(0);; ```. You can set the current style by:. ``` {.cpp}; gROOT->SetStyle(style_name);; ```. You can get a pointer to an existing style by:. ``` {.cpp}; TStyle *style = gROOT->GetStyle(style_name);; ```. You can create additional styles by:. ``` {.cpp}; TStyle *st1 = new TStyle(""st1"",""my style"");; st1->Set...; st1->cd(); // this becomes now the cur",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:104149,Usability,clear,clear,104149,". Note that when an object is created, its attributes are taken from the; current style. For example, you may have created a histogram in a; previous session and saved it in a file. Meanwhile, if you have changed; the style, the histogram will be drawn with the old attributes. You can; force the current style attributes to be set when you read an object; from a file by calling `ForceStyle` before reading the objects from the; file. ``` {.cpp}; gROOT->ForceStyle();; ```. When you call `gROOT->ForceStyle()` and read an object from a ROOT file,; the object's method `UseCurrentStyle` is called. The attributes saved; with the object are replaced by the current style attributes. You call; also call `myObject->UseCurrentStyle()` directly. For example if you; have a canvas or pad with your histogram or any other object, you can; force these objects to get the attributes of the current style by:. ``` {.cpp}; canvas->UseCurrentStyle();; ```. The description of the style functions should be clear from the name of; the **`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105143,Usability,simpl,simple,105143,"*`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in y",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105316,Usability,simpl,simple,105316,"set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in your chosen viewer. ### Invoking a 3D viewer. A 3D viewer can be created in a script by passing the appropriate option; to `Draw() `when attaching the dra",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:118207,Usability,guid,guides,118207,"of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Initial position is at the center of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the col",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121103,Usability,simpl,simple,121103,"Emissive. For each of these you can select the component via the radio buttons.; Each component can have the red, green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D o",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:123775,Usability,simpl,simple,123775,"ects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; viewers free of viewer specific drawing code. They allow our simple x3d; viewer, and considerably more sophisticated OpenGL one to both work with; both geometry libraries (`g3d` and `geom`) efficiently. In addition to external viewers, created in separate windows, this; architecture is also used by internal **`TPad`** drawing when it; requires 3D projections. Publishing to a viewer consists of the; following steps:. 1- Create / obtain viewer handle. 2- Begin scene on viewer. 3- Fill mandatory parts of TBuffer3D describing object. 4- Add to viewer. 5- Fill optional parts of TBuffer3D as requested by viewer. [ .... repeat 3/4/5 as required for other/child objects]. 6- End scene on viewer. You should attach the top-level node of your external geometry (or the; manager) to a **`TPad`** object using **`TObject::Draw()`, and perform; the publishing to the viewer in your object's `TObject::Paint()`; overloaded method. See ""Scene Rebuilds"", and example scripts, for more; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in t",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:127493,Usability,clear,clear,127493,"ription. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`, `kRaw` - see the class diagram and; the file `TBuffer3D.h` for more details. The **`TBuffer3D`** methods; `SectionsValid()`, `SetSectionsValid()`, `ClearSectionsValid()` are used; to test, set, clear these section validity flags e.g. ``` {.cpp}; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; ...; if (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {; ...; }; ```. The sections found in the base **`TBuffer3D`**; (`kCore/kBoundingBox/kRawSizes/kRaw`) are sufficient to describe any; tessellated shape in a generic fashion. An additional `kShapeSpecific`; section is added in **`TBuffer3D`** derived classes, allowing a more; abstract shape description (""a sphere of inner radius x, outer radius; y""). This enables a viewer, which knows how to draw (tessellate) the; shape itself to do so, while providing a generic fallback suitable for; all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized **`TBuffer3D`** class exists, use it,; otherwise use **`TBuffer3D`**. - Complete the mandatory `kCore` section. - Complete the `kShapeSpecific` section if applicable. - Complete the `kBoundingBox` if you can. - Pa",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:132276,Usability,clear,clear,132276," viewer requires two publication passes - one to establish; the full tessellation capacity for all shapes, and another to; actually add them. Splitting avoids having to do the expensive; tessellation on the first pass. #### Shape Specific TBuffer3D Derived Classes. Currently we provide the following shape specific classes, which the GL; Viewer can take advantage of (see `TBuffer3D.h` and `TBuffer3DTypes.h`). - **`TBuffer3DSphere`** - solid, hollow and cut spheres (GL Viewer; only supports solid spheres at present - cut / hollow ones will be; requested as tessellated objects by client.). - **`TBuffer3DTube`** - basic tube with inner/outer radius and length. - **`TBuffer3DTubeSeg`** - angle tube segment. - **`TBuffer3DCutTube`** - angle tube segment with plane cut ends. See the above example from `TGeoSphere::GetBuffer3D` and also equivalent; functions in **`TGeoTube`**, **`TGeoTubeSeg`** and **`TGeoCtub`**.; Anyone is free to add new **`TBuffer3D`** classes, but it should be; clear that one or more viewers will require updating to be able to take; advantage of them. Hence we only provide classes which existing viewers; can benefit from. The number of native shapes in GL Viewer will be; expanded in the future. #### Master / Local Reference Frames. The Core section of **`TBuffer3D`** contains two members relating to; reference frames:. - `fLocalFrame`: indicates if any positions in the buffer (bounding; box and tessellation vertexes) are in local or master (world frame). - `fLocalMaster`: is a standard 4x4 translation matrix (OpenGL column; major ordering) for placing the object into the 3D master frame. If `fLocalFrame` is false, `fLocalMaster` should contain an identity; matrix. This is set by default, and can be reset using the; **`TBuffer3D::SetLocalMasterIdentity()` method.**. #### Bounding Boxes. You are not obliged to complete the `kBoundingBox` section, as any; viewer requiring one internally (GL Viewer) will build it if you do not; provide. However to do this ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:133654,Usability,simpl,simpler,133654," `fLocalFrame`: indicates if any positions in the buffer (bounding; box and tessellation vertexes) are in local or master (world frame). - `fLocalMaster`: is a standard 4x4 translation matrix (OpenGL column; major ordering) for placing the object into the 3D master frame. If `fLocalFrame` is false, `fLocalMaster` should contain an identity; matrix. This is set by default, and can be reset using the; **`TBuffer3D::SetLocalMasterIdentity()` method.**. #### Bounding Boxes. You are not obliged to complete the `kBoundingBox` section, as any; viewer requiring one internally (GL Viewer) will build it if you do not; provide. However to do this the viewer will force you to provide the; (expensive) raw tessellation, and the resulting box will be axis aligned; with the overall scene, which is non-ideal for rotated shapes. As we; need to support orientated (rotated) bounding boxes, **`TBuffer3D`**; requires the 6 vertices of the box. We also provide a convenience; function, `TBuffer::SetAABoundingBox()`, for simpler case of setting an; axis aligned bounding box. The bounding box should be filled in same; frame (local / master) as the rest of the **`TBuffer3D`**, and; in accordance with `fLocalFrame` flag. A typical example from TGeoBBox::FillBuffer3D:. ``` {.cpp}; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The sec",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:137831,Usability,simpl,simple,137831,"returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has b",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:139086,Usability,simpl,simple,139086,"ct::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, examine the code under; `$ROOTSYS/geom` - in particular **`TGeoShape`** hierarchy, and the; painter object **`TGeoPainter`** (under geopainter) where the; negotiation with the viewer is performed.; ",MatchSource.DOCS,documentation/users-guide/Graphics.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:1664,Availability,error,error,1664,"[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; ```. #### Bar Graphs (AB). ![A graph drawn with axis and bar (option AB)](pictures/0300004C.png). ``` {.cpp}; root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->SetFillColor(40);; root[] gr1->Draw(""AB"");; ```. This code will only work if n, x, and y is defined. The previous; ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:4871,Availability,error,error,4871,"h's marker style at each point; gr3->SetMarkerStyle(21);; c1->cd(4);; gr3->Draw(""APL"");. // get the points in the graph and put them into an array; Double_t *nx = gr3->GetX();; Double_t *ny = gr3->GetY();. // create markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; ```. ## Superimposing Two Graphs. To super impose two graphs you need to draw the axis only once, and; leave out the ""A"" in the draw options for the second graph. Next is an; example:. ![Superimposing two graphs](pictures/0300004F.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5076,Availability,error,error,5076,"markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; ```. ## Superimposing Two Graphs. To super impose two graphs you need to draw the axis only once, and; leave out the ""A"" in the draw options for the second graph. Next is an; example:. ![Superimposing two graphs](pictures/0300004F.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerr",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5211,Availability,error,error,5211,"ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; ```. ## Superimposing Two Graphs. To super impose two graphs you need to draw the axis only once, and; leave out the ""A"" in the draw options for the second graph. Next is an; example:. ![Superimposing two graphs](pictures/0300004F.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);;",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5286,Availability,error,error,5286,"mposing Two Graphs. To super impose two graphs you need to draw the axis only once, and; leave out the ""A"" in the draw options for the second graph. Next is an; example:. ![Superimposing two graphs](pictures/0300004F.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5366,Availability,error,error,5366,"once, and; leave out the ""A"" in the draw options for the second graph. Next is an; example:. ![Superimposing two graphs](pictures/0300004F.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5494,Availability,error,errors,5494,"; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create th",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5543,Availability,error,errors,5543,"; {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create th",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5620,Availability,error,error,5620,"->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5693,Availability,error,error,5693,"""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; ```. ## Graphs with Error Bars. A **`TGraphErrors`** is a **`TGraph`** with error bars. The various; draw format options of `TGraphErrors::Paint()` are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs wit",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5944,Availability,error,errors,5944," are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(O",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5960,Availability,error,errors,5960," are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(O",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:5985,Availability,error,errors,5985," are derived from; **`TGraph`**. ``` {.cpp}; void TGraphErrors::Paint(Option_t *option); ```. ![Graphs with different draw options of error bars](pictures/03000050.png). In addition, it can be drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(O",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6138,Availability,error,error,6138," drawn with the ""`Z`"" option to leave off the; small lines at the end of the error bars. If option contains ""`>`"", an; arrow is drawn at the end of the error bars. If option contains; ""`|>`"", a full arrow is drawn at the end of the error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6357,Availability,error,error,6357," error bars. The size; of the arrow is set to 2/3 of the marker size. The option ""`[]`"" is interesting to superimpose systematic errors on; top of the graph with the statistical errors. When it is specified,; only the end vertical/horizontal lines of the error bars are drawn. To control the size of the lines at the end of the error bars (when; option 1 is chosen) use `SetEndErrorSize(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end ve",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6750,Availability,error,error,6750,"(np)`. By default `np=1`; `np`; represents the number of pixels. ``` {.cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6846,Availability,error,error,6846,".cpp}; gStyle->SetEndErrorSize(np);; ```. The four parameters of **`TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new T",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7170,Availability,error,error,7170," with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] =",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7225,Availability,error,error,7225," arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7285,Availability,error,error,7285," Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7397,Availability,error,error,7397,"oat_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7473,Availability,error,errors,7473,"oat_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7516,Availability,error,errors,7516,"oat_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7603,Availability,error,errors,7603,""");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Er",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7621,Availability,error,errors,7621,""");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Er",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7635,Availability,error,errors,7635,""");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Er",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7653,Availability,error,errors,7653,""");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Er",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7697,Availability,error,error,7697,"graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetri",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7723,Availability,down,down,7723,"graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetri",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7766,Availability,error,error,7766,"graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetri",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:7855,Availability,error,error,7855," bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` meth",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:8108,Availability,error,errors,8108,"he horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:8629,Availability,error,error,8629," low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the f",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:8730,Availability,error,error,8730,"bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:8908,Availability,error,error,8908,"s for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:8978,Availability,error,error,8978,"s for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9102,Availability,error,errors,9102,"s; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9230,Availability,error,error,9230,".6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9312,Availability,error,error,9312,"6,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,ey",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9462,Availability,error,error,9462,",eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9538,Availability,error,errors,9538,"->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## TGraphPolar. The **`TGraphPolar`** class creates a polar graph (including error; bars). A **`TGraphPolar",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:9581,Availability,error,errors,9581,"->Draw(""ALP"");; }; ```. ## Graphs with Asymmetric Bent Errors. ![A graph with asymmetric bent error bars](pictures/03000053.png). A **`TGraphBentErrors`** is a **`TGraph`** with bent, asymmetric error; bars. The various format options to draw a **`TGraphBentErrors`** are; explained in **`TGraphBentErrors::Paint` method. The; `TGraphBentErrors`** is drawn by default with error bars and small; horizontal and vertical lines at the end of the error bars. If option; ""`z`"" or ""`Z`"" is specified, these small lines are not drawn. If the; option ""`X`"" is specified, the errors are not drawn; (the `TGraph::Paint` method equivalent). - if option contains ""`>`"", an arrow is drawn at the end of the; error bars. - if option contains ""`|>`"", a full arrow is drawn at the end of the; error bars. - the size of the arrow is set to 2/3 of the marker size. - if option ""`[]`"" is specified, only the end vertical/horizontal; lines of the error bars are drawn. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## TGraphPolar. The **`TGraphPolar`** class creates a polar graph (including error; bars). A **`TGraphPolar",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:10506,Availability,error,error,10506,"n. This option is interesting to; superimpose systematic errors on top of a graph with statistical; errors. This figure has been generated by the following macro:. ``` {.cpp}; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## TGraphPolar. The **`TGraphPolar`** class creates a polar graph (including error; bars). A **`TGraphPolar`** is a **`TGraphErrors`** represented in; polar coordinates. It uses the class **`TGraphPolargram`** to draw the; polar axis. ``` {.cpp}; {; TCanvas *CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",700,700);; Double_t rmin=0;; Double_t rmax=TMath::Pi()*2;; Double_t r[1000];; Double_t theta[1000];; TF1 * fp1 = new TF1(""fplot"",""cos(x)"",rmin,rmax);; for (Int_t ipt = 0; ipt < 1000; ipt++) {; r[ipt] = ipt*(rmax-rmin)/1000+rmin;; theta[ipt] = fp1->Eval(r[ipt]);; }; TGraphPolar * grP1 = new TGraphPolar(1000,r,theta);; grP1->SetLineColor(2);; grP1->Draw(""AOL"");; }; ```. The TGraphPolar drawing options are:. ""O"" Polar labels are paint orthogonally to the polargram radius. ""P"" Polymarker are paint at each point position. ""E"" Paint error bars. ""F"" Paint fill area (closed polygon). ""A""Force axis redrawing even if a polagram already exists. ![A polar graph](pictures/03000054.png). ## TGraph Exclusion Zone. When a graph is painted with the opt",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:11270,Availability,error,error,11270,"; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; ```. ## TGraphPolar. The **`TGraphPolar`** class creates a polar graph (including error; bars). A **`TGraphPolar`** is a **`TGraphErrors`** represented in; polar coordinates. It uses the class **`TGraphPolargram`** to draw the; polar axis. ``` {.cpp}; {; TCanvas *CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",700,700);; Double_t rmin=0;; Double_t rmax=TMath::Pi()*2;; Double_t r[1000];; Double_t theta[1000];; TF1 * fp1 = new TF1(""fplot"",""cos(x)"",rmin,rmax);; for (Int_t ipt = 0; ipt < 1000; ipt++) {; r[ipt] = ipt*(rmax-rmin)/1000+rmin;; theta[ipt] = fp1->Eval(r[ipt]);; }; TGraphPolar * grP1 = new TGraphPolar(1000,r,theta);; grP1->SetLineColor(2);; grP1->Draw(""AOL"");; }; ```. The TGraphPolar drawing options are:. ""O"" Polar labels are paint orthogonally to the polargram radius. ""P"" Polymarker are paint at each point position. ""E"" Paint error bars. ""F"" Paint fill area (closed polygon). ""A""Force axis redrawing even if a polagram already exists. ![A polar graph](pictures/03000054.png). ## TGraph Exclusion Zone. When a graph is painted with the option ""`C`"" or ""`L`"", it is possible; to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute; value of the graph line width (set thanks to `SetLineWidth`) is; greater than 99. In that case the line width number is interpreted as; `100*ff+ll = ffll`. The two-digit numbers ""`ll`"" represent the normal; line width whereas ""`ff`"" is the filled area width. The sign of; ""`ffll`"" allows flipping the filled area from one side of the line to; the other. The current fill area attributes are used to draw the; hatched zone. ![Graphs with exclusion zones](pictures/03000055.png). ``` {.cpp}; {; c1 = new TCanvas(""c1"",""Exclusion graphs examples"",200,10,700,500);; c1->SetGrid();. // create the multigraph; TMultiGraph",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:13785,Availability,robust,robust,13785,"(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. // create the 3rd TGraph; gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. // put the graphs in the multigraph; mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);. // draw the multigraph; mg->Draw(""AC"");; }; ```. ## TGraphQQ. A **`TGraphQQ`** allows drawing quantile-quantile plots. Such plots; can be drawn for two datasets, or for one dataset and a theoretical; distribution function. ### Two Datasets. ![Examples of qq-plots of 2 datasets](pictures/03000056.png). Quantile-quantile plots are used to determine whether two samples come; from the same distribution. A qq-plot draws the quantiles of one; dataset against the quantile of the other. The quantiles of the; dataset with fewer entries are on Y-axis, with more entries - on; X-axis. A straight line, going through 0.25 and 0.75 quantiles is also; plotted for reference. It represents a robust linear fit, not; sensitive to the extremes of the datasets. If the datasets come from; the same distribution, points of the plot should fall approximately on; the 45 degrees line. If they have the same distribution function, but; different parameters of location or scale, they should still fall on; the straight line, but not the 45 degrees one. The greater their departure from the straight line, the more evidence; there is that the datasets come from different distributions. The; advantage of qq-plot is that it not only shows that the underlying; distributions are different, but, unlike the analytical methods, it; also gives information on the nature of this difference: heavier; tails, different location/scale, different shape, etc. ### One Dataset. ![Examples of qq-plots of 1 dataset](pictures/03000057.png). Quantile-quantile plots are used to determine if the dataset comes; from the specified theoretical distribution, such as normal. A qq-plot; draws quantiles of the dataset against quantiles of the s",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:15004,Availability,robust,robust,15004,"ent parameters of location or scale, they should still fall on; the straight line, but not the 45 degrees one. The greater their departure from the straight line, the more evidence; there is that the datasets come from different distributions. The; advantage of qq-plot is that it not only shows that the underlying; distributions are different, but, unlike the analytical methods, it; also gives information on the nature of this difference: heavier; tails, different location/scale, different shape, etc. ### One Dataset. ![Examples of qq-plots of 1 dataset](pictures/03000057.png). Quantile-quantile plots are used to determine if the dataset comes; from the specified theoretical distribution, such as normal. A qq-plot; draws quantiles of the dataset against quantiles of the specified; theoretical distribution. Note, that density, not CDF should be; specified a straight line, going through 0.25 and 0.75 quantiles could; also be plotted for reference. It represents a robust linear fit, not; sensitive to the extremes of the dataset. As in the two datasets case,; departures from straight line indicate departures from the specified; distribution. Next picture shows an example of a qq-plot of a dataset; from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function.; Fitting parameters are estimates of the distribution mean and sigma. ## TMultiGraph. ![A multigraph example](pictures/03000058.png). A **`TMultiGraph`** is a collection of **`TGraph`** (or derived); objects. Use `TMultiGraph::Add `to add a new graph to the list. The; **`TMultiGraph`** owns the objects in the list. The drawing and; fitting options are the same as for **`TGraph`**. ``` {.cpp}; {; // create the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t x2[n] = {-.12,.15,.35,.45,.6,.71,.8,.95,.99,1.05};; Double_t y2[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the width of errors in x and y direction; ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:15999,Availability,error,errors,15999,"linear fit, not; sensitive to the extremes of the dataset. As in the two datasets case,; departures from straight line indicate departures from the specified; distribution. Next picture shows an example of a qq-plot of a dataset; from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function.; Fitting parameters are estimates of the distribution mean and sigma. ## TMultiGraph. ![A multigraph example](pictures/03000058.png). A **`TMultiGraph`** is a collection of **`TGraph`** (or derived); objects. Use `TMultiGraph::Add `to add a new graph to the list. The; **`TMultiGraph`** owns the objects in the list. The drawing and; fitting options are the same as for **`TGraph`**. ``` {.cpp}; {; // create the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t x2[n] = {-.12,.15,.35,.45,.6,.71,.8,.95,.99,1.05};; Double_t y2[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the width of errors in x and y direction; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create two graphs; TGraph *gr1 = new TGraph(n,x2,y2);; TGraphErrors *gr2 = new TGraphErrors(n,x,y,ex,ey);. // create a multigraph and draw it; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1);; mg->Add(gr2);; mg->Draw(""ALP"");; }; ```. ## TGraph2D. ![Delaunay triangles and Voronoï diagram](pictures/03000059.png). This class is a set of `N` points `x[i]`, `y[i]`, `z[i]` in a; non-uniform grid. Several visualization techniques are implemented,; including Delaunay triangulation. Delaunay triangulation is defined as; follow: ‘for a set `S` of points in the Euclidean plane, the unique; triangulation `DT(S)` of `S` such that no point in `S` is inside the; circum-circle of any triangle in `DT(S)`. `DT(S)` is the dual of the; Voronoï diagram of `S`. If n is the number of points in `S`, the; Voronoï diagram of S is the partitioning of the plane containing `S`; poin",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:20635,Availability,error,errors,20635,"ke the form of a 2D histogram or a; vector. The triangles found can be drawn in 3D. This software cannot; be guaranteed to work under all circumstances. It was originally; written to work with a few hundred points in an` XY` space with; similar `X` and `Y` ranges. ![Graph2D drawn with option ""surf1"" and ""tri1 p0""](pictures/0300005A.png). ``` {.cpp}; {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; ```. A more complete example is `$ROOTSYS/tutorials/fit/graph2dfit.C` that; produces the next figure. ![Output of macro graph2dfit.C](pictures/0300005C.png). ## TGraph2DErrors. A **`TGraph2DErrors`** is a **`TGraph2D`** with errors. It is useful to; perform fits with errors on a 2D graph. An example is the macro; `$ROOTSYS/tutorials/graphs/graph2derrorsfit.C`. ## Fitting a Graph. The graph `Fit` method in general works the same way as the `TH1::Fit`.; See ""Fitting Histograms"". ## Setting the Graph's Axis Title. To give the axis of a graph a title you need to draw the graph first,; only then does it actually have an axis object. Once drawn, you set the; title by getting the axis and calling the `TAxis::SetTitle` method, and; if you want to center it, you can call the `TAxis::CenterTitle` method. Assuming that `n, x,` and `y` are defined. Next code sets the titles of; the `x` and `y` axes. ``` {.cpp}; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()-",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:20678,Availability,error,errors,20678,"s found can be drawn in 3D. This software cannot; be guaranteed to work under all circumstances. It was originally; written to work with a few hundred points in an` XY` space with; similar `X` and `Y` ranges. ![Graph2D drawn with option ""surf1"" and ""tri1 p0""](pictures/0300005A.png). ``` {.cpp}; {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; ```. A more complete example is `$ROOTSYS/tutorials/fit/graph2dfit.C` that; produces the next figure. ![Output of macro graph2dfit.C](pictures/0300005C.png). ## TGraph2DErrors. A **`TGraph2DErrors`** is a **`TGraph2D`** with errors. It is useful to; perform fits with errors on a 2D graph. An example is the macro; `$ROOTSYS/tutorials/graphs/graph2derrorsfit.C`. ## Fitting a Graph. The graph `Fit` method in general works the same way as the `TH1::Fit`.; See ""Fitting Histograms"". ## Setting the Graph's Axis Title. To give the axis of a graph a title you need to draw the graph first,; only then does it actually have an axis object. Once drawn, you set the; title by getting the axis and calling the `TAxis::SetTitle` method, and; if you want to center it, you can call the `TAxis::CenterTitle` method. Assuming that `n, x,` and `y` are defined. Next code sets the titles of; the `x` and `y` axes. ``` {.cpp}; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more gr",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:1971,Deployability,continuous,continuous,1971,"ternal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; ```. #### Bar Graphs (AB). ![A graph drawn with axis and bar (option AB)](pictures/0300004C.png). ``` {.cpp}; root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->SetFillColor(40);; root[] gr1->Draw(""AB"");; ```. This code will only work if n, x, and y is defined. The previous; example defines these. You need to set the fill color, because by; default the fill color is white and will not be visible on a white; canvas. You also need to give it an axis, or the bar chart will not be; displayed properly. #### Filled Graphs (AF). ![A graph drawn with axis and fill (option AF)](pictures/0300004D.png). ```",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:2300,Deployability,continuous,continuous,2300,"2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; ```. #### Bar Graphs (AB). ![A graph drawn with axis and bar (option AB)](pictures/0300004C.png). ``` {.cpp}; root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->SetFillColor(40);; root[] gr1->Draw(""AB"");; ```. This code will only work if n, x, and y is defined. The previous; example defines these. You need to set the fill color, because by; default the fill color is white and will not be visible on a white; canvas. You also need to give it an axis, or the bar chart will not be; displayed properly. #### Filled Graphs (AF). ![A graph drawn with axis and fill (option AF)](pictures/0300004D.png). ``` {.cpp}; root[] TGraph *gr3 = new TGraph(n,x,y);; root[] gr3->SetFillColor(45);; root[] gr3->Draw(""AF""); ```. This code will only work if `n`, `x`, `y `are defined. The first; example defines them. You need to set the fill color, because by; default the fill color is white and will not be visible on a white; canvas. You also need to give it an ax",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:22689,Integrability,interface,interface,22689,",x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more graph examples see the scripts: `$ROOTSYS/tutorials` directory; `graph.C`, `gerrors.C`, `zdemo.C`, and `gerrors2.C`. ![A graph with axis titles](pictures/0300005D.png). ## Zooming a Graph. To zoom a graph you can create a histogram with the desired axis range; first. Draw the empty histogram and then draw the graph using the; existing axis from the histogram. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; ```. The next example is the same graph as above with a zoom in the x and y; directions. ![A zoomed graph](pictures/0300005E.png). ## The User Interface for Graphs. The class **`TGraphEditor`** provides the user interface for setting; the following graph attributes interactively:. - Title text entry field ... sets the title of the graph. - Shape radio button group - sets the graph shapes:. - *No Line*: draw unconnected points;; - *Smooth Line*: a smooth curve;; - *Simple Line*: a simple poly-line;; - *Bart Chart*: a bar chart at each point.; - *Fill Area*: a fill area is drawn. - Show Marker - sets markers as visible or invisible. - Exclusion Zone - specifies the exclusion zone parameters :. - *'+-‘ check button*: sets on which side of the line the; exclusion zone will be drawn;; - *Width combo box*: defines the width of the zone. ![](pictures/0300005F.png). ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:961,Modifiability,extend,extend,961,"# Graphs. A graph is a graphics object made of two arrays X and Y, holding the; x,y coordinates of `n` points. There are several graph classes; they; are **`TGraph`**, **`TGraphErrors`**, **`TGraphAsymmErrors`**, and; **`TMultiGraph`**. ## TGraph. The **`TGraph`** class supports the general case with non-equidistant; points, and the special case with equidistant points. Graphs are; created with the **`TGraph`** constructor. First, we define the arrays; of coordinates and then create the graph. The coordinates can be; arrays of doubles or floats. ``` {.cpp}; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)]",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6862,Modifiability,inherit,inherits,6862,"TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1-",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:18277,Modifiability,extend,extended,18277,"et tessellation. The **`TGraph2D`** class has the following constructors:. - With an arrays' dimension `n` and three arrays `x`, `y`, and `z`; (can be arrays of doubles, floats, or integers):. ``` {.cpp}; TGraph2D *g = new TGraph2D(n,x,y,z);; ```. - With an array dimension only:. ``` {.cpp}; TGraph2D *g = new TGraph2D(n);; ```. - Internal arrays are filled with the method `SetPoint` at the; position ""`i`"" with the values `x`, `y`, `z`:. ``` {.cpp}; g->SetPoint(i,x,y,z);; ```. - Without parameters; the method `SetPoint` must be used to fill the; internal arrays. ``` {.cpp}; TGraph2D *g = new TGraph2D();; ```. - From a file:. ``` {.cpp}; TGraph2D *g = new TGraph2D(""graph.dat"");; ```. The arrays are read from the ASCII file ""`graph.dat`"" according to a; specified format. The format's default value is ""`%lg %lg %lg`"". Note; that in any of last three cases, the `SetPoint` method can be used to; change a data point or to add a new one. If the data point index (`i`); is greater than the size of the internal arrays, they are; automatically extended. Specific drawing options can be used to paint a **`TGraph2D`**:. - ""`TRI`"" the Delaunay triangles are drawn using filled area. A; hidden surface drawing technique is used. The surface is painted; with the current fill area color. The edges of the triangles are; painted with the current line color;. - ""`TRIW`""the Delaunay triangles are drawn as wire frame;. - ""`TRI1`"" the Delaunay triangles are painted with color levels. The; edges of the triangles are painted with the current line color;. - ""`TRI2`"" the Delaunay triangles are painted with color levels;. - ""`P`""draws a marker at each vertex;. - ""`P0`"" draws a circle at each vertex. Each circle background is; white. A **`TGraph2D`** can be also drawn with ANY options valid for 2D; histogram drawing. In this case, an intermediate 2D histogram is; filled using the Delaunay triangles technique to interpolate the data; set. **`TGraph2D`** linearly interpolate a `Z` value for any `(X,Y",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:20660,Performance,perform,perform,20660,"s found can be drawn in 3D. This software cannot; be guaranteed to work under all circumstances. It was originally; written to work with a few hundred points in an` XY` space with; similar `X` and `Y` ranges. ![Graph2D drawn with option ""surf1"" and ""tri1 p0""](pictures/0300005A.png). ``` {.cpp}; {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; ```. A more complete example is `$ROOTSYS/tutorials/fit/graph2dfit.C` that; produces the next figure. ![Output of macro graph2dfit.C](pictures/0300005C.png). ## TGraph2DErrors. A **`TGraph2DErrors`** is a **`TGraph2D`** with errors. It is useful to; perform fits with errors on a 2D graph. An example is the macro; `$ROOTSYS/tutorials/graphs/graph2derrorsfit.C`. ## Fitting a Graph. The graph `Fit` method in general works the same way as the `TH1::Fit`.; See ""Fitting Histograms"". ## Setting the Graph's Axis Title. To give the axis of a graph a title you need to draw the graph first,; only then does it actually have an axis object. Once drawn, you set the; title by getting the axis and calling the `TAxis::SetTitle` method, and; if you want to center it, you can call the `TAxis::CenterTitle` method. Assuming that `n, x,` and `y` are defined. Next code sets the titles of; the `x` and `y` axes. ``` {.cpp}; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more gr",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:1161,Usability,simpl,simple,1161,"rors`**, **`TGraphAsymmErrors`**, and; **`TMultiGraph`**. ## TGraph. The **`TGraph`** class supports the general case with non-equidistant; points, and the special case with equidistant points. Graphs are; created with the **`TGraph`** constructor. First, we define the arrays; of coordinates and then create the graph. The coordinates can be; arrays of doubles or floats. ``` {.cpp}; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:22962,Usability,simpl,simple,22962,",x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more graph examples see the scripts: `$ROOTSYS/tutorials` directory; `graph.C`, `gerrors.C`, `zdemo.C`, and `gerrors2.C`. ![A graph with axis titles](pictures/0300005D.png). ## Zooming a Graph. To zoom a graph you can create a histogram with the desired axis range; first. Draw the empty histogram and then draw the graph using the; existing axis from the histogram. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; ```. The next example is the same graph as above with a zoom in the x and y; directions. ![A zoomed graph](pictures/0300005E.png). ## The User Interface for Graphs. The class **`TGraphEditor`** provides the user interface for setting; the following graph attributes interactively:. - Title text entry field ... sets the title of the graph. - Shape radio button group - sets the graph shapes:. - *No Line*: draw unconnected points;; - *Smooth Line*: a smooth curve;; - *Simple Line*: a simple poly-line;; - *Bart Chart*: a bar chart at each point.; - *Fill Area*: a fill area is drawn. - Show Marker - sets markers as visible or invisible. - Exclusion Zone - specifies the exclusion zone parameters :. - *'+-‘ check button*: sets on which side of the line the; exclusion zone will be drawn;; - *Width combo box*: defines the width of the zone. ![](pictures/0300005F.png). ",MatchSource.DOCS,documentation/users-guide/Graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:7178,Availability,error,errors,7178,"ins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with statements like:. ``` {.cpp}; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; ```. The `Fill` method computes the bin number corresponding to the given; x, y or z argument and increments this bin by the given weight. The; `Fill()` method returns the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and access the bin content of a given; bin via **`TH1`**`::GetBinContent()` . ``` {.cpp}; Double_t binContent = h->GetBinContent(bin);; ```. ### Automatic Re-binning Option. By default, the number of bins is computed using the range of the; axis. You can change thi",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:12208,Availability,error,error,12208,"rent histogram. - Additions of two histograms with coefficients and storage into the; current histogram. - Multiplications and divisions are supported in the same way as; additions. - The `Add` , `Divide` and ` Multiply` methods also exist to add,; divide or multiply a histogram by a function. Histograms objects (not pointers) **`TH1F`** `h1` can be multiplied by; a constant using:. ``` {.cpp}; h1.Scale(const); ```. A new histogram can be created without changing the original one by; doing:. ``` {.cpp}; TH1F h3 = 8*h1;; ```. To multiply two histogram objects and put the result in a 3rd one do:. ``` {.cpp}; TH1F h3 = h1*h2;; ```. The same operations can be done with histogram pointers; **`TH1F`** `*h1`, **`*h2`** following way:. ``` {.cpp}; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; ```. Of course, the **`TH1`** methods `Add` , `Multiply` and `Divide` can; be used instead of these operators. If a histogram has associated error bars ( **`TH1`**`::Sumw2()` has; been called), the resulting error bars are also computed assuming; independent histograms. In case of divisions, binomial errors are also; supported. ## Projections. One can make:. - a 1-D projection of a 2-D histogram or profile. See; **`TH2`**`::ProfileX`,; **`TH2`**`::ProfileY, `**`TProfile`**`::ProjectionX`,; **`TProfile2D`**`::ProjectionXY`, **`TH2`**`::ProjectionX`,; **`TH2`**`::ProjectionY` . - a 1-D, 2-D or profile out of a 3-D histogram see; **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** cl",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:12275,Availability,error,error,12275,"rent histogram. - Additions of two histograms with coefficients and storage into the; current histogram. - Multiplications and divisions are supported in the same way as; additions. - The `Add` , `Divide` and ` Multiply` methods also exist to add,; divide or multiply a histogram by a function. Histograms objects (not pointers) **`TH1F`** `h1` can be multiplied by; a constant using:. ``` {.cpp}; h1.Scale(const); ```. A new histogram can be created without changing the original one by; doing:. ``` {.cpp}; TH1F h3 = 8*h1;; ```. To multiply two histogram objects and put the result in a 3rd one do:. ``` {.cpp}; TH1F h3 = h1*h2;; ```. The same operations can be done with histogram pointers; **`TH1F`** `*h1`, **`*h2`** following way:. ``` {.cpp}; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; ```. Of course, the **`TH1`** methods `Add` , `Multiply` and `Divide` can; be used instead of these operators. If a histogram has associated error bars ( **`TH1`**`::Sumw2()` has; been called), the resulting error bars are also computed assuming; independent histograms. In case of divisions, binomial errors are also; supported. ## Projections. One can make:. - a 1-D projection of a 2-D histogram or profile. See; **`TH2`**`::ProfileX`,; **`TH2`**`::ProfileY, `**`TProfile`**`::ProjectionX`,; **`TProfile2D`**`::ProjectionXY`, **`TH2`**`::ProjectionX`,; **`TH2`**`::ProjectionY` . - a 1-D, 2-D or profile out of a 3-D histogram see; **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** cl",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:12369,Availability,error,errors,12369,"ltiplications and divisions are supported in the same way as; additions. - The `Add` , `Divide` and ` Multiply` methods also exist to add,; divide or multiply a histogram by a function. Histograms objects (not pointers) **`TH1F`** `h1` can be multiplied by; a constant using:. ``` {.cpp}; h1.Scale(const); ```. A new histogram can be created without changing the original one by; doing:. ``` {.cpp}; TH1F h3 = 8*h1;; ```. To multiply two histogram objects and put the result in a 3rd one do:. ``` {.cpp}; TH1F h3 = h1*h2;; ```. The same operations can be done with histogram pointers; **`TH1F`** `*h1`, **`*h2`** following way:. ``` {.cpp}; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; ```. Of course, the **`TH1`** methods `Add` , `Multiply` and `Divide` can; be used instead of these operators. If a histogram has associated error bars ( **`TH1`**`::Sumw2()` has; been called), the resulting error bars are also computed assuming; independent histograms. In case of divisions, binomial errors are also; supported. ## Projections. One can make:. - a 1-D projection of a 2-D histogram or profile. See; **`TH2`**`::ProfileX`,; **`TH2`**`::ProfileY, `**`TProfile`**`::ProjectionX`,; **`TProfile2D`**`::ProjectionXY`, **`TH2`**`::ProjectionX`,; **`TH2`**`::ProjectionY` . - a 1-D, 2-D or profile out of a 3-D histogram see; **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; examp",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16818,Availability,error,errors,16818,"le and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": Use spherical coordinates. - ""`PSR`"": Use pseudo-rapidity/phi coordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; c",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16860,Availability,error,error,16860,"le and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": Use spherical coordinates. - ""`PSR`"": Use pseudo-rapidity/phi coordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; c",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16896,Availability,error,errors,16896," call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": Use spherical coordinates. - ""`PSR`"": Use pseudo-rapidity/phi coordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18186,Availability,error,error,18186,"oordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18217,Availability,error,error,18217,"hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number of pixels in the current; pad. - ""`][`"": Draw",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18279,Availability,error,error,18279,"rface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number of pixels in the current; pad. - ""`][`"": Draw histogram without the vertical lines for the first; and the last ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18348,Availability,error,error,18348,"to show the cell; contents. - ""`SURF`"": Draw a surface plot with hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number of pixels in the current; pad. - ""`][`"": Draw histogram without the vertical lines for the first; and the last bin. Use it when superposing many histograms on the; same ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18443,Availability,error,error,18443,"h hidden line removal. - ""`SURF1`"": Draw a surface plot with hidden surface removal. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number of pixels in the current; pad. - ""`][`"": Draw histogram without the vertical lines for the first; and the last bin. Use it when superposing many histograms on the; same picture. The following options are supported for 2-D histogram ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:18524,Availability,error,error,18524,"val. - ""`SURF2`"": Draw a surface plot using colors to show the cell; contents. - ""`SURF3`"": Same as `SURF` with a contour view on the top. - ""`SURF4`"": Draw a surface plot using `Gouraud` shading. - ""`SURF5`"": Same as `SURF3` but only the colored contour is drawn.; Used with option `CYL` , `SPH` or `PSR` it allows to draw colored; contours on a sphere, a cylinder or in a pseudo rapidly space. In; Cartesian or polar coordinates, option `SURF3` is used. The following options are supported for 1-D histogram classes:. - ""`AH`"": Draw the histogram, but not the axis labels and tick marks. - ""`B`"": Draw a bar chart. - ""`C`"": Draw a smooth curve through the histogram bins. - ""`E`"": Draw the error bars. - ""`E0`"": Draw the error bars including bins with 0 contents. - ""`E1`"": Draw the error bars with perpendicular lines at the edges. - ""`E2`"": Draw the error bars with rectangles. - ""`E3`"": Draw a fill area through the end points of the vertical; error bars. - ""`E4`"": Draw a smoothed filled area through the end points of the; error bars. - ""`L`"": Draw a line through the bin contents. - ""`P`"": Draw a (poly)marker at each bin using the histogram's; current marker style. - ""`P0`"": Draw current marker at each bin including empty bins. - ""`PIE`"": Draw a Pie Chart. - ""`*H`"": Draw histogram with a \* at each bin. - ""`LF2`"": Draw histogram as with option ""`L`"" but with a fill; area. Note that ""`L`"" also draws a fill area if the histogram fill; color is set but the fill area corresponds to the histogram; contour. - ""`9`"": Force histogram to be drawn in high resolution mode. By; default, the histogram is drawn in low resolution in case the; number of bins is greater than the number of pixels in the current; pad. - ""`][`"": Draw histogram without the vertical lines for the first; and the last bin. Use it when superposing many histograms on the; same picture. The following options are supported for 2-D histogram classes:. - ""`ARR`"": Arrow mode. Shows gradient between adjacent cells. - ""`BOX`",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23228,Availability,error,error,23228,"l use the scatter plot option; ```. #### The SCATter Plot Option. By default, 2D histograms are drawn as scatter plots. For each cell; `(i,j)` a number of points proportional to the cell content are drawn.; A maximum of 500 points per cell are drawn. If the maximum is above; 500 contents are normalized to 500. #### The ARRow Option. The `ARR` option shows the gradient between adjacent cells. For each; cell `(i,j)` an arrow is drawn. The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defi",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23371,Availability,error,error,23371,"For each cell; `(i,j)` a number of points proportional to the cell content are drawn.; A maximum of 500 points per cell are drawn. If the maximum is above; 500 contents are normalized to 500. #### The ARRow Option. The `ARR` option shows the gradient between adjacent cells. For each; cell `(i,j)` an arrow is drawn. The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::Set",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23397,Availability,error,error,23397,"proportional to the cell content are drawn.; A maximum of 500 points per cell are drawn. If the maximum is above; 500 contents are normalized to 500. #### The ARRow Option. The `ARR` option shows the gradient between adjacent cells. For each; cell `(i,j)` an arrow is drawn. The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictu",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23476,Availability,error,error,23476,"m of 500 points per cell are drawn. If the maximum is above; 500 contents are normalized to 500. #### The ARRow Option. The `ARR` option shows the gradient between adjacent cells. For each; cell `(i,j)` an arrow is drawn. The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cel",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23552,Availability,error,error,23552,"re normalized to 500. #### The ARRow Option. The `ARR` option shows the gradient between adjacent cells. For each; cell `(i,j)` an arrow is drawn. The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text fo",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23705,Availability,error,errors,23705," The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/020",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23715,Availability,error,errors,23715," The orientation of the arrow follows; the cell gradient. #### The BOX Option. For each cell `(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/020",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23788,Availability,error,error,23788,"(i,j)` a box is drawn with surface proportional to; contents. The size of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/02000031.png). #### The CONTour Options. The following contour options are supported:. - `""CONT"":`",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23856,Availability,error,errors,23856,"of the box is proportional to the absolute value of; the cell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/02000031.png). #### The CONTour Options. The following contour options are supported:. - `""CONT"":` Draw a contour plot (same as CONT0). - `""CONT0"":` Draw a contour plot ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:23902,Availability,error,error,23902,"ell contents. The cells with negative contents are drawn with an; X on top of the boxes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/02000031.png). #### The CONTour Options. The following contour options are supported:. - `""CONT"":` Draw a contour plot (same as CONT0). - `""CONT0"":` Draw a contour plot using surface colors to distinguish; contours. - `""CONT1"":",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:24006,Availability,error,error,24006,"xes. With option `BOX1` a button is drawn for each; cell with surface proportional to contents' absolute value. A sunken; button is drawn for negative values, a raised one for positive values. #### The ERRor Bars Options. - `""E""` Default. Draw only error bars, without markers. - `""E0""` Draw also bins with 0 contents (turn off the symbols; clipping). - `""E1""` Draw small lines at the end of error bars. - `""E2""` Draw error rectangles. - `""E3""` Draw a fill area through the end points of vertical error; bars. - `""E4""` Draw a smoothed filled area through the end points of error; bars. ![The ""E1"" bars' option](pictures/0300002F.png). Note that for all options, the line and fill attributes of the; histogram are used for the errors or errors contours. Use; `gStyle->SetErrorX(dx)` to control the size of the error along x. The; parameter `dx` is a percentage of bin width for errors along `X`. Set; `dx=0` to suppress the error along `X`. Use; `gStyle->SetEndErrorSize(np)` to control the size of the lines at the; end of the error bars (when option 1 is used). By default `np=1`; (`np` represents the number of pixels). #### The Color Option. For each cell `(i,j)` a box is drawn with a color proportional to the; cell content. The color table used is defined in the current style; (***`gStyle`*** ). The color palette in **`TStyle`** can be modified; with **`TStyle`**`::SetPalette` . ![Different draw options](pictures/02000030.png). #### The TEXT Option. For each cell `(i,j)` the cell content is printed. The text attributes; are:. - Text font = current font set by **`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/02000031.png). #### The CONTour Options. The following contour options are supported:. - `""CONT"":` Draw a contour plot (same as CONT0). - `""CONT0"":` Draw a contour plot using surface colors to distinguish; contours. - `""CONT1"":` Draw a contour plot using line styles to distinguish; contours. - `""CONT2"":` Draw ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:32360,Availability,avail,available,32360," 2-D histogram with cells; represented by a box filled with a color index, which is a function of; the cell content. If the cell content is N, the color index used will; be the color number in `colors[N]` . If the maximum cell content is; greater than `ncolors` , all cell contents are scaled to `ncolors`. If; `ncolors<=0`, a default palette of 50 colors is defined. This palette; is recommended for pads, labels. It defines:. - Index 0 to 9: shades of gray; - Index 10 to 19:shades of brown; - Index 20 to 29:shades of blue; - Index 30 to 39: shades of red; - Index 40 to 49:basic colors. The color numbers specified in this palette can be viewed by selecting; the menu entry Colors in the View menu of the canvas menu bar. The; color's red, green, and blue values can be changed via; **`TColor`**`::SetRGB`. If `ncolors == 1 && colors == 0`, then a Pretty Palette with a; spectrum violet to red is created with 50 colors. That's the default; rain bow palette. Other predefined palettes with 255 colors are available when; `colors == 0`. The following value of `ncolors` (with `colors = 0`); give access to:. - `ncolors = 51` : Deep Sea palette.; - `ncolors = 52` : Grey Scale palette.; - `ncolors = 53` : Dark Body Radiator palette.; - `ncolors = 54` : Two-color hue palette palette. (dark blue through; neutral gray to bright yellow); - `ncolors = 55` : Rain Bow palette.; - `ncolors = 56` : Inverted Dark Body Radiator palette. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas toolbar.; The color parameters can be changed via `TColor::SetRGB`. Note that when drawing a 2D histogram `h2` with the option ""`COL`"" or; ""`COLZ`"" or with any ""`CONT`"" options using the color map, the number; of colors used is defined by the number of contours `n` specified; with: `h2->SetContour(n)`. #### TPaletteAxis. A **`TPaletteAxis`**object is used to display; the color palette when drawing 2D histograms. The object is; automatically c",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:34387,Availability,avail,available,34387," ""`z`"" is specified. It is added to the histogram list of functions.; It can be retrieved and its attributes can be changed with:. ``` {.cpp}; TPaletteAxis *palette=(TPaletteAxis*)h->FindObject(""palette"");; ```. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a; range on the axis, to set the min/max in z. #### The SPEC Option. The ""SPEC"" option offers a large set of options/attributes to; visualize 2D histograms thanks to ""operators"" following the ""SPEC""; keyword. For example, to draw the 2-D histogram `h2` using all default; attributes except the viewing angles, one can do:. ``` {.cpp}; h2->Draw(""SPEC a(30,30,0)"");; ```. The operators' names are case insensitive (i.e. one can use ""a"" or; ""A"") and their parameters are separated by coma "","". Operators can be; put in any order in the option and must be separated by a space "" "".; No space characters should be put in an operator. All the available; operators are described below. The way how a 2D histogram will be painted is controlled by two; parameters: the ""Display modes groups"" and the ""Display Modes"".; ""Display modes groups"" can take the following values:. - 0 = Simple - simple display modes using one color only; - 1 = Light - the shading is carried out according to the position; of the fictive light source; - 2 = Height - the shading is carried out according to the channel; contents; - 3 = LightHeight - combination of two previous shading algorithms; (one can control the weight between both algorithms). ""Display modes"" can take the following values:. - 1 = Points; - 2 = Grid; - 3 = Contours; - 4 = Bars; - 5 = LinesX; - 6 = LinesY; - 7 = BarsX; - 8 = BarsY; - 9 = Needles; - 10 = Surface; - 11 = Triangles. These parameters can be set by using the ""`dm`"" operator in the; option. ``` {.cpp}; h2->Draw(""SPEC dm(1,2)"");; ```. The above example draws the histogram using the ""Light Display mode; group"" and the ""Grid Display mode"". The fol",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45064,Availability,error,error,45064,"int1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; ```. ### Statistics Display. By default, a histogram drawing includes the statistics box. Use; **`TH1`**`::SetStats(kFALSE)` to eliminate the statistics box. If the; statistics box is drawn, `gStyle->SetOptStat(mode)` allow you to; select the type of displayed information `.` The parameter `mode` has; up to nine digits that can be set OFF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45142,Availability,error,error,45142,"int1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; ```. ### Statistics Display. By default, a histogram drawing includes the statistics box. Use; **`TH1`**`::SetStats(kFALSE)` to eliminate the statistics box. If the; statistics box is drawn, `gStyle->SetOptStat(mode)` allow you to; select the type of displayed information `.` The parameter `mode` has; up to nine digits that can be set OFF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45316,Availability,error,error,45316,"int1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; ```. ### Statistics Display. By default, a histogram drawing includes the statistics box. Use; **`TH1`**`::SetStats(kFALSE)` to eliminate the statistics box. If the; statistics box is drawn, `gStyle->SetOptStat(mode)` allow you to; select the type of displayed information `.` The parameter `mode` has; up to nine digits that can be set OFF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45387,Availability,error,error,45387,"int1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; ```. ### Statistics Display. By default, a histogram drawing includes the statistics box. Use; **`TH1`**`::SetStats(kFALSE)` to eliminate the statistics box. If the; statistics box is drawn, `gStyle->SetOptStat(mode)` allow you to; select the type of displayed information `.` The parameter `mode` has; up to nine digits that can be set OFF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45777,Availability,error,error,45777,"FF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAtt",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:45847,Availability,error,error,45847,"FF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAtt",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:46001,Availability,error,error,46001,"FF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAtt",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:46064,Availability,error,error,46064,"FF (0) or ON as follows:. `mode = ksiourmen` (`default =000001111`). - `n` = 1 the name of histogram is printed; - `e` = 1 the number of entries; - `m` = 1 the mean value; - `m` = 2 the mean and mean error values; - `r` = 1 the root mean square (RMS); - `r` = 2 the RMS and RMS error; - `u` = 1 the number of underflows; - `o` = 1 the number of overflows; - `i` = 1 the integral of bins; - `s` = 1 the skewness; - `s` = 2 the skewness and the skewness error; - `k` = 1 the kurtosis; - `k` = 2 the kurtosis and the kurtosis error. Never call `SetOptStat(0001111)` , but `SetOptStat(1111)` , because; `0001111` will be taken as an octal number. The method **`TStyle`**`::SetOptStat(Option_t*option)` can also be; called with a character string as a parameter. The parameter `option`; can contain:. - `n` for printing the name of histogram; - `e` the number of entries; - `m` the mean value; - `M` the mean and mean error values; - `r` the root mean square (RMS); - `R` the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAtt",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:49196,Availability,error,errors,49196,"tles are part of the persistent histogram. For example; if you wanted to write E with a subscript (T) you could use this:. ``` {.cpp}; h->GetXaxis()->SetTitle(""E_{T}"");; ```. For a complete explanation of the Latex mathematical expressions, see; ""Graphics and the Graphical User Interface"". It is also possible to; specify the histogram title and the axis titles at creation time.; These titles can be given in the ""title"" parameter. They must be; separated by ""**;**"":. ``` {.cpp}; TH1F* h=new TH1F(""h"",""Histogram title;X Axis;Y Axis;Z Axis"",; 100,0,1);; ```. Any title can be omitted:. ``` {.cpp}; TH1F* h=new TH1F(""h"",""Histogram title;;Y Axis"",100,0,1);; TH1F* h=new TH1F(""h"","";;Y Axis"",100,0,1);; ```. The method `SetTitle` has the same syntax:. ``` {.cpp}; h->SetTitle(""Histogram title;An other X title Axis"");; ```. ## Making a Copy of an Histogram. Like for any other ROOT object derived from **`TObject`** , the; `Clone` method can be used. This makes an identical copy of the; original histogram including all associated errors and functions:. ``` {.cpp}; TH1F *hnew = (TH1F*)h->Clone(); // renaming is recommended,; hnew->SetName(""hnew""); // because otherwise you will have; // two histograms with the same; // name; ```. ## Normalizing Histograms. You can scale a histogram ( **`TH1`** `*h` ) such that the bins; integral is equal to the normalization parameter norm:. ``` {.cpp}; Double_t scale = norm/h->Integral();; h->Scale(scale);; ```. ## Saving/Reading Histograms to/from a File. The following statements create a ROOT file and store a histogram on; the file. Because **`TH1`** derives from **`TNamed`** , the key; identifier on the file is the histogram name:. ``` {.cpp}; TFile f(""histos.root"",""new"");; TH1F h1(""hgaus"",""histo from a gaussian"",100,-3,3);; h1.FillRandom(""gaus"",10000);; h1->Write();; ```. To read this histogram in another ROOT session, do:. ``` {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ```. One can save all histograms in memory to the fi",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:52301,Availability,error,error,52301,"ntegral. Note that this; option ""`X`"" is much slower. - **`TH1`**`::Smooth` - smoothes the bin contents of a 1D histogram. - **`TH1`**`::Integral(Option_t *opt)-`returns the integral of bin; contents in a given bin range. If the option ""`width`"" is; specified, the integral is the sum of the bin contents multiplied; by the bin width in `x` . - **`TH1`**`::GetMean(int axis)` - returns the mean value along axis. - **`TH1`**`::GetStdDev(int axis)` - returns the sigma distribution along axis. - **`TH1`**`::GetRMS(int axis)` - returns the Root Mean Square; along axis. - **`TH1`**`::GetEntries()` - returns the number of entries. - **`TH1`**`::GetAsymmetry(`**`TH1`** `*h2,Double_t c2,Double_tdc2)`; - returns an histogram containing the asymmetry of this histogram; with `h2`, where the asymmetry is defined as:. ``` {.cpp}; Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this; ```. - It works for `1D` , `2D` , etc. histograms. The parameter `c2` is; an optional argument that gives a relative weight between the two; histograms, and `dc` `2` is the error on this weight. This is; useful, for example, when forming an asymmetry between two; histograms from two different data sets that need to be normalized; to each other in some way. The function calculates the errors; assuming Poisson statistics on `h1` and `h2`; (that is, `dh=sqrt(h)`). In the next example we assume that `h1`; and `h2` are already filled:. ``` {.cpp}; h3 = h1->GetAsymmetry(h2);; ```. - Then `h3` is created and filled with the asymmetry between `h1`; and `h2` ; `h1` and `h2` are left intact. - Note that the user's responsibility is to manage the created; histograms. - **`TH1`**`::Reset()` - resets the bin contents and errors of a; histogram. ## Important note on returned statistics (`GetMean`, `GetStdDev`, etc.). By default, histogram statistics are computed at fill time using the; unbinned data used to update the bin content. **This means the values; returned by `GetMean`, `GetStdDev`, etc., are those of the datas",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:52515,Availability,error,errors,52515,"he bin contents multiplied; by the bin width in `x` . - **`TH1`**`::GetMean(int axis)` - returns the mean value along axis. - **`TH1`**`::GetStdDev(int axis)` - returns the sigma distribution along axis. - **`TH1`**`::GetRMS(int axis)` - returns the Root Mean Square; along axis. - **`TH1`**`::GetEntries()` - returns the number of entries. - **`TH1`**`::GetAsymmetry(`**`TH1`** `*h2,Double_t c2,Double_tdc2)`; - returns an histogram containing the asymmetry of this histogram; with `h2`, where the asymmetry is defined as:. ``` {.cpp}; Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this; ```. - It works for `1D` , `2D` , etc. histograms. The parameter `c2` is; an optional argument that gives a relative weight between the two; histograms, and `dc` `2` is the error on this weight. This is; useful, for example, when forming an asymmetry between two; histograms from two different data sets that need to be normalized; to each other in some way. The function calculates the errors; assuming Poisson statistics on `h1` and `h2`; (that is, `dh=sqrt(h)`). In the next example we assume that `h1`; and `h2` are already filled:. ``` {.cpp}; h3 = h1->GetAsymmetry(h2);; ```. - Then `h3` is created and filled with the asymmetry between `h1`; and `h2` ; `h1` and `h2` are left intact. - Note that the user's responsibility is to manage the created; histograms. - **`TH1`**`::Reset()` - resets the bin contents and errors of a; histogram. ## Important note on returned statistics (`GetMean`, `GetStdDev`, etc.). By default, histogram statistics are computed at fill time using the; unbinned data used to update the bin content. **This means the values; returned by `GetMean`, `GetStdDev`, etc., are those of the dataset used; to fill the histogram**, not those of the binned content of the histogram; itself, **unless one of the axes has been zoomed**. (See the documentation; on `TH1::GetStats()`.) This is useful if you want to keep track of the; mean and standard deviation of the dataset you are visuali",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:52948,Availability,error,errors,52948,"c2,Double_tdc2)`; - returns an histogram containing the asymmetry of this histogram; with `h2`, where the asymmetry is defined as:. ``` {.cpp}; Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this; ```. - It works for `1D` , `2D` , etc. histograms. The parameter `c2` is; an optional argument that gives a relative weight between the two; histograms, and `dc` `2` is the error on this weight. This is; useful, for example, when forming an asymmetry between two; histograms from two different data sets that need to be normalized; to each other in some way. The function calculates the errors; assuming Poisson statistics on `h1` and `h2`; (that is, `dh=sqrt(h)`). In the next example we assume that `h1`; and `h2` are already filled:. ``` {.cpp}; h3 = h1->GetAsymmetry(h2);; ```. - Then `h3` is created and filled with the asymmetry between `h1`; and `h2` ; `h1` and `h2` are left intact. - Note that the user's responsibility is to manage the created; histograms. - **`TH1`**`::Reset()` - resets the bin contents and errors of a; histogram. ## Important note on returned statistics (`GetMean`, `GetStdDev`, etc.). By default, histogram statistics are computed at fill time using the; unbinned data used to update the bin content. **This means the values; returned by `GetMean`, `GetStdDev`, etc., are those of the dataset used; to fill the histogram**, not those of the binned content of the histogram; itself, **unless one of the axes has been zoomed**. (See the documentation; on `TH1::GetStats()`.) This is useful if you want to keep track of the; mean and standard deviation of the dataset you are visualizing with the histogram,; but it can lead to some unintuitive results. For example, suppose you have a histogram; with one bin between 0 and 100, then you fill it with a; Gaussian dataset with mean 20 and standard deviation 2:; ``` {.cpp}; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; ```; Right now, `h->GetMean()` will return 20 and `",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:58345,Availability,down,down,58345,"ar*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`** context menu by selecting the menu item; ""`LabelsOption` "" or by calling directly. ``` {.cpp}; TH1::LabelsOption(option,axis);; ```. Here `axis` may be X, Y, or Z. The parameter `option` may be:. - ""`a`"" sort by alphabetic order; - ""`>`"" sort by decreasing values; - ""`<`"" sort by increasing values; - ""`h`"" draw labels horizontal; - ""`v`"" draw labels vertical; - ""`u`"" draw labels up (end of label right adjusted); - ""`d`"" draw labels down (start of label left adjusted). When using the option second above, new labels are added by doubling; the current number of bins in case one label does not exist yet. When; the filling is terminated, it is possible to trim the number of bins; to match the number of active labels by calling:. ``` {.cpp}; TH1::LabelsDeflate(axis);; ```. Here `axis` may be X, Y, or Z. This operation is automatic when using; **`TTree`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:62226,Availability,error,error,62226,"TSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of X, it can be; displayed by a profile histogram with much better precision than by a; scatter-plot. Profile histograms display the mean value of Y and its; RMS for each bin in X. The following shows the contents; [capital letters] and the values shown in the graphics [small letters]; of the elements for bin j. When you fill a profile histogram with; **`TProfile`**`.Fill(x,y)` :. - `H[j]` will contain for each bin `j` the sum of the y values for; this bin. - `L[j]` contains the number of entries in the bin `j`. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; ```. In the special case where `s[j]` is zero, when there is only one entry; per bin, `e[j]` is computed from the average of the `s[j]` for all; bins. This approximation is used to keep the bin during a fit; operation. The **`TProfile`** constructor takes up to eight arguments.; The first five parameters are similar to **`TH1D`** constructor. ``` {.cpp}; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:63853,Availability,error,error,63853," Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. -",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:63923,Availability,error,error,63923," Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. -",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64416,Availability,error,errors,64416,"ing the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are dist",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64526,Availability,error,errors,64526,"` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64682,Availability,error,errors,64682,"ntegers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64822,Availability,error,errors,64822,". If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Prof",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64975,Availability,error,errors,64975,"of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and hig",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:66587,Availability,error,error,66587,"t with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ```. ![A profile histogram example](pictures/0300003E.png). ### Drawing a Profile without Error Bars. To draw a profile histogram and not show the error bars use the; ""`HIST`"" option in the **`TProfile`**`::Draw` method. This will draw; the outline of the **`TProfile`**. ### Create a Profile from a 2D Histogram. You can make a profile from a histogram using the methods; **`TH2`**`::ProfileX` and **`TH2`**`::ProfileY`. ### Create a Histogram from a Profile. To create a regular histogram from a profile histogram, use the method; **`TProfile`**`::ProjectionX` .This example instantiates a **`TH1D`**; object by copying the `TH1D` piece of **`TProfile`**. ``` {.cpp}; TH1D *sum = myProfile.ProjectionX();; ```. You can do the same with a 2D profile using the method; **`TProfile2D`**`::ProjectionXY` . ### Generating a Profile from a TTree. The `'prof'` and `'profs'` options in the **`TTree`**`::Draw` method; generate a profile histogram ( **`TProfile`** ), given a two; dimensional expression in the tree, or a **`TProfile2D`** given a; three dimensional expression. See ""Trees"". Note that you can specify; `'prof'` or `'profs'` : `'prof'` generates a **`T",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:67617,Availability,error,error,67617,"T`"" option in the **`TProfile`**`::Draw` method. This will draw; the outline of the **`TProfile`**. ### Create a Profile from a 2D Histogram. You can make a profile from a histogram using the methods; **`TH2`**`::ProfileX` and **`TH2`**`::ProfileY`. ### Create a Histogram from a Profile. To create a regular histogram from a profile histogram, use the method; **`TProfile`**`::ProjectionX` .This example instantiates a **`TH1D`**; object by copying the `TH1D` piece of **`TProfile`**. ``` {.cpp}; TH1D *sum = myProfile.ProjectionX();; ```. You can do the same with a 2D profile using the method; **`TProfile2D`**`::ProjectionXY` . ### Generating a Profile from a TTree. The `'prof'` and `'profs'` options in the **`TTree`**`::Draw` method; generate a profile histogram ( **`TProfile`** ), given a two; dimensional expression in the tree, or a **`TProfile2D`** given a; three dimensional expression. See ""Trees"". Note that you can specify; `'prof'` or `'profs'` : `'prof'` generates a **`TProfile`** with error; on the mean, `'profs'` generates a **`TProfile`** with error on the; spread. ### 2D Profiles. The class for a 2D Profile is called **`TProfile2D`** . It is in many; cases an elegant replacement of a three-dimensional histogram. The; relationship of three measured quantities X, Y and Z can be visualized; by a three-dimensional histogram or scatter-plot; its representation; is not particularly satisfactory, except for sparse data. If Z is an; unknown (but single-valued) function of (X,Y), it can be displayed; with a **`TProfile2D`** with better precision than by a scatter-plot.; A **`TProfile2D`** displays the mean value of Z and its RMS for each; cell in X, Y. The following shows the cumulated contents (capital; letters) and the values displayed (small letters) of the elements for; cell `i,j`. When you fill a profile histogram with **`TProfile2D`**`.Fill(x,y,z)`:. - `E[i,j]` contains for each bin `i,j` the sum of the z values for; this bin. - `L[i,j]` contains the number of ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:67679,Availability,error,error,67679,"T`"" option in the **`TProfile`**`::Draw` method. This will draw; the outline of the **`TProfile`**. ### Create a Profile from a 2D Histogram. You can make a profile from a histogram using the methods; **`TH2`**`::ProfileX` and **`TH2`**`::ProfileY`. ### Create a Histogram from a Profile. To create a regular histogram from a profile histogram, use the method; **`TProfile`**`::ProjectionX` .This example instantiates a **`TH1D`**; object by copying the `TH1D` piece of **`TProfile`**. ``` {.cpp}; TH1D *sum = myProfile.ProjectionX();; ```. You can do the same with a 2D profile using the method; **`TProfile2D`**`::ProjectionXY` . ### Generating a Profile from a TTree. The `'prof'` and `'profs'` options in the **`TTree`**`::Draw` method; generate a profile histogram ( **`TProfile`** ), given a two; dimensional expression in the tree, or a **`TProfile2D`** given a; three dimensional expression. See ""Trees"". Note that you can specify; `'prof'` or `'profs'` : `'prof'` generates a **`TProfile`** with error; on the mean, `'profs'` generates a **`TProfile`** with error on the; spread. ### 2D Profiles. The class for a 2D Profile is called **`TProfile2D`** . It is in many; cases an elegant replacement of a three-dimensional histogram. The; relationship of three measured quantities X, Y and Z can be visualized; by a three-dimensional histogram or scatter-plot; its representation; is not particularly satisfactory, except for sparse data. If Z is an; unknown (but single-valued) function of (X,Y), it can be displayed; with a **`TProfile2D`** with better precision than by a scatter-plot.; A **`TProfile2D`** displays the mean value of Z and its RMS for each; cell in X, Y. The following shows the cumulated contents (capital; letters) and the values displayed (small letters) of the elements for; cell `i,j`. When you fill a profile histogram with **`TProfile2D`**`.Fill(x,y,z)`:. - `E[i,j]` contains for each bin `i,j` the sum of the z values for; this bin. - `L[i,j]` contains the number of ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:68675,Availability,error,error,68675,"with error on the; spread. ### 2D Profiles. The class for a 2D Profile is called **`TProfile2D`** . It is in many; cases an elegant replacement of a three-dimensional histogram. The; relationship of three measured quantities X, Y and Z can be visualized; by a three-dimensional histogram or scatter-plot; its representation; is not particularly satisfactory, except for sparse data. If Z is an; unknown (but single-valued) function of (X,Y), it can be displayed; with a **`TProfile2D`** with better precision than by a scatter-plot.; A **`TProfile2D`** displays the mean value of Z and its RMS for each; cell in X, Y. The following shows the cumulated contents (capital; letters) and the values displayed (small letters) of the elements for; cell `i,j`. When you fill a profile histogram with **`TProfile2D`**`.Fill(x,y,z)`:. - `E[i,j]` contains for each bin `i,j` the sum of the z values for; this bin. - `L[i,j]` contains the number of entries in the bin j. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[i,j] = sum z; L[i,j] = sum l; h[i,j] = H[i,j ] / L[i,j]; s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**2]; e[i,j] = s[i,j] / sqrt[L[i,j]]; ```. In the special case where `s[i,j]` is zero, when there is only one; entry per cell, `e[i,j]` is computed from the average of the `s[i,j]`; for all cells. This approximation is used to keep the cell during a; fit operation. ![A TProfile2D histogram example](pictures/0800003F.png). ``` {.cpp}; {; // Creating a Canvas and a TProfile2D; TCanvas *c1 = new TCanvas(""c1"",; ""Profile histogram example"",; 200, 10,700,500);; hprof2d = new TProfile2D(""hprof2d"",; ""Profile of pz versus px and py"",; 40,-4,4,40,-4,4,0,20);. // Filling the TProfile2D with 25000 points; Float_t px, py, pz;; for (Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ```. ## Iso Surfaces. Paint one Gouraud shaded 3d iso surface though a 3d hi",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71740,Availability,error,error,71740," method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binn",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71772,Availability,error,errors,71772," method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binn",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71972,Availability,error,errors,71972," the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the re",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:72881,Availability,avail,available,72881,". #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. ![](pictures/03000045.png). To see the differences do:. ``` {.cpp}; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px"");// ntuple histogram; ```. #### Non ntuple histogram. Rebin with a slider and the number of bins (shown in the field below; the slider). The number of bins can be changed to any number, which; divides the number of bins of the original histogram. A click on the; Apply button will delete the origin histogram and will replace it by; the rebinned one on the screen. A click on the Ignore button will; restore the origin histogram. #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the slider, the number of bins can be enlarged by a factor; of 2, 3, 4, 5 (moving to the right) or reduced by a factor of; $\frac{1}{2}$, $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ####",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:75564,Availability,error,errors,75564,"# Style Tab:. ##### Title; set the title of the histogram. ##### Histogram; change the draw options of the histogram. ##### Plot; draw a 2D or 3D plot of the histogram; according to the dimension,; the drawing possibilities are different. #### 2-D Plot. ##### Contour; draw a contour plot (None, Cont0...5). ##### Cont \#; set the number of Contours;. ##### Arrow; set the arrow mode and shows the gradient between adjacent cells;. ##### Col; a box is drawn for each cell with a color scale varying with contents;. ##### Text; draw bin contents as text;. ##### Box; a box is drawn for each cell with surface proportional to contents;. ##### Scat; draw a scatter-plot (default);. ##### Palette; the color palette is drawn. #### 3-D Plot. ##### Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.);. ##### Cont \#; set the number of Contours (for e.g. Lego2 draw option);. ##### Errors; draw errors in a Cartesian lego plot;. ##### Palette; draw the color palette;. ##### Front; draw the front box of a Cartesian lego plot;. ##### Back; draw the back box of a Cartesian lego plot;. ##### Bar; change the bar attributes: the width and offset. #### Rebinning Tab. The Rebinning tab has two different layouts. One is for a histogram; that is not drawn from an ntuple; the other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. To see the differences do for example:. ``` {.cpp}; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; ```. #### Non-ntuple histogram:. Rebin with sliders (one for the x, one for the y-axis) and the number; of bins (shown in the field below them can be changed to any number,; which divides the number of bins of the original histogram. Selecting; the Apply button will de",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:75954,Availability,avail,available,75954,"row mode and shows the gradient between adjacent cells;. ##### Col; a box is drawn for each cell with a color scale varying with contents;. ##### Text; draw bin contents as text;. ##### Box; a box is drawn for each cell with surface proportional to contents;. ##### Scat; draw a scatter-plot (default);. ##### Palette; the color palette is drawn. #### 3-D Plot. ##### Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.);. ##### Cont \#; set the number of Contours (for e.g. Lego2 draw option);. ##### Errors; draw errors in a Cartesian lego plot;. ##### Palette; draw the color palette;. ##### Front; draw the front box of a Cartesian lego plot;. ##### Back; draw the back box of a Cartesian lego plot;. ##### Bar; change the bar attributes: the width and offset. #### Rebinning Tab. The Rebinning tab has two different layouts. One is for a histogram; that is not drawn from an ntuple; the other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. To see the differences do for example:. ``` {.cpp}; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; ```. #### Non-ntuple histogram:. Rebin with sliders (one for the x, one for the y-axis) and the number; of bins (shown in the field below them can be changed to any number,; which divides the number of bins of the original histogram. Selecting; the Apply button will delete the origin histogram and will replace it; by the rebinned one on the screen. Selecting the Ignore the origin; histogram will be restored. ![](pictures/03000049.png). #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the sliders the number of bins can be enlarged by a factor of; 2,3,4,5 (moving to the right) or reduced by a factor of $\fr",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:10222,Deployability,integrat,integrated,10222,"positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1`** histogram (for all dimensions). For example, the following; two statements create and fill a histogram 10 000 times with a default; Gaussian distribution of `mean` `0` and `sigma` `1` :. ``` {.cpp}; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; root[] h1.FillRandom(""gaus"",10000);; ```. **`TH1`**`::GetRandom()` can be used to get a random number; distributed according the contents of a histogram. To fill a histogram; following the distribution in an existing histogram you can use the; second signature of **`TH1`**`::FillRandom()`. Next code snipped; assumes that `h` is an existing histogram (**`TH1`** ). ``` {.cpp}; root[] TH1F h2(""h2"",""Histo from existing histo"",100,-3,3);; root[] h2.FillRandom(&h1, 1000);; ```. The distribution contained in the histogram `h1` ( **`TH1`** ) is; integrated over the channel contents. It is normalized to one. The; second parameter (1000) indicates how many random numbers are; generated. Getting 1 random number implies:. - Generating a random number between 0 and 1 (say `r1` ). - Find the bin in the normalized integral for `r1`. - Fill histogram channel. You can see below an example of the **`TH1`**`::GetRandom()` method; which can be used to get a random number distributed according; the contents of a histogram. ``` {.cpp}; void getrandomh() {; TH1F *source = new TH1F(""source"",""source hist"",100,-3,3);; source->FillRandom(""gaus"",1000);; TH1F *final = new TH1F(""final"",""final hist"",100,-3,3);. // continued... for (Int_t i=0;i<10000;i++) {; final->Fill(source->GetRandom());; }; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,2);; c1->cd(1);; source->Draw();; c1->cd(2);; final->Draw();; c1->cd();; }; ```. ## Adding, Dividing, and Multiplying. Many types of operations are supported on histograms or between;",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13722,Deployability,update,updated,13722," **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13740,Deployability,update,updated,13740,"e projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is return",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16070,Deployability,update,update,16070,"object. If a pad containing this copy is cleared, the; histogram will be automatically deleted. See ""Draw Options"" for the; list of options. ### Setting the Style. Histograms use the current style ***`gStyle`***, which is the global; object of class **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16194,Deployability,update,updated,16194,"object. If a pad containing this copy is cleared, the; histogram will be automatically deleted. See ""Draw Options"" for the; list of options. ### Setting the Style. Histograms use the current style ***`gStyle`***, which is the global; object of class **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:53137,Deployability,update,update,53137,"+ h2); //where h1 = this; ```. - It works for `1D` , `2D` , etc. histograms. The parameter `c2` is; an optional argument that gives a relative weight between the two; histograms, and `dc` `2` is the error on this weight. This is; useful, for example, when forming an asymmetry between two; histograms from two different data sets that need to be normalized; to each other in some way. The function calculates the errors; assuming Poisson statistics on `h1` and `h2`; (that is, `dh=sqrt(h)`). In the next example we assume that `h1`; and `h2` are already filled:. ``` {.cpp}; h3 = h1->GetAsymmetry(h2);; ```. - Then `h3` is created and filled with the asymmetry between `h1`; and `h2` ; `h1` and `h2` are left intact. - Note that the user's responsibility is to manage the created; histograms. - **`TH1`**`::Reset()` - resets the bin contents and errors of a; histogram. ## Important note on returned statistics (`GetMean`, `GetStdDev`, etc.). By default, histogram statistics are computed at fill time using the; unbinned data used to update the bin content. **This means the values; returned by `GetMean`, `GetStdDev`, etc., are those of the dataset used; to fill the histogram**, not those of the binned content of the histogram; itself, **unless one of the axes has been zoomed**. (See the documentation; on `TH1::GetStats()`.) This is useful if you want to keep track of the; mean and standard deviation of the dataset you are visualizing with the histogram,; but it can lead to some unintuitive results. For example, suppose you have a histogram; with one bin between 0 and 100, then you fill it with a; Gaussian dataset with mean 20 and standard deviation 2:; ``` {.cpp}; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; ```; Right now, `h->GetMean()` will return 20 and `h->GetStdDev()` will return 2;; ROOT calculated these values as we filled `h`.; Next, zoom in on the Gaussian:; ``` {.cpp}; h->GetXaxis()->SetRangeUser(10, 30);; ```; No",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:74406,Deployability,update,updated,74406,"es the number of bins of the original histogram. A click on the; Apply button will delete the origin histogram and will replace it by; the rebinned one on the screen. A click on the Ignore button will; restore the origin histogram. #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the slider, the number of bins can be enlarged by a factor; of 2, 3, 4, 5 (moving to the right) or reduced by a factor of; $\frac{1}{2}$, $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset with a BinOffset slider; the origin of the histogram can be; changed within one binwidth. Using this slider the effect of binning; the data into bins can be made visible (statistical fluctuations). ##### Axis Range; with a double slider it is possible to zoom into the; specified axis range. It is also possible to set the upper and lower; limit in fields below the slider. ##### Delayed drawing; all the Binning sliders can set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is time consuming. ### TH2Editor. ![](pictures/03000047.png). #### Style Tab:. ##### Title; set the title of the histogram. ##### Histogram; change the draw options of the histogram. ##### Plot; draw a 2D or 3D plot of the histogram; according to the dimension,; the drawing possibilities are different. #### 2-D Plot. ##### Contour; draw a contour plot (None, Cont0...5). ##### Cont \#; set the number of Contours;. ##### Arrow; set the arrow mode and shows the gradient between adjacent cells;. ##### Col; a box is drawn for each cell with a color scale varying with contents;. ##### Text; draw bin contents as text;. ##### Box; a box is drawn for each cell with surface proportional to contents;. ##### Scat; draw a scatter-plot (default);. ##### Palette; the color palette is drawn. #### 3-D Plot. ##### Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf,; Surf1...5). ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:74435,Deployability,release,released,74435,"es the number of bins of the original histogram. A click on the; Apply button will delete the origin histogram and will replace it by; the rebinned one on the screen. A click on the Ignore button will; restore the origin histogram. #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the slider, the number of bins can be enlarged by a factor; of 2, 3, 4, 5 (moving to the right) or reduced by a factor of; $\frac{1}{2}$, $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset with a BinOffset slider; the origin of the histogram can be; changed within one binwidth. Using this slider the effect of binning; the data into bins can be made visible (statistical fluctuations). ##### Axis Range; with a double slider it is possible to zoom into the; specified axis range. It is also possible to set the upper and lower; limit in fields below the slider. ##### Delayed drawing; all the Binning sliders can set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is time consuming. ### TH2Editor. ![](pictures/03000047.png). #### Style Tab:. ##### Title; set the title of the histogram. ##### Histogram; change the draw options of the histogram. ##### Plot; draw a 2D or 3D plot of the histogram; according to the dimension,; the drawing possibilities are different. #### 2-D Plot. ##### Contour; draw a contour plot (None, Cont0...5). ##### Cont \#; set the number of Contours;. ##### Arrow; set the arrow mode and shows the gradient between adjacent cells;. ##### Col; a box is drawn for each cell with a color scale varying with contents;. ##### Text; draw bin contents as text;. ##### Box; a box is drawn for each cell with surface proportional to contents;. ##### Scat; draw a scatter-plot (default);. ##### Palette; the color palette is drawn. #### 3-D Plot. ##### Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf,; Surf1...5). ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:77507,Deployability,update,updated,77507,"lette;. ##### Front; draw the front box of a Cartesian lego plot;. ##### Back; draw the back box of a Cartesian lego plot;. ##### Bar; change the bar attributes: the width and offset. #### Rebinning Tab. The Rebinning tab has two different layouts. One is for a histogram; that is not drawn from an ntuple; the other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. To see the differences do for example:. ``` {.cpp}; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; ```. #### Non-ntuple histogram:. Rebin with sliders (one for the x, one for the y-axis) and the number; of bins (shown in the field below them can be changed to any number,; which divides the number of bins of the original histogram. Selecting; the Apply button will delete the origin histogram and will replace it; by the rebinned one on the screen. Selecting the Ignore the origin; histogram will be restored. ![](pictures/03000049.png). #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the sliders the number of bins can be enlarged by a factor of; 2,3,4,5 (moving to the right) or reduced by a factor of $\frac{1}{2}$,; $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset; with the BinOffset slider the origin of the histogram can; be changed within one binwidth. Using this slider the effect of; binning the data into bins can be made visible (=\> statistical; fluctuations). ##### Axis Range; with a double slider that gives the possibility for; zooming. It is also possible to set the upper and lower limit in; fields below the slider. ##### Delayed drawing; all the binning sliders can be set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is too time consuming.; ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:77536,Deployability,release,released,77536,"lette;. ##### Front; draw the front box of a Cartesian lego plot;. ##### Back; draw the back box of a Cartesian lego plot;. ##### Bar; change the bar attributes: the width and offset. #### Rebinning Tab. The Rebinning tab has two different layouts. One is for a histogram; that is not drawn from an ntuple; the other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. To see the differences do for example:. ``` {.cpp}; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; ```. #### Non-ntuple histogram:. Rebin with sliders (one for the x, one for the y-axis) and the number; of bins (shown in the field below them can be changed to any number,; which divides the number of bins of the original histogram. Selecting; the Apply button will delete the origin histogram and will replace it; by the rebinned one on the screen. Selecting the Ignore the origin; histogram will be restored. ![](pictures/03000049.png). #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the sliders the number of bins can be enlarged by a factor of; 2,3,4,5 (moving to the right) or reduced by a factor of $\frac{1}{2}$,; $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset; with the BinOffset slider the origin of the histogram can; be changed within one binwidth. Using this slider the effect of; binning the data into bins can be made visible (=\> statistical; fluctuations). ##### Axis Range; with a double slider that gives the possibility for; zooming. It is also possible to set the upper and lower limit in; fields below the slider. ##### Delayed drawing; all the binning sliders can be set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is too time consuming.; ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:32095,Energy Efficiency,green,green,32095," hist->GetZaxis()->SetLabelSize();; ```. #### Setting the Color Palette. You can set the color palette with **`TStyle`**`::SetPalette` , e.g. ``` {.cpp}; gStyle->SetPalette(ncolors,colors);; ```. For example, the option `COL` draws a 2-D histogram with cells; represented by a box filled with a color index, which is a function of; the cell content. If the cell content is N, the color index used will; be the color number in `colors[N]` . If the maximum cell content is; greater than `ncolors` , all cell contents are scaled to `ncolors`. If; `ncolors<=0`, a default palette of 50 colors is defined. This palette; is recommended for pads, labels. It defines:. - Index 0 to 9: shades of gray; - Index 10 to 19:shades of brown; - Index 20 to 29:shades of blue; - Index 30 to 39: shades of red; - Index 40 to 49:basic colors. The color numbers specified in this palette can be viewed by selecting; the menu entry Colors in the View menu of the canvas menu bar. The; color's red, green, and blue values can be changed via; **`TColor`**`::SetRGB`. If `ncolors == 1 && colors == 0`, then a Pretty Palette with a; spectrum violet to red is created with 50 colors. That's the default; rain bow palette. Other predefined palettes with 255 colors are available when; `colors == 0`. The following value of `ncolors` (with `colors = 0`); give access to:. - `ncolors = 51` : Deep Sea palette.; - `ncolors = 52` : Grey Scale palette.; - `ncolors = 53` : Dark Body Radiator palette.; - `ncolors = 54` : Two-color hue palette palette. (dark blue through; neutral gray to bright yellow); - `ncolors = 55` : Rain Bow palette.; - `ncolors = 56` : Inverted Dark Body Radiator palette. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas toolbar.; The color parameters can be changed via `TColor::SetRGB`. Note that when drawing a 2D histogram `h2` with the option ""`COL`"" or; ""`COLZ`"" or with any ""`CONT`"" options using the color map, the number; of ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:73813,Energy Efficiency,reduce,reduced,73813,"o different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. ![](pictures/03000045.png). To see the differences do:. ``` {.cpp}; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px"");// ntuple histogram; ```. #### Non ntuple histogram. Rebin with a slider and the number of bins (shown in the field below; the slider). The number of bins can be changed to any number, which; divides the number of bins of the original histogram. A click on the; Apply button will delete the origin histogram and will replace it by; the rebinned one on the screen. A click on the Ignore button will; restore the origin histogram. #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the slider, the number of bins can be enlarged by a factor; of 2, 3, 4, 5 (moving to the right) or reduced by a factor of; $\frac{1}{2}$, $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset with a BinOffset slider; the origin of the histogram can be; changed within one binwidth. Using this slider the effect of binning; the data into bins can be made visible (statistical fluctuations). ##### Axis Range; with a double slider it is possible to zoom into the; specified axis range. It is also possible to set the upper and lower; limit in fields below the slider. ##### Delayed drawing; all the Binning sliders can set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is time consuming. ### TH2Editor. ![](pictures/03000047.png). #### Style Tab:. ##### Title; set the title of the histogram. ##### Histogram; change the draw options of the histogram. ##### Plot; draw a 2D or 3D plot of the histogram; according to the dimension,; the drawing pos",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:76918,Energy Efficiency,reduce,reduced,76918,"lette;. ##### Front; draw the front box of a Cartesian lego plot;. ##### Back; draw the back box of a Cartesian lego plot;. ##### Bar; change the bar attributes: the width and offset. #### Rebinning Tab. The Rebinning tab has two different layouts. One is for a histogram; that is not drawn from an ntuple; the other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. To see the differences do for example:. ``` {.cpp}; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; ```. #### Non-ntuple histogram:. Rebin with sliders (one for the x, one for the y-axis) and the number; of bins (shown in the field below them can be changed to any number,; which divides the number of bins of the original histogram. Selecting; the Apply button will delete the origin histogram and will replace it; by the rebinned one on the screen. Selecting the Ignore the origin; histogram will be restored. ![](pictures/03000049.png). #### Histogram drawn from an ntuple. ##### Rebin; \index{histogram!rebin}; with the sliders the number of bins can be enlarged by a factor of; 2,3,4,5 (moving to the right) or reduced by a factor of $\frac{1}{2}$,; $\frac{1}{3}$, $\frac{1}{4}$, $\frac{1}{5}$. ##### BinOffset; with the BinOffset slider the origin of the histogram can; be changed within one binwidth. Using this slider the effect of; binning the data into bins can be made visible (=\> statistical; fluctuations). ##### Axis Range; with a double slider that gives the possibility for; zooming. It is also possible to set the upper and lower limit in; fields below the slider. ##### Delayed drawing; all the binning sliders can be set to delay draw mode.; Then the changes on the histogram are only updated, when the Slider is; released. This should be activated if the redrawing of the histogram; is too time consuming.; ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:720,Integrability,depend,depending,720,"# Histograms. This chapter covers the functionality of the histogram classes. We; begin with an overview of the histogram classes, after which we; provide instructions and examples on the histogram features. We have put this chapter ahead of the graphics chapter so that you can; begin working with histograms as soon as possible. Some of the; examples have graphics commands that may look unfamiliar to you. These; are covered in the chapter ""Input/Output"". ## The Histogram Classes; \index{histogram}. ROOT supports histograms up to three dimensions. Separate concrete; classes are provided for one-dimensional, two-dimensional and; three-dimensional classes. The histogram classes are split into; further categories, depending on the set of possible bin values:. - **`TH1C, TH2C and TH3C`** contain one char (one byte) per bin; (maximum bin content = 255). - **`TH1S, TH2S and TH3S`** contain one short (two bytes) per bin; (maximum bin content = 65 535). - **`TH1I, TH2I and TH3I`** contain one integer (four bytes) per bin; (maximum bin content = 2 147 483 647).; ; - **`TH1L, TH2L and TH3L`** contain one long64 (eight bytes) per bin; (maximum bin content = 9 223 372 036 854 775 807). - **`TH1F, TH2F and TH3F`** contain one float (four bytes) per bin; (maximum precision = 7 digits). - **`TH1D, TH2D and TH3D`** contain one double (eight bytes) per bin; (maximum precision = 14 digits). ROOT also supports profile histograms, which constitute an elegant; replacement of two-dimensional histograms in many cases. The; inter-relation of two measured quantities X and Y can always be; visualized with a two-dimensional histogram or scatter-plot. Profile; histograms, on the other hand, are used to display the mean value of Y; and its RMS for each bin in X. If Y is an unknown but single-valued; approximate function of X, it will have greater precision in a profile; histogram than in a scatter plot. - **`TProfile`** : one dimensional profiles. - **`TProfile2D`** : two dimensional profiles. ![",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:10222,Integrability,integrat,integrated,10222,"positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1`** histogram (for all dimensions). For example, the following; two statements create and fill a histogram 10 000 times with a default; Gaussian distribution of `mean` `0` and `sigma` `1` :. ``` {.cpp}; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; root[] h1.FillRandom(""gaus"",10000);; ```. **`TH1`**`::GetRandom()` can be used to get a random number; distributed according the contents of a histogram. To fill a histogram; following the distribution in an existing histogram you can use the; second signature of **`TH1`**`::FillRandom()`. Next code snipped; assumes that `h` is an existing histogram (**`TH1`** ). ``` {.cpp}; root[] TH1F h2(""h2"",""Histo from existing histo"",100,-3,3);; root[] h2.FillRandom(&h1, 1000);; ```. The distribution contained in the histogram `h1` ( **`TH1`** ) is; integrated over the channel contents. It is normalized to one. The; second parameter (1000) indicates how many random numbers are; generated. Getting 1 random number implies:. - Generating a random number between 0 and 1 (say `r1` ). - Find the bin in the normalized integral for `r1`. - Fill histogram channel. You can see below an example of the **`TH1`**`::GetRandom()` method; which can be used to get a random number distributed according; the contents of a histogram. ``` {.cpp}; void getrandomh() {; TH1F *source = new TH1F(""source"",""source hist"",100,-3,3);; source->FillRandom(""gaus"",1000);; TH1F *final = new TH1F(""final"",""final hist"",100,-3,3);. // continued... for (Int_t i=0;i<10000;i++) {; final->Fill(source->GetRandom());; }; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,2);; c1->cd(1);; source->Draw();; c1->cd(2);; final->Draw();; c1->cd();; }; ```. ## Adding, Dividing, and Multiplying. Many types of operations are supported on histograms or between;",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:62232,Integrability,depend,depending,62232,"TSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of X, it can be; displayed by a profile histogram with much better precision than by a; scatter-plot. Profile histograms display the mean value of Y and its; RMS for each bin in X. The following shows the contents; [capital letters] and the values shown in the graphics [small letters]; of the elements for bin j. When you fill a profile histogram with; **`TProfile`**`.Fill(x,y)` :. - `H[j]` will contain for each bin `j` the sum of the y values for; this bin. - `L[j]` contains the number of entries in the bin `j`. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; ```. In the special case where `s[j]` is zero, when there is only one entry; per bin, `e[j]` is computed from the average of the `s[j]` for all; bins. This approximation is used to keep the bin during a fit; operation. The **`TProfile`** constructor takes up to eight arguments.; The first five parameters are similar to **`TH1D`** constructor. ``` {.cpp}; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:68681,Integrability,depend,depending,68681,"with error on the; spread. ### 2D Profiles. The class for a 2D Profile is called **`TProfile2D`** . It is in many; cases an elegant replacement of a three-dimensional histogram. The; relationship of three measured quantities X, Y and Z can be visualized; by a three-dimensional histogram or scatter-plot; its representation; is not particularly satisfactory, except for sparse data. If Z is an; unknown (but single-valued) function of (X,Y), it can be displayed; with a **`TProfile2D`** with better precision than by a scatter-plot.; A **`TProfile2D`** displays the mean value of Z and its RMS for each; cell in X, Y. The following shows the cumulated contents (capital; letters) and the values displayed (small letters) of the elements for; cell `i,j`. When you fill a profile histogram with **`TProfile2D`**`.Fill(x,y,z)`:. - `E[i,j]` contains for each bin `i,j` the sum of the z values for; this bin. - `L[i,j]` contains the number of entries in the bin j. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[i,j] = sum z; L[i,j] = sum l; h[i,j] = H[i,j ] / L[i,j]; s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**2]; e[i,j] = s[i,j] / sqrt[L[i,j]]; ```. In the special case where `s[i,j]` is zero, when there is only one; entry per cell, `e[i,j]` is computed from the average of the `s[i,j]`; for all cells. This approximation is used to keep the cell during a; fit operation. ![A TProfile2D histogram example](pictures/0800003F.png). ``` {.cpp}; {; // Creating a Canvas and a TProfile2D; TCanvas *c1 = new TCanvas(""c1"",; ""Profile histogram example"",; 200, 10,700,500);; hprof2d = new TProfile2D(""hprof2d"",; ""Profile of pz versus px and py"",; 40,-4,4,40,-4,4,0,20);. // Filling the TProfile2D with 25000 points; Float_t px, py, pz;; for (Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ```. ## Iso Surfaces. Paint one Gouraud shaded 3d iso surface though a 3d hi",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71422,Integrability,interface,interface,71422," to draw a **`TPie`** are:. - ""`R`"" Paint the labels along the central ""`R`""adius of slices. - ""`T`"" Paint the labels in a direction ""`T`""angent to circle that; describes the TPie. - ""`3D`"" Draw the pie-chart with a pseudo 3D effect. - ""`NOL`"" No OutLine: do not draw the slices' outlines; any property; over the slices' line is ignored. The method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw h",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:72326,Integrability,interface,interface,72326," The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the rebin; algorithm can create a rebinned histogram from the original data i.e.; the ntuple. ![](pictures/03000045.png). To see the differences do:. ``` {.cpp}; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px"");// ntuple histogram; ```. #### Non ntuple histogram. Rebin with a slider and the number of bins (shown in the field below;",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:4357,Modifiability,variab,variable,4357,"ctionX(); // ! TH1D, not TH1F; TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F; ```. ### Constant or Variable Bin Width. The histogram classes provide a variety of ways to construct a; histogram, but the most common way is to provide the name and title of; histogram and for each dimension: the number of bins, the minimum x; (lower edge of the first bin) and the maximum x (upper edge of the; last bin). ``` {.cpp}; TH2* h = new TH2D(; /* name */ ""h2"",; /* title */ ""Hist with constant bin width"",; /* X-dimension */ 100, 0.0, 4.0,; /* Y-dimension */ 200, -3.0, 1.5);; ```. When employing this constructor, you will create a histogram with; constant (fixed) bin width on each axis. For the example above, the; interval `[0.0, 4.0]` is divided into 100 bins of the same width `w`; `X = 4.0 - 0.0 100 = 0.04` for the X axis (dimension). Likewise, for; the Y axis (dimension), we have bins of equal width `w`; `Y = 1.5 - (-3.0) 200 = 0.0225`. If you want to create histograms with variable bin widths, ROOT; provides another constructor suited for this purpose. Instead of; passing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:4935,Modifiability,variab,variable,4935,";; ```. When employing this constructor, you will create a histogram with; constant (fixed) bin width on each axis. For the example above, the; interval `[0.0, 4.0]` is divided into 100 bins of the same width `w`; `X = 4.0 - 0.0 100 = 0.04` for the X axis (dimension). Likewise, for; the Y axis (dimension), we have bins of equal width `w`; `Y = 1.5 - (-3.0) 200 = 0.0225`. If you want to create histograms with variable bin widths, ROOT; provides another constructor suited for this purpose. Instead of; passing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetB",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6147,Modifiability,variab,variable,6147,"histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogr",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6220,Modifiability,variab,variable,6220," the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recompu",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:8404,Modifiability,extend,extend,8404,"x,y,z);; h3->Fill(x,y,z,w);; ```. The `Fill` method computes the bin number corresponding to the given; x, y or z argument and increments this bin by the given weight. The; `Fill()` method returns the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and access the bin content of a given; bin via **`TH1`**`::GetBinContent()` . ``` {.cpp}; Double_t binContent = h->GetBinContent(bin);; ```. ### Automatic Re-binning Option. By default, the number of bins is computed using the range of the; axis. You can change this to re-bin automatically by setting the; automatic re-binning option:. ``` {.cpp}; h->SetBit(TH1::kCanRebin);; ```; \index{histogram!rebin}. Once this is set, the `Fill()` method will automatically extend the; axis range to accommodate the new value specified in the `Fill()`; argument. The used method is to double the bin size until the new; value fits in the range, merging bins two by two. The; **`TTree`**`::Draw()` method extensively uses this automatic binning; option when drawing histograms of variables in **`TTree`** with an; unknown range. The automatic binning option is supported for 1-D, 2-D; and 3-D histograms. During filling, some statistics parameters are; incremented to compute the mean value and root mean square with the; maximum precision. In case of histograms of type **`TH1C`**,; **`TH1S`**, **`TH2C`**, **`TH2S`**, **`TH3C`**, **`TH3S`** a check is; made that the bin contents do not exceed the maximum positive capacity; (127 or 65 535). Histograms of all types may have positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:8709,Modifiability,variab,variables,8709,"D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and access the bin content of a given; bin via **`TH1`**`::GetBinContent()` . ``` {.cpp}; Double_t binContent = h->GetBinContent(bin);; ```. ### Automatic Re-binning Option. By default, the number of bins is computed using the range of the; axis. You can change this to re-bin automatically by setting the; automatic re-binning option:. ``` {.cpp}; h->SetBit(TH1::kCanRebin);; ```; \index{histogram!rebin}. Once this is set, the `Fill()` method will automatically extend the; axis range to accommodate the new value specified in the `Fill()`; argument. The used method is to double the bin size until the new; value fits in the range, merging bins two by two. The; **`TTree`**`::Draw()` method extensively uses this automatic binning; option when drawing histograms of variables in **`TTree`** with an; unknown range. The automatic binning option is supported for 1-D, 2-D; and 3-D histograms. During filling, some statistics parameters are; incremented to compute the mean value and root mean square with the; maximum precision. In case of histograms of type **`TH1C`**,; **`TH1S`**, **`TH2C`**, **`TH2S`**, **`TH3C`**, **`TH3S`** a check is; made that the bin contents do not exceed the maximum positive capacity; (127 or 65 535). Histograms of all types may have positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1`** histogram (for all dimensions). For example, the following; two statements create and fill a histogram 10 000 times with a default; Gaussian distribution of `mean` `0` and `sigma` `1` :. ``` {.cpp}; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16391,Modifiability,inherit,inherited,16391," **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": Use spherical coordinates. - ""`PSR`"": Use pseudo-rapidity/phi coordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell;",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:46789,Modifiability,inherit,inherit,46789," the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAttMarker`** and **`TAttText`**.; See the description of these classes for the list of options. ### Setting Tick Marks on the Axis. The **`TPad`**`::SetTicks()` method specifies the type of tick; marks on the axis. Let `tx=gPad->GetTickx()` and; `ty=gPad->GetTicky()`. - `tx` = 1; tick marks on top side are drawn (inside); - `tx` = 2; tick marks and labels on top side are drawn; - `ty` = 1; tick marks on right side are drawn (inside); - `ty` = 2; tick marks and labels on right side are drawn; - `tx=ty=0` by default only the left Y axis and X bottom axis are; drawn. Use **`TPad`**`::SetTicks(tx,ty)` to set these options. See also; the methods of **`TAxis`** that set specific axis attributes. If; multiple color-filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force the axis redrawing; over all the histograms by calling:. ``` {.cpp}; gPad->RedrawAxis();; ```. ### Giving Titles to the X, Y and Z Axis. Because t",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:56886,Modifiability,variab,variable,56886,") h->Fill(85);; ```; results in `GetMean` and `GetStdDev` returning 67.5 and 17.5, respectively;; you must call `TH1::ResetStats` again to get consistent binned statistics. ## Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels. One; can specify alphanumeric labels instead. ### Option 1: SetBinLabel. To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`*",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:57094,Modifiability,variab,variable,57094," default, a histogram axis is drawn with its numeric bin labels. One; can specify alphanumeric labels instead. ### Option 1: SetBinLabel. To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`** context menu by selecting the menu item; ""`LabelsOption` "" or by calling directly. ``` {.cpp}; TH1::LabelsOption(option,axis);; ```. Here `axis` may be X, Y, or Z. The parameter `option` may be:. - ""`",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:57216,Modifiability,variab,variable,57216," To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`** context menu by selecting the menu item; ""`LabelsOption` "" or by calling directly. ``` {.cpp}; TH1::LabelsOption(option,axis);; ```. Here `axis` may be X, Y, or Z. The parameter `option` may be:. - ""`a`"" sort by alphabetic order; - ""`>`"" sort by decreasing values; - ""`<`"" sort by increasing values; - ""`h`"" draw labels horizontal; - ""`v",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:63166,Modifiability,variab,variable,63166,"ntains the number of entries in the bin `j`. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; ```. In the special case where `s[j]` is zero, when there is only one entry; per bin, `e[j]` is computed from the average of the `s[j]` for all; bins. This approximation is used to keep the bin during a fit; operation. The **`TProfile`** constructor takes up to eight arguments.; The first five parameters are similar to **`TH1D`** constructor. ``` {.cpp}; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64174,Modifiability,variab,variable,64174,"he variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y value",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64304,Modifiability,variab,variable,64304,"arded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; betwe",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:65425,Modifiability,variab,variables,65425," data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ```. ![A p",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:5309,Security,access,access,5309,"Y = 1.5 - (-3.0) 200 = 0.0225`. If you want to create histograms with variable bin widths, ROOT; provides another constructor suited for this purpose. Instead of; passing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, ma",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:5458,Security,access,accessing,5458,"ssing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow.",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6308,Security,access,access,6308," access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with stateme",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6933,Security,access,access,6933,"nLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with statements like:. ``` {.cpp}; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; ```. The `Fill` method computes the bin number corresponding to the given; x, y or z argument and increments this bin by the given weight. The; `Fill()` method returns the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and acce",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:7944,Security,access,access,7944,"This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with statements like:. ``` {.cpp}; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; ```. The `Fill` method computes the bin number corresponding to the given; x, y or z argument and increments this bin by the given weight. The; `Fill()` method returns the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and access the bin content of a given; bin via **`TH1`**`::GetBinContent()` . ``` {.cpp}; Double_t binContent = h->GetBinContent(bin);; ```. ### Automatic Re-binning Option. By default, the number of bins is computed using the range of the; axis. You can change this to re-bin automatically by setting the; automatic re-binning option:. ``` {.cpp}; h->SetBit(TH1::kCanRebin);; ```; \index{histogram!rebin}. Once this is set, the `Fill()` method will automatically extend the; axis range to accommodate the new value specified in the `Fill()`; argument. The used method is to double the bin size until the new; value fits in the range, merging bins two by two. The; **`TTree`**`::Draw()` method extensively uses this automatic binning; option when drawing histograms of variables in **`TTree`** with an; unknown range. The automatic binning option is supported for 1-D, 2-D; and 3-D histograms. During filling, some statistics parameters are; incremented to compute",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:25611,Security,access,accessible,25611,"`TStyle`**. - Text size= 0.02 \* pad-height \* marker-size. - Text color= marker color. ![The TEXT option](pictures/02000031.png). #### The CONTour Options. The following contour options are supported:. - `""CONT"":` Draw a contour plot (same as CONT0). - `""CONT0"":` Draw a contour plot using surface colors to distinguish; contours. - `""CONT1"":` Draw a contour plot using line styles to distinguish; contours. - `""CONT2"":` Draw a contour plot using the same line style for all; contours. - `""CONT3"":` Draw a contour plot using fill area colors. - `""CONT4"":`Draw a contour plot using surface colors (SURF2 option; at theta = 0); see also options ""`AITOFF`"", ""`MERCATOR`"", etc.; below. - `""CONT5"":` Use Delaunay triangles to compute the contours. ![Different contour options](pictures/02000032.png). The default number of contour levels is 20 equidistant levels. It can; be changed with **`TH1`**`::SetContour`. When option ""`LIST`"" is; specified together with option ""`CONT`"", all points used for contour; drawing, are saved in the **`TGraph`** object and are accessible in; the following way:. ``` {.cpp}; TObjArray *contours =; gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize(); TList *list =; (TList*)contours->At(i);; ```. Where ""`i`"" is a contour number and list contains a list of; **`TGraph`** objects. For one given contour, more than one disjoint; poly-line may be generated. The **`TGraph`** numbers per contour are; given by `list->GetSize()`. Here we show how to access the first graph; in the list. ``` {.cpp}; TGraph *gr1 = (TGraph*)list->First();; ```. - ""`AITOFF`"": Draw a contour via an AITOFF projection. - ""`MERCATOR`"": Draw a contour via a Mercator projection. - ""`SINUSOIDAL`"": Draw a contour via a Sinusoidal projection. - ""`PARABOLIC`"": Draw a contour via a Parabolic projection. The tutorial macro `earth.C` uses these four options and produces the; following picture:. ![The `earth.C` macro output](pictures/03000033.png). #### The LEGO",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:26067,Security,access,access,26067,"sing fill area colors. - `""CONT4"":`Draw a contour plot using surface colors (SURF2 option; at theta = 0); see also options ""`AITOFF`"", ""`MERCATOR`"", etc.; below. - `""CONT5"":` Use Delaunay triangles to compute the contours. ![Different contour options](pictures/02000032.png). The default number of contour levels is 20 equidistant levels. It can; be changed with **`TH1`**`::SetContour`. When option ""`LIST`"" is; specified together with option ""`CONT`"", all points used for contour; drawing, are saved in the **`TGraph`** object and are accessible in; the following way:. ``` {.cpp}; TObjArray *contours =; gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize(); TList *list =; (TList*)contours->At(i);; ```. Where ""`i`"" is a contour number and list contains a list of; **`TGraph`** objects. For one given contour, more than one disjoint; poly-line may be generated. The **`TGraph`** numbers per contour are; given by `list->GetSize()`. Here we show how to access the first graph; in the list. ``` {.cpp}; TGraph *gr1 = (TGraph*)list->First();; ```. - ""`AITOFF`"": Draw a contour via an AITOFF projection. - ""`MERCATOR`"": Draw a contour via a Mercator projection. - ""`SINUSOIDAL`"": Draw a contour via a Sinusoidal projection. - ""`PARABOLIC`"": Draw a contour via a Parabolic projection. The tutorial macro `earth.C` uses these four options and produces the; following picture:. ![The `earth.C` macro output](pictures/03000033.png). #### The LEGO Options. In a lego plot, the cell contents are drawn as 3D boxes, with the; height of the box proportional to the cell content. ![""LEGO"" and ""SURF"" options](pictures/02000034.png). - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell contents. A lego plot can be represented in several coordinate systems; the; default system is Cartesian coordinates. Other possible coordinate; systems are `CYL` , `",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:32450,Security,access,access,32450," which is a function of; the cell content. If the cell content is N, the color index used will; be the color number in `colors[N]` . If the maximum cell content is; greater than `ncolors` , all cell contents are scaled to `ncolors`. If; `ncolors<=0`, a default palette of 50 colors is defined. This palette; is recommended for pads, labels. It defines:. - Index 0 to 9: shades of gray; - Index 10 to 19:shades of brown; - Index 20 to 29:shades of blue; - Index 30 to 39: shades of red; - Index 40 to 49:basic colors. The color numbers specified in this palette can be viewed by selecting; the menu entry Colors in the View menu of the canvas menu bar. The; color's red, green, and blue values can be changed via; **`TColor`**`::SetRGB`. If `ncolors == 1 && colors == 0`, then a Pretty Palette with a; spectrum violet to red is created with 50 colors. That's the default; rain bow palette. Other predefined palettes with 255 colors are available when; `colors == 0`. The following value of `ncolors` (with `colors = 0`); give access to:. - `ncolors = 51` : Deep Sea palette.; - `ncolors = 52` : Grey Scale palette.; - `ncolors = 53` : Dark Body Radiator palette.; - `ncolors = 54` : Two-color hue palette palette. (dark blue through; neutral gray to bright yellow); - `ncolors = 55` : Rain Bow palette.; - `ncolors = 56` : Inverted Dark Body Radiator palette. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas toolbar.; The color parameters can be changed via `TColor::SetRGB`. Note that when drawing a 2D histogram `h2` with the option ""`COL`"" or; ""`COLZ`"" or with any ""`CONT`"" options using the color map, the number; of colors used is defined by the number of contours `n` specified; with: `h2->SetContour(n)`. #### TPaletteAxis. A **`TPaletteAxis`**object is used to display; the color palette when drawing 2D histograms. The object is; automatically created when drawing a 2D histogram when the option; ""`z`"" is specified. It",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13165,Testability,log,logarithmic,13165," has associated error bars ( **`TH1`**`::Sumw2()` has; been called), the resulting error bars are also computed assuming; independent histograms. In case of divisions, binomial errors are also; supported. ## Projections. One can make:. - a 1-D projection of a 2-D histogram or profile. See; **`TH2`**`::ProfileX`,; **`TH2`**`::ProfileY, `**`TProfile`**`::ProjectionX`,; **`TProfile2D`**`::ProjectionXY`, **`TH2`**`::ProjectionX`,; **`TH2`**`::ProjectionY` . - a 1-D, 2-D or profile out of a 3-D histogram see; **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:37784,Testability,log,log,37784,"sx,nodesy)`. Example:. ``` {.cpp}; h2->Draw(""SPEC n(40,40)"");; ```. Sometimes the displayed region is rather large. When displaying all; channels the pictures become very dense and complicated. It is very; difficult to understand the overall shape of data. ""`n(nx,ny)`"" allows; to change the density of displayed channels. Only the channels; coinciding with given nodes are displayed. The visualization ""Angles"" can be changed with ""`a(alpha,beta,view)`"":; ""`alpha`"" is the angle between the bottom horizontal screen line and; the displayed space on the right side of the picture and ""`beta`"" on; the left side, respectively. One can rotate the 3-d space around the; vertical axis using the ""`view`"" parameter. Allowed values are 0, 90,; 180 and 270 degrees. ``` {.cpp}; h2->Draw(""SPEC n(40,40) dm(0,1) a(30,30,0)"");; ```. The operator ""`zs(scale)`"" changes the scale of the Z-axis. The; possible values are:. - 0 = Linear (default),; - 1 = Log,; - 2 = Sqrt. If `gPad->SetLogz()` has been set, the log scale on Z-axis is set; automatically, i.e. there is no need for using the `zs()` operator.; Note that the X and Y axis are always linear. The operator ""`ci(r,g,b`)"" defines the colors increments (`r`, `g`; and `b` are floats). For sophisticated shading (Light, Height and; LightHeight Display Modes Groups) the color palette starts from the; basic pen color (see `pa()` function). There is a predefined number of; color levels (256). Color in every level is calculated by adding the; increments of the `r` , `g` , `b` components to the previous level.; Using this function one can change the color increments between two; neighboring color levels. The function does not apply on the Simple; Display Modes Group. The default values are: (1,1,1). The operator ""`ca(color_algorithm)`"" allows to choose the Color; Algorithm. To define the colors one can use one of the following color; algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a; component reaches the limit value one can choose e",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:50370,Testability,test,test,50370,"o histograms with the same; // name; ```. ## Normalizing Histograms. You can scale a histogram ( **`TH1`** `*h` ) such that the bins; integral is equal to the normalization parameter norm:. ``` {.cpp}; Double_t scale = norm/h->Integral();; h->Scale(scale);; ```. ## Saving/Reading Histograms to/from a File. The following statements create a ROOT file and store a histogram on; the file. Because **`TH1`** derives from **`TNamed`** , the key; identifier on the file is the histogram name:. ``` {.cpp}; TFile f(""histos.root"",""new"");; TH1F h1(""hgaus"",""histo from a gaussian"",100,-3,3);; h1.FillRandom(""gaus"",10000);; h1->Write();; ```. To read this histogram in another ROOT session, do:. ``` {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ```. One can save all histograms in memory to the file by:. ``` {.cpp}; file->Write();; ```. For a more detailed explanation, see ""Input/Output"". ## Miscellaneous Operations. - **`TH1`**`::KolmogorovTest(` **`TH1`**`* h2,Option_t *option)` is; statistical test of compatibility in shape between two histograms.; The parameter `option` is a character string that specifies:. - ""`U`"" include Underflows in test (also for 2-dim). - ""`O`"" include Overflows (also valid for 2-dim). - ""`N`"" include comparison of normalizations. - ""`D`"" put out a line of ""Debug"" printout. - ""`M`"" return the maximum Kolmogorov distance instead of `prob`. - ""`X`"" run the pseudo experiments post-processor with the following; procedure: it makes pseudo experiments based on random values from; the parent distribution and compare the KS distance of the pseudo; experiment to the parent distribution. Bin the KS distances in a; histogram, and then take the integral of all the KS values above; the value obtained from the original data to Monte Carlo; distribution. The number of pseudo-experiments NEXPT is currently; fixed at 1000. The function returns the integral. Note that this; option ""`X`"" is much slower. - **`TH1`**`::Smooth` - smoothes the bin contents of",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:50518,Testability,test,test,50518,"e normalization parameter norm:. ``` {.cpp}; Double_t scale = norm/h->Integral();; h->Scale(scale);; ```. ## Saving/Reading Histograms to/from a File. The following statements create a ROOT file and store a histogram on; the file. Because **`TH1`** derives from **`TNamed`** , the key; identifier on the file is the histogram name:. ``` {.cpp}; TFile f(""histos.root"",""new"");; TH1F h1(""hgaus"",""histo from a gaussian"",100,-3,3);; h1.FillRandom(""gaus"",10000);; h1->Write();; ```. To read this histogram in another ROOT session, do:. ``` {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ```. One can save all histograms in memory to the file by:. ``` {.cpp}; file->Write();; ```. For a more detailed explanation, see ""Input/Output"". ## Miscellaneous Operations. - **`TH1`**`::KolmogorovTest(` **`TH1`**`* h2,Option_t *option)` is; statistical test of compatibility in shape between two histograms.; The parameter `option` is a character string that specifies:. - ""`U`"" include Underflows in test (also for 2-dim). - ""`O`"" include Overflows (also valid for 2-dim). - ""`N`"" include comparison of normalizations. - ""`D`"" put out a line of ""Debug"" printout. - ""`M`"" return the maximum Kolmogorov distance instead of `prob`. - ""`X`"" run the pseudo experiments post-processor with the following; procedure: it makes pseudo experiments based on random values from; the parent distribution and compare the KS distance of the pseudo; experiment to the parent distribution. Bin the KS distances in a; histogram, and then take the integral of all the KS values above; the value obtained from the original data to Monte Carlo; distribution. The number of pseudo-experiments NEXPT is currently; fixed at 1000. The function returns the integral. Note that this; option ""`X`"" is much slower. - **`TH1`**`::Smooth` - smoothes the bin contents of a 1D histogram. - **`TH1`**`::Integral(Option_t *opt)-`returns the integral of bin; contents in a given bin range. If the option ""`width`"" is; specified, the",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59709,Testability,test,test,59709,"e`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59763,Testability,test,test,59763,"e`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59883,Testability,test,test,59883,"de via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60004,Testability,test,test,60004,"HStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13927,Usability,clear,clears,13927,"`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:15160,Usability,clear,cleared,15160,"ent pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory. It is the user's; responsibility to delete this histogram. The `kCanDelete` bit is set; for the returned object. If a pad containing this copy is cleared, the; histogram will be automatically deleted. See ""Draw Options"" for the; list of options. ### Setting the Style. Histograms use the current style ***`gStyle`***, which is the global; object of class **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read a",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:34629,Usability,simpl,simple,34629," in z. #### The SPEC Option. The ""SPEC"" option offers a large set of options/attributes to; visualize 2D histograms thanks to ""operators"" following the ""SPEC""; keyword. For example, to draw the 2-D histogram `h2` using all default; attributes except the viewing angles, one can do:. ``` {.cpp}; h2->Draw(""SPEC a(30,30,0)"");; ```. The operators' names are case insensitive (i.e. one can use ""a"" or; ""A"") and their parameters are separated by coma "","". Operators can be; put in any order in the option and must be separated by a space "" "".; No space characters should be put in an operator. All the available; operators are described below. The way how a 2D histogram will be painted is controlled by two; parameters: the ""Display modes groups"" and the ""Display Modes"".; ""Display modes groups"" can take the following values:. - 0 = Simple - simple display modes using one color only; - 1 = Light - the shading is carried out according to the position; of the fictive light source; - 2 = Height - the shading is carried out according to the channel; contents; - 3 = LightHeight - combination of two previous shading algorithms; (one can control the weight between both algorithms). ""Display modes"" can take the following values:. - 1 = Points; - 2 = Grid; - 3 = Contours; - 4 = Bars; - 5 = LinesX; - 6 = LinesY; - 7 = BarsX; - 8 = BarsY; - 9 = Needles; - 10 = Surface; - 11 = Triangles. These parameters can be set by using the ""`dm`"" operator in the; option. ``` {.cpp}; h2->Draw(""SPEC dm(1,2)"");; ```. The above example draws the histogram using the ""Light Display mode; group"" and the ""Grid Display mode"". The following tables summarize all; the possible combinations of both groups:. +-----------+------+----+--------+----+------+------+; | |Points|Grid|Contours|Bars|LinesX|LinesY|; +-----------+------+----+--------+----+------+------+; |Simple | x | x | x |x |x |x |; +-----------+------+----+--------+----+------+------+; |Light | x | x | - |- |x |x |; +-----------+------+----+--------+----+----",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59596,Usability,simpl,simple,59596,"s by calling:. ``` {.cpp}; TH1::LabelsDeflate(axis);; ```. Here `axis` may be X, Y, or Z. This operation is automatic when using; **`TTree`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filli",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60418,Usability,simpl,simple,60418,"pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantiti",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60652,Usability,simpl,simple,60652,"ck.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of ",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:65675,Usability,simpl,simple,65675,". - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ```. ![A profile histogram example](pictures/0300003E.png). ### Drawing a Profile without Error Bars. To draw a profile histogram and not show the error bars use the; ""`HIST`"" option in the **`TProfile`**`::Draw` method. This wil",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71780,Usability,simpl,simple,71780," method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binn",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71865,Usability,simpl,simple,71865,"in one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71947,Usability,simpl,simple,71947," the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the re",MatchSource.DOCS,documentation/users-guide/Histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:416,Deployability,update,update,416,"# Automatic HTML Documentation; \index{documentation!class}. **`THtml`** is ROOT's documentation engine. It can be used to document; your classes in a reference guide, and to convert your text or source; files to HTML. ## Reference Guide. The Reference Guide for the ROOT classes at; <http://root.cern.ch/root/html/> has been generated by ROOT's; **`THtml`** class. Just as for ROOT's classes, it can generate (and; update) a reference guide for your classes, too. You document your; classes using source code comments. All comments will be automatically; put into a `<pre></pre>` environment to keep the indentation and line; length. You can write ""raw"" HTML by enclosing comments in the keywords; `Begin_Html` and `End_Html`. To generate documentation for the class **`TObject`** you could run the; following commands:. ``` {.cpp}; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; ```. The comments following the first comment of the form; //\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_, before any method, is; assumed to be the **class description**. As with any other documentation; part, it has to be a continuous block of comments. Any documented class will have an **class index entry** in the; `ClassIndex.html`, showing their name with a link to their documentation; page and a miniature description. This description for e.g. the class; `MyClass` has to be given in `MyClass's` header file as documentation. A **method description** block starts immediately after '`{`' and looks; like this:. ``` {.cpp}; void TWorld::HelloWorldFunc(string *text); {; // This is a documentation example of the function TWorld::HelloWorldFunc; helloWorld.Print(text);; }; ```. Like in a class description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:1200,Deployability,continuous,continuous,1200," text or source; files to HTML. ## Reference Guide. The Reference Guide for the ROOT classes at; <http://root.cern.ch/root/html/> has been generated by ROOT's; **`THtml`** class. Just as for ROOT's classes, it can generate (and; update) a reference guide for your classes, too. You document your; classes using source code comments. All comments will be automatically; put into a `<pre></pre>` environment to keep the indentation and line; length. You can write ""raw"" HTML by enclosing comments in the keywords; `Begin_Html` and `End_Html`. To generate documentation for the class **`TObject`** you could run the; following commands:. ``` {.cpp}; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; ```. The comments following the first comment of the form; //\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_, before any method, is; assumed to be the **class description**. As with any other documentation; part, it has to be a continuous block of comments. Any documented class will have an **class index entry** in the; `ClassIndex.html`, showing their name with a link to their documentation; page and a miniature description. This description for e.g. the class; `MyClass` has to be given in `MyClass's` header file as documentation. A **method description** block starts immediately after '`{`' and looks; like this:. ``` {.cpp}; void TWorld::HelloWorldFunc(string *text); {; // This is a documentation example of the function TWorld::HelloWorldFunc; helloWorld.Print(text);; }; ```. Like in a class description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header file, e.g. ``` {.cpp}; Int_t fIAmADataMember; // this is a data member; ```. When documenting a class, **`THtml`** creates both a ""beautified""; version of the source file and a web page ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:6248,Deployability,update,updated,6248,"tion Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; ```. THtml will inject the following picture:. ![](pictures/0300022D.png). The image file name is generated from the formula and will be unique for; all the documentation. It is stored along-side the documentation, and it; will be automatically regenerated when the documentation is updated. The; handling of the Latex directive is done by the class; **`TDocLatexDirective`**. The `BEGIN_LATEX` keyword can take the following parameters:. - `fontsize`: sets the **`TLatex`** font size. The default value is 16. - `separator`: sets a list of characters for which a new column will; be started. This allows aligned, multi-line, multi-column layout,; which can be useful for e.g. mathematical derivations. It is unset; by default, meaning the Latex directive will only generate one; column. - `rseparator`: like separator, but a regular expression. Columns; start with a match of this regular expression. Only one of separator; or rseparator can be given. - `align`: defines the alignment of the columns. Note that the column; delimiter counts as a column itself!. Example invocation, where the font size is set to 10, new columns are; started by the characters '`=`' and '`,`', and the two columns are left; aligned with the separato",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:11259,Deployability,install,installation,11259,"b` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successful example of this; is the PHP.net documentation with its user annotations. **`THtml`** can; include a link to a class's Wiki page by setting the Wiki base URL via; `Root.Html.WikiURL` or **`THtml`**`::SetWikiURL()`. ## Tutorial. You can run the tutorial `htmlex.C` to see how **`THtml`** converts a; script to HTML and how it creates the corresponding class reference:. ``` {.cpp}; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; ```. Have a look at the HTML version of the macro in; `htmldoc/htmlex.C.html `(which should be the same as the one at; <http://root.cern.ch/root/html/examples/htmlex.C.html>). It demonstrates how to generate documentation for your classes and for; ROOT classes and how to ""beautify"" a macro.; ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:5981,Integrability,inject,inject,5981,"ot[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; ```. THtml will inject the following picture:. ![](pictures/0300022D.png). The image file name is generated from the formula and will be unique for; all the documentation. It is stored along-side the documentation, and it; will be automatically regenerated when the documentation is updated. The; handling of the Latex directive is done by the class; **`TDocLatexDirective`**. The `BEGIN_LATEX` keyword can take the following parameters:. - `fontsize`: sets the **`TLatex`** font size. The default value is 16. - `separator`: sets a list of characters for which a new column will; be started. This allows aligned, multi-line, multi-column layout,; which can be useful for e.g. mathematical derivations. It is unset; by default, meaning the Latex directive will only generate one; column. - `rseparator`: like separator, but a regular expression. Columns; start with a match of this regular expression. Only one of separator; or rseparator can be given. - `align`: defines the alignment of the columns. Note that the column; d",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:11031,Integrability,interface,interface,11031,"of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successful example of this; is the PHP.net documentation with its user annotations. **`THtml`** can; include a link to a class's Wiki page by setting the Wiki base URL via; `Root.Html.WikiURL` or **`THtml`**`::SetWikiURL()`. ## Tutorial. You can run the tutorial `htmlex.C` to see how **`THtml`** converts a; script to HTML and how it creates the corresponding class reference:. ``` {.cpp}; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; ```. Have a look at the HTML version of the macro in; `htmldoc/htmlex.C.html `(which ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:11190,Modifiability,variab,variable,11190,"name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successful example of this; is the PHP.net documentation with its user annotations. **`THtml`** can; include a link to a class's Wiki page by setting the Wiki base URL via; `Root.Html.WikiURL` or **`THtml`**`::SetWikiURL()`. ## Tutorial. You can run the tutorial `htmlex.C` to see how **`THtml`** converts a; script to HTML and how it creates the corresponding class reference:. ``` {.cpp}; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; ```. Have a look at the HTML version of the macro in; `htmldoc/htmlex.C.html `(which should be the same as the one at; <http://root.cern.ch/root/html/examples/htmlex.C.html>). It demonstrates how to generate documentation for your c",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:5981,Security,inject,inject,5981,"ot[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; ```. THtml will inject the following picture:. ![](pictures/0300022D.png). The image file name is generated from the formula and will be unique for; all the documentation. It is stored along-side the documentation, and it; will be automatically regenerated when the documentation is updated. The; handling of the Latex directive is done by the class; **`TDocLatexDirective`**. The `BEGIN_LATEX` keyword can take the following parameters:. - `fontsize`: sets the **`TLatex`** font size. The default value is 16. - `separator`: sets a list of characters for which a new column will; be started. This allows aligned, multi-line, multi-column layout,; which can be useful for e.g. mathematical derivations. It is unset; by default, meaning the Latex directive will only generate one; column. - `rseparator`: like separator, but a regular expression. Columns; start with a match of this regular expression. Only one of separator; or rseparator can be given. - `align`: defines the alignment of the columns. Note that the column; d",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:4540,Testability,test,test,4540,"if any of these files exist. The index page will also; contain a list of links to all files in the directory that end on; `.html` or `.txt`. Files ending on `.txt` will be converted to HTML; before they are copied to the output directory. For each file, the; link's text will be the file name without extension, with underscores; replaced by spaces. You can see an example of the module documentation including links, the; corresponding `index.html`, and the module class index at; <http://root.cern.ch/root/html/HIST_Index.html>. ## Converting Sources (and Other Files) to HTML. **`THtml`** can take a file (C++ or text) and convert it to HTML. There; are two main use cases:. The output of a **macro** converted to HTML will almost look like the; beautified source file of a class reference. The `Begin_Html/End_Html`; keywords are supported; comments, strings, and keywords are colored like; in **`THtml`**'s output for source code. The macro `Event.cxx` in `$ROOTSYS/test` can be seen as an example of; documented ROOT macros at; <http://root.cern.ch/root/html/examples/Event.cxx.html>. `THtml::Convert()`converts a single text file to HTML. For example, it; can be run on a change log. Each known class name will be linked to its; documentation page. An example is ROOT's change log at; <http://root.cern.ch/root/html/examples/V5.16.txt.html>. To convert the source file MyCode.C to HTML, you can run. ``` {.cpp}; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keyw",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:4755,Testability,log,log,4755,"l be converted to HTML; before they are copied to the output directory. For each file, the; link's text will be the file name without extension, with underscores; replaced by spaces. You can see an example of the module documentation including links, the; corresponding `index.html`, and the module class index at; <http://root.cern.ch/root/html/HIST_Index.html>. ## Converting Sources (and Other Files) to HTML. **`THtml`** can take a file (C++ or text) and convert it to HTML. There; are two main use cases:. The output of a **macro** converted to HTML will almost look like the; beautified source file of a class reference. The `Begin_Html/End_Html`; keywords are supported; comments, strings, and keywords are colored like; in **`THtml`**'s output for source code. The macro `Event.cxx` in `$ROOTSYS/test` can be seen as an example of; documented ROOT macros at; <http://root.cern.ch/root/html/examples/Event.cxx.html>. `THtml::Convert()`converts a single text file to HTML. For example, it; can be run on a change log. Each known class name will be linked to its; documentation page. An example is ROOT's change log at; <http://root.cern.ch/root/html/examples/V5.16.txt.html>. To convert the source file MyCode.C to HTML, you can run. ``` {.cpp}; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The out",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:4853,Testability,log,log,4853,"he file name without extension, with underscores; replaced by spaces. You can see an example of the module documentation including links, the; corresponding `index.html`, and the module class index at; <http://root.cern.ch/root/html/HIST_Index.html>. ## Converting Sources (and Other Files) to HTML. **`THtml`** can take a file (C++ or text) and convert it to HTML. There; are two main use cases:. The output of a **macro** converted to HTML will almost look like the; beautified source file of a class reference. The `Begin_Html/End_Html`; keywords are supported; comments, strings, and keywords are colored like; in **`THtml`**'s output for source code. The macro `Event.cxx` in `$ROOTSYS/test` can be seen as an example of; documented ROOT macros at; <http://root.cern.ch/root/html/examples/Event.cxx.html>. `THtml::Convert()`converts a single text file to HTML. For example, it; can be run on a change log. Each known class name will be linked to its; documentation page. An example is ROOT's change log at; <http://root.cern.ch/root/html/examples/V5.16.txt.html>. To convert the source file MyCode.C to HTML, you can run. ``` {.cpp}; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // Th",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:161,Usability,guid,guide,161,"# Automatic HTML Documentation; \index{documentation!class}. **`THtml`** is ROOT's documentation engine. It can be used to document; your classes in a reference guide, and to convert your text or source; files to HTML. ## Reference Guide. The Reference Guide for the ROOT classes at; <http://root.cern.ch/root/html/> has been generated by ROOT's; **`THtml`** class. Just as for ROOT's classes, it can generate (and; update) a reference guide for your classes, too. You document your; classes using source code comments. All comments will be automatically; put into a `<pre></pre>` environment to keep the indentation and line; length. You can write ""raw"" HTML by enclosing comments in the keywords; `Begin_Html` and `End_Html`. To generate documentation for the class **`TObject`** you could run the; following commands:. ``` {.cpp}; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; ```. The comments following the first comment of the form; //\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_, before any method, is; assumed to be the **class description**. As with any other documentation; part, it has to be a continuous block of comments. Any documented class will have an **class index entry** in the; `ClassIndex.html`, showing their name with a link to their documentation; page and a miniature description. This description for e.g. the class; `MyClass` has to be given in `MyClass's` header file as documentation. A **method description** block starts immediately after '`{`' and looks; like this:. ``` {.cpp}; void TWorld::HelloWorldFunc(string *text); {; // This is a documentation example of the function TWorld::HelloWorldFunc; helloWorld.Print(text);; }; ```. Like in a class description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:436,Usability,guid,guide,436,"# Automatic HTML Documentation; \index{documentation!class}. **`THtml`** is ROOT's documentation engine. It can be used to document; your classes in a reference guide, and to convert your text or source; files to HTML. ## Reference Guide. The Reference Guide for the ROOT classes at; <http://root.cern.ch/root/html/> has been generated by ROOT's; **`THtml`** class. Just as for ROOT's classes, it can generate (and; update) a reference guide for your classes, too. You document your; classes using source code comments. All comments will be automatically; put into a `<pre></pre>` environment to keep the indentation and line; length. You can write ""raw"" HTML by enclosing comments in the keywords; `Begin_Html` and `End_Html`. To generate documentation for the class **`TObject`** you could run the; following commands:. ``` {.cpp}; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; ```. The comments following the first comment of the form; //\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_, before any method, is; assumed to be the **class description**. As with any other documentation; part, it has to be a continuous block of comments. Any documented class will have an **class index entry** in the; `ClassIndex.html`, showing their name with a link to their documentation; page and a miniature description. This description for e.g. the class; `MyClass` has to be given in `MyClass's` header file as documentation. A **method description** block starts immediately after '`{`' and looks; like this:. ``` {.cpp}; void TWorld::HelloWorldFunc(string *text); {; // This is a documentation example of the function TWorld::HelloWorldFunc; helloWorld.Print(text);; }; ```. Like in a class description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header ",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:2758,Usability,learn,learn,2758,"s description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header file, e.g. ``` {.cpp}; Int_t fIAmADataMember; // this is a data member; ```. When documenting a class, **`THtml`** creates both a ""beautified""; version of the source file and a web page containing the class; documentation. The documentation also shows the **author** and a; **copyright statement**. This information is extracted from the source; file. The author can be in the format. ``` {.cpp}; // Author: Enrico Fermi; ```. for people that have an entry in CERN's XWho database, and for those who; have not:. ``` {.cpp}; // Author: Enrico Fermi <mailto:enrico@fnal.gov>; ```. The copyright statement is introduced by the string ""`* Copyright`""; inside a comment. You should read the class reference page at; <http://root.cern.ch/root/html/THtml.html> to learn about all of; **`THtml`**'s features. ### Product and Module Documentation. For **`THtml`**, a product like ROOT is a combination of several; modules. It can include user-provided document for both products and; modules. The name of the product can be set by calling; `THtml::SetProductName()`. By default, the documentation is searched for; in the `doc/` subdirectory of the source tree, and in the; `../doc `directory, relative to the directory of first source file of a; module. This can be set by calls to `THtml::SetProductDocDir()` and; `THtml::SetModuleDocPath()`. The documentation is generated as an index page with links to further; files. This index page includes the file `index.txt` converted to HTML; (via `THtml::Convert()`) or the file index.html (without conversion to; HTML, of course), if any of these files exist. The index page will also; contain a list of links to all files in the directory that end on; `.html` or `.txt`. Files ending on `.txt` will be converted to HTML; before they are",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:10538,Usability,guid,guide,10538,"rence page <http://root.cern.ch/root/html/THtml>. The; following will enumerate some of the highlights. ### Referencing Documentation for other Libraries. When **`THtml`** generates documentation for classes it recognizes all; class names known to ROOT. If **`THtml`** does not have sources for a; class it determines the class's library name. This has to be set by; means of `rootmap` files, see Library AutoLoading of this User's Guide.; Given the library name, **`THtml`** searches for an entry in its map of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successf",MatchSource.DOCS,documentation/users-guide/HTMLDoc.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:228,Availability,recover,recovery,228,"# Input/Output; \index{I/O}. This chapter covers the saving and reading of objects to and from ROOT; files. It begins with an explanation of the physical layout of a ROOT; file. It includes a discussion on compression, and file recovery. Then; we explain the logical file, the class **`TFile`** and its methods. We; show how to navigate in a file, how to save objects and read them back.; We also include a discussion on `Streamers`. `Streamers` are the methods; responsible to capture an objects current state to save it to disk or; send it over the network. At the end of the chapter is a discussion on; the two specialized ROOT files: **`TNetFile`** and **`TWebFile`**. ## The Physical Layout of ROOT Files. A ROOT file is like a UNIX file directory. It can contain directories; and objects organized in unlimited number of levels. It also is stored; in machine independent format (ASCII, IEEE floating point, Big Endian; byte ordering). To look at the physical layout of a ROOT file, we first; create one. This example creates a ROOT file and 15 histograms, fills; each histogram with 1000 entries from a Gaussian distribution, and; writes them to the file. ``` {.cpp}; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of Histograms; TH1F* h; // create a pointer to a histogram; // make and fill 15 histograms and add them to the object array; for (Int_t i = 0; i < 15; i++) {; sprintf(name,""h%d"",i);; sprintf(title,""histo nr:%d"",i);; h = new TH1F(name,title,100,-4,4);; Hlist.Add(h);; h->FillRandom(""gaus"",1000);; }; // open a file and write the array to the file; TFile f(""demo.root"",""recreate"");; Hlist.Write();; f.Close();; }; ```. The example begins with a call to the **`TFile`** constructor. This; class is describing the ROOT file (that has the extension ""`.root`""). In; the next section, we will cover **`TFile`** in details. The last line of; the example closes the file. To view its contents we need to open it; again, and to create a **`TBrowser`** object by:. ``` ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:6737,Availability,avail,available,6737,"-----------------------------+; | 38 `->` 41 | `fSeekInfo` | Pointer to **`TStreamerInfo`** record |; | [46-\>53] | | |; +-------------------+------------------+---------------------------------------+; | 42 `->` 45 | `fNBytesInfo` | Number of bytes in |; | [54-\>57] | | **`TStreamerInfo`** record |; +-------------------+------------------+---------------------------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record. If the key; is located past the 32 bit file limit (\> 2 GB) then some fields will be; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:7380,Availability,avail,available,7380,"e of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record. If the key; is located past the 32 bit file limit (\> 2 GB) then some fields will be; 8 bytes instead of 4 bytes (values between the brackets):. +--------------------+-------------------+--------------------------------------+; | Byte | Value Name | Description |; +--------------------+-------------------+--------------------------------------+; | 1 `->` 4 | `Nbytes` | Length of compressed object (in |; | | | bytes) |; +--------------------+-------------------+--------------------------------------+; | 5 `->` 6 | `Version` | **`TKey`** version identifier |; +--------------------+-------------------+--------------------------------------+; | 7 `->` 10 | `ObjLen` | Length of uncompressed object |; +--------------------+----------",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:14998,Availability,recover,recover,14998,"e output of `TFile::Map()` are the list of; keys, the list of free segments, and the address where the data ends..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When w",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15097,Availability,recover,recovery,15097,"ds..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery at",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15126,Availability,redundant,redundant,15126,"ds..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery at",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15325,Availability,recover,recovery,15325," KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file se",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15531,Availability,recover,recovery,15531,"tes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15718,Availability,recover,recovery,15718,"rrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class;",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15788,Availability,recover,recover,15788,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15851,Availability,recover,recovered,15851,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16104,Availability,recover,recovery,16104,"ides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16236,Availability,recover,recover,16236,", it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16257,Availability,recover,recovered,16257,", it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:18079,Availability,avail,available,18079,", Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TKey Name = h6, Title = histo nr:6, Cycle = 1; TKey Name = h7, Title = histo nr:7, Cycle = 1; TKey Name = h8, Title = histo nr:8, Cycle = 1; TKey Name = h9, Title = histo nr:9, Cycle = 1; TKey Name = h10, Title = histo nr:10, Cycle = 1; TKey Name = h11, Title = histo nr:11, Cycle = 1; TKey Name = h12, Title = histo nr:12, Cycle = 1; TKey Name = h13, Title = histo nr:13, Cycle = 1; TKey Name = h14, Title = histo nr:14, Cycle = 1; root[] TH1F *h9 = (TH1F*)f.Get(""h9"");; ```. The `TFile::Get()` finds the **`TKey`** object with name ""`h9`"". Using; the **`TKey`** info it will import in memory the object in the file at; the file address \#3352 (see the output from the `TFile::Map` above).; This is done by the `Streamer` method that is covered in detail in a; later section. Since the keys are available in a **`TList`** of; **`TKeys` we can iterate over the list of keys:**. ``` {.cpp}; {; TFile f(""demo.root"");; TIter next(f.GetListOfKeys());; TKey *key;; while ((key=(TKey*)next())) {; printf(""key: %s points to an object of class: %s at %dn"",; key->GetName(),; key->GetClassName(),key->GetSeekKey());; }; }; ```. The output of this script is:. ``` {.cpp}; root[] .x iterate.C; key: h0 points to an object of class: TH1F at 150; key: h1 points to an object of class: TH1F at 503; key: h2 points to an object of class: TH1F at 854; key: h3 points to an object of class: TH1F at 1194; key: h4 points to an object of class: TH1F at 1539; key: h5 points to an object of class: TH1F at 1882; key: h6 points to an object of class: TH1F at 2240; key: h7 points to an object of class: TH1F at 2582; key: h8 points to an object of class: TH1F at 2937; key: h9 points to an object of class: TH1F at 3293; key: h10 points to an object of class: TH1F at 3639; key: h11 points to an object of class: TH1F at 3986; key: h12 points to an",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:36150,Availability,avail,available,36150," out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a **`TFile`** object is deleted an implicit call to; `TFile::Close` is made. This will save only the file descriptor to disk.; It contains the file header, the `StreamerInfo `list, the key list, the; free segment list, and the end address. See ""The Physical Layout of ROOT; Files"". The `TFile::Close` does not make a call to `Write()`, which; means that the objects in memory will not be saved in the file. You need; to explicitly call `TFile::Write()` to save the object in memory to file; before the exit of the function. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a **`TFile`** object `f`, that is available on a global; scope, and it will still be available when exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets y",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:36201,Availability,avail,available,36201," out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a **`TFile`** object is deleted an implicit call to; `TFile::Close` is made. This will save only the file descriptor to disk.; It contains the file header, the `StreamerInfo `list, the key list, the; free segment list, and the end address. See ""The Physical Layout of ROOT; Files"". The `TFile::Close` does not make a call to `Write()`, which; means that the objects in memory will not be saved in the file. You need; to explicitly call `TFile::Write()` to save the object in memory to file; before the exit of the function. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a **`TFile`** object `f`, that is available on a global; scope, and it will still be available when exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets y",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:57315,Availability,error,error,57315," object; identifier is unique for one I/O operation. If there is another pointer; to the object in the same I/O operation, the first object is referenced; i.e. it is not saved again. When reading the file, the object is rebuilt; and the references recalculated. ![Streaming object pointers](pictures/020000EC.jpg). In this way, the network of pointers and their objects is rebuilt and; ready to use the same way it was used before it was persistent. If the; pointer hold the address of an object which in embedded in another; object (as opposed to being pointed to by a pointer), the object will be; duplicate at read time. To avoid this, make the pointer a transient data; member. ### Motivation for the TRef Class. If the object is split into several files or into several branches of; one or more `TTrees`, standard C++ pointers cannot be used because each; I/O operation will write the referenced objects, and multiple copies; will exist. In addition, if the pointer is read before the referenced; object, it is null and may cause a run time system error. To address; these limitations, ROOT offers the **`TRef`** class. **`TRef`** allows referencing an object in a different branch and/or in; a different file. **`TRef`** also supports the complex situation where a; **`TFile`** is updated multiple times on the same machine or a different; machine. When a **`TRef`** is read before its referenced object, it is; null. As soon as the referenced object is read, the **`TRef`** points to; it. In addition, one can specify an action to be taken by **`TRef`** in; the case it is read before its reference object (see""Action on Demand""; below). ### Using TRef. A **`TRef`** is a lightweight object pointing to any **`TObject`**. This; object can be used instead of normal C++ pointers in case:. - The referenced object R and the pointer P are not written to the; same file. - P is read before R. - R and P are written to different Tree branches. Below is a line from the example in `$ROOTSYS/test/Even",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:84658,Availability,avail,available,84658,"`:. ``` {.cpp}; if (R__v > 1) R__b >> fNew;; else fNew = 0; // set to some default value; ```. If, in the same new version 2 you remove the member `fH`, you must add; the following code to read the histogram object into some temporary; object and delete it:. ``` {.cpp}; if (R__v) < 2 {; TH1F *dummy = 0;; R__b >> dummy;; delete dummy;; }; ```. Our experience with manual schema evolution shows that it is easy to; make and mismatches between `Streamer` writers and readers are frequent; and increase as the number of classes increase. We recommend you use; `rootcling` generated `Streamers` whenever you can, and profit from the; automatic schema evolution. ### Building Class Definitions with the StreamerInfo. A ROOT file's `StreamerInfo `list contains the description of all; versions of all classes in the file. When a file is opened the; `StreamerInfo `is read into memory and it provides enough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `Strea",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:85052,Availability,down,down,85052,"between `Streamer` writers and readers are frequent; and increase as the number of classes increase. We recommend you use; `rootcling` generated `Streamers` whenever you can, and profit from the; automatic schema evolution. ### Building Class Definitions with the StreamerInfo. A ROOT file's `StreamerInfo `list contains the description of all; versions of all classes in the file. When a file is opened the; `StreamerInfo `is read into memory and it provides enough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy u",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:85500,Availability,avail,available,85500,"ough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:85573,Availability,avail,available,85573,"ough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95438,Availability,failure,failure,95438,"ile`**). This; functionality is provided by the static `TFile::Open()` function:. ``` {.cpp}; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:20670,Deployability,update,update,20670,"ect is used.; `TFile::fListHead` contains a sorted list (**`TSortedList`**) of objects; in memory. The diagram below illustrates the logical view of the; **`TFile`** and **`TKey`**. ![ROOT File/Directory/Key description](pictures/030000E7.png). ### Viewing the Logical File Contents. **`TFile`** is a descendent of **`TDirectory`**, which means it behaves; like a **`TDirectory`**. We can list the contents, print the name, and; create subdirectories. In a ROOT session, you are always in a directory; and the directory you are in is called the current directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number al",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:52517,Deployability,release,released,52517,"t over the network. This; is beyond the scope of this chapter, but it is worthwhile to emphasize; the need and advantage of separating the creation of the buffer from its; use. Let us look how a buffer is written to a file. The dictionary for a; class needs to be loaded before any object of that type can be saved. The `TObject::Write` method does the following:. - Creates a **`TKey`** object in the current directory. - Creates a **`TBuffer`** object which is part of the newly created; **`TKey`**. - Fills the **`TBuffer`** with a call to the `class::Streamer` method. - Creates a second buffer for compression, if needed. - Reserves space by scanning the **`TFree`** list. At this point, the; size of the buffer is known. - Writes the buffer to the file. - Releases the **`TBuffer`** part of the key. In other words, the `TObject::Write` calls the `Streamer` method of the; class to build the buffer. The buffer is in the key and the key is; written to disk. Once written to disk the memory consumed by the buffer; part is released. The key part of the **`TKey`** is kept. ![A diagram of a streamed TH1F in the buffer](pictures/020000EB.jpg). The key consumes about 60 bytes, whereas the buffer, since it contains; the object data, can be very large. ### Ignore Object Streamers. Your class can ignore the **`TObject`** `Streamer `with the; `MyClass->Class::IgnoreObjectStreamer()` method. When the class; `kIgnoreTObjectStreamer `bit is set (by calling the; `IgnoreTObjectStreamer `method`)`, the automatically generated; `Streamer `will not call `TObject::Streamer`, and the **`TObject`** part; of the class is not streamed to the file. This is useful in case you do; not use the **`TObject`** `fBits` and `fUniqueID `data members. You gain; space on the file, and you do not loose functionality if you do not use; the `fBits` and `fUniqueID. `See ""The Role of TObject"" on the use of; `fBits` and `fUniqueID`. ### Streaming a TClonesArray. When writing a **`TClonesArray`** it bypasses by defa",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:57549,Deployability,update,updated,57549,"nters](pictures/020000EC.jpg). In this way, the network of pointers and their objects is rebuilt and; ready to use the same way it was used before it was persistent. If the; pointer hold the address of an object which in embedded in another; object (as opposed to being pointed to by a pointer), the object will be; duplicate at read time. To avoid this, make the pointer a transient data; member. ### Motivation for the TRef Class. If the object is split into several files or into several branches of; one or more `TTrees`, standard C++ pointers cannot be used because each; I/O operation will write the referenced objects, and multiple copies; will exist. In addition, if the pointer is read before the referenced; object, it is null and may cause a run time system error. To address; these limitations, ROOT offers the **`TRef`** class. **`TRef`** allows referencing an object in a different branch and/or in; a different file. **`TRef`** also supports the complex situation where a; **`TFile`** is updated multiple times on the same machine or a different; machine. When a **`TRef`** is read before its referenced object, it is; null. As soon as the referenced object is read, the **`TRef`** points to; it. In addition, one can specify an action to be taken by **`TRef`** in; the case it is read before its reference object (see""Action on Demand""; below). ### Using TRef. A **`TRef`** is a lightweight object pointing to any **`TObject`**. This; object can be used instead of normal C++ pointers in case:. - The referenced object R and the pointer P are not written to the; same file. - P is read before R. - R and P are written to different Tree branches. Below is a line from the example in `$ROOTSYS/test/Event.cxx.`. ``` {.cpp}; TRef fLastTrack; //pointer to last track; ...; Track *track = (Track*)fTracks->ConstructedAt(fNtrack++);; track->Set(random);; // Save reference to last Track in the collection of Tracks; fLastTrack = track;; ```. The `track` and its reference `fLastTrack` can be",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:68471,Deployability,update,updated,68471,"written separately. ## Schema Evolution. Schema evolution is a problem faced by long-lived data. When a schema; changes, existing persistent data can become inaccessible unless the; system provides a mechanism to access data created with previous; versions of the schema. In the lifetime of collaboration, the class; definitions (i.e. the schema) are likely to change frequently. Not only; can the class itself change, but any of its parent classes or data; member classes can change also. This makes the support for schema; evolution necessary. ROOT fully supports schema evolution. The next figure below illustrates; some of the scenarios. ![The ROOT schema evolution](pictures/020000ED.jpg). The top half represents different versions of the shared library with; the class definitions. These are the in-memory class versions. The; bottom half represents data files that contain different versions of the; classes. - An old version of a shared library and a file with new class; definitions - this can be the case when someone has not updated the; library and is reading a new file. - Reading a file with a shared library that is missing a class; definition (i.e. missing class D). - Reading a file without any class definitions. This can be the case; where the class definition is lost, or unavailable. - The current version of a shared library and an old file with old; class versions (backward compatibility). This is often the case when; reading old data. - Reading a file with a shared library built with `MakeProject`. This; is the case when someone has already read the data without a shared; library and has used ROOT `MakeProject` feature to reconstruct the; class definitions and shared library (`MakeProject` is explained in; detail later on). In case of a mismatch between the in-memory version and the persistent; version of a class, ROOT maps the persistent one to the one in memory.; This allows you to change the class definition at will, for example:. - Change the order of data me",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:88376,Deployability,update,update,88376,"3D type= 0, offset= 0, len=1, method=142684688; i= 2, m_KFcode type= 23, offset= 16, len=5, method=0; i= 3, m_Eta type= 25, offset= 36, len=3, method=0; i= 4, m_Trigger type= 3, offset= 48, len=1, method=0; ```. `MakeProject` has three parameters:. ``` {.cpp}; MakeProject(const char *dirname,const char *classes,Option_t *option); ```. The first is the directory name in which to place the generated header; files. The second parameter is the name of the classes to include in the; project. By default, all classes are included. It recognizes the wild; card character \*, for example, ""ATLF\*"" includes all classes beginning; with ATLF. The third parameter is an option with the following values:. - ""`new`"" If the directory does not exist, it is created. - ""`recreate`"" If the directory does not exist, it is creates as in; ""new"", in addition if the directory does exist, all existing files; are deleted before creating the new files. - ""`update`"" The new classes are added to the existing directory and; the existing classes are replaced with the new definition. If the; directory does not exist, it creates it as in ""new"". - ""+"": This option can be used in combination with the other three. It; will create the necessary files to easily build a shared library; containing the class definitions.Specifically it will:. - Generate a script called `MAKE` that builds the shared library; containing the definition of all classes in the directory. - Generate a `LinkDef.h `files to use with `rootcling` in `MAKE`. - Run `rootcling` to generate a `<dirname>ProjectDict.cxx` file. - Compile the \<`dirname>ProjectDict.cxx `with the current options in; `compiledata.h`. - Build a shared library` <dirname>.so`. - ""++"":This option can be used instead of the single ""+"". It does; everything the single ""+"" does, and dynamically loads the shared; library `<dirname>.so`. This example makes a directory called `MyProject` that will contain all; class definitions from the `atlfast.root` file. The necessary `ma",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:96512,Deployability,update,update,96512,"OT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a sim",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:53545,Energy Efficiency,efficient,efficient,53545,"ased. The key part of the **`TKey`** is kept. ![A diagram of a streamed TH1F in the buffer](pictures/020000EB.jpg). The key consumes about 60 bytes, whereas the buffer, since it contains; the object data, can be very large. ### Ignore Object Streamers. Your class can ignore the **`TObject`** `Streamer `with the; `MyClass->Class::IgnoreObjectStreamer()` method. When the class; `kIgnoreTObjectStreamer `bit is set (by calling the; `IgnoreTObjectStreamer `method`)`, the automatically generated; `Streamer `will not call `TObject::Streamer`, and the **`TObject`** part; of the class is not streamed to the file. This is useful in case you do; not use the **`TObject`** `fBits` and `fUniqueID `data members. You gain; space on the file, and you do not loose functionality if you do not use; the `fBits` and `fUniqueID. `See ""The Role of TObject"" on the use of; `fBits` and `fUniqueID`. ### Streaming a TClonesArray. When writing a **`TClonesArray`** it bypasses by default the; `Streamer `of the member class and uses a more efficient internal; mechanism to write the members to the file. You can override the default; and specify that the member class `Streamer `is used by setting the; `TClonesArray::BypassStreamer` bit to false:. ``` {.cpp}; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; ```. When the `kBypassStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this ca",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:66806,Energy Efficiency,efficient,efficient,66806,"ng `fWebHistogram.GetObject()`, the function `GetObject` will; automatically invoke the script `GetWebHistogram.C` via the interpreter.; An example of a `GetWebHistogram.C` script is shown below:. ``` {.cpp}; void GetWebHistogram() {; TFile *f=TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetObject(h6);; }; ```. In the above example, a call to `fWebHistogram.GetObject()` executes the; script with the function `GetWebHistogram`. This script connects a file; with histograms: `pippa.root` on the ROOT Web site and returns the; object `h6` to **`TRef`**`::GetObject`. ``` {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram(); ```. Note that if the definition of the `TRef fWebHistogram` had been changed; the compiled or interpreted function `GetWebHistogram()` would have been; called instead of the Cling script `GetWebHistogram.C.`. ### Array of TRef. When storing multiple **`TRef`**s, it is more efficient to use a; **`TRefArray`**. The efficiency is due to having a single pointer `fPID`; for all `TRefs` in the array. It has a dynamic compact table of; `fUniqueIDs`. We recommend that you use a **`TRefArray`** rather then a; collection of `TRefs`. Example:. - Suppose a `TObjArray *mytracks` containing a list of `Track`; objects. - Suppose a `TRefArray *pions` containing pointers to the pion tracks; in `mytracks`. This list is created with statements like:; `pions->Add(track);`. - Suppose a `TRefArray *muons` containing pointers to the muon tracks; in `mytracks`. The 3 arrays `mytracks`,` pions` and `muons` may be written separately. ## Schema Evolution. Schema evolution is a problem faced by long-lived data. When a schema; changes, existing persistent data can become inaccessible unless the; system provides a mechanism to access data created with previous; versions of the schema. In the lifetime of collaboration, the class; definitions (i.e. the schema) are likely to change",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:86037,Energy Efficiency,energy,energy,86037,"eriment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake class from the `StreamerInfo`. ``` {.cpp}; // Build a 'fake' class; root[] gROOT->GetClass(""ATLFMuon""); (const class TClass*)0x87e5c08; // The fake class has a StreamerInfo; root[] gROOT->GetClass(""ATLFMuon"")->GetStreamerInfo()->ls(); StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 16 type= 3 Muon KF-code; Int_t m_MCParticle offset= 20 type= 3 Muon position in MCParticles list; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:86262,Energy Efficiency,energy,energy,86262,"eriment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake class from the `StreamerInfo`. ``` {.cpp}; // Build a 'fake' class; root[] gROOT->GetClass(""ATLFMuon""); (const class TClass*)0x87e5c08; // The fake class has a StreamerInfo; root[] gROOT->GetClass(""ATLFMuon"")->GetStreamerInfo()->ls(); StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 16 type= 3 Muon KF-code; Int_t m_MCParticle offset= 20 type= 3 Muon position in MCParticles list; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:87099,Energy Efficiency,energy,energy,87099,"n isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake class from the `StreamerInfo`. ``` {.cpp}; // Build a 'fake' class; root[] gROOT->GetClass(""ATLFMuon""); (const class TClass*)0x87e5c08; // The fake class has a StreamerInfo; root[] gROOT->GetClass(""ATLFMuon"")->GetStreamerInfo()->ls(); StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 16 type= 3 Muon KF-code; Int_t m_MCParticle offset= 20 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 24 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 28 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 32 type= 3 Muon isolation; Float_t m_Eta offset= 36 type= 5 Eta coordinate; Float_t m_Phi offset= 40 type= 5 Phi coordinate; Float_t m_PT offset= 44 type= 5 Transverse energy; Int_t m_Trigger offset= 48 type= 3 Result of trigger; i= 0, TObject type= 66, offset= 0, len=1, method=0; i= 1, TAtt3D type= 0, offset= 0, len=1, method=142684688; i= 2, m_KFcode type= 23, offset= 16, len=5, method=0; i= 3, m_Eta type= 25, offset= 36, len=3, method=0; i= 4, m_Trigger type= 3, offset= 48, len=1, method=0; ```. `MakeProject` has three parameters:. ``` {.cpp}; MakeProject(const char *dirname,const char *classes,Option_t *option); ```. The first is the directory name in which to place the generated header; files. The second parameter is the name of the classes to include in the; project. By default, all classes are included. It recognizes the wild; card character \*, for example, ""ATLF\*"" includes all classes beginning; with ATLF. The third parameter is",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:87311,Energy Efficiency,energy,energy,87311,"n isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to use a specific class we get a warning because; the class is not in the dictionary. We can create a class using; `gROOT->GetClass()` which makes a fake class from the `StreamerInfo`. ``` {.cpp}; // Build a 'fake' class; root[] gROOT->GetClass(""ATLFMuon""); (const class TClass*)0x87e5c08; // The fake class has a StreamerInfo; root[] gROOT->GetClass(""ATLFMuon"")->GetStreamerInfo()->ls(); StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 16 type= 3 Muon KF-code; Int_t m_MCParticle offset= 20 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 24 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 28 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 32 type= 3 Muon isolation; Float_t m_Eta offset= 36 type= 5 Eta coordinate; Float_t m_Phi offset= 40 type= 5 Phi coordinate; Float_t m_PT offset= 44 type= 5 Transverse energy; Int_t m_Trigger offset= 48 type= 3 Result of trigger; i= 0, TObject type= 66, offset= 0, len=1, method=0; i= 1, TAtt3D type= 0, offset= 0, len=1, method=142684688; i= 2, m_KFcode type= 23, offset= 16, len=5, method=0; i= 3, m_Eta type= 25, offset= 36, len=3, method=0; i= 4, m_Trigger type= 3, offset= 48, len=1, method=0; ```. `MakeProject` has three parameters:. ``` {.cpp}; MakeProject(const char *dirname,const char *classes,Option_t *option); ```. The first is the directory name in which to place the generated header; files. The second parameter is the name of the classes to include in the; project. By default, all classes are included. It recognizes the wild; card character \*, for example, ""ATLF\*"" includes all classes beginning; with ATLF. The third parameter is",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:91125,Energy Efficiency,energy,energy,91125,"FTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; ```. Now you can load the shared library in any consecutive root session to; use the `atlfast` classes. ``` {.cpp}; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; ```. This is an example of a generated header file:. ``` {.cpp}; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; ```. ## Compression and Performance. ROOT uses a compression algorithm based on the well-known `gzip`; algorithm. It supports nine levels of compression. The default for ROOT; is one. The compression level can be set with the method; `TFile::SetCompressionLevel`. The experience with this algorithm shows; that a compression level of 1.3 for raw data files and around two on; most DST files is the optimum. The choice of one for the default is a; compromise between the time it takes to read and write the object vs.; the disk space savings. To specify no compression, set the level to zero. We recommend using compression when the time spent in I/O is small; compared to the total processing time. If the I/O operation is increased; by a ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:91290,Energy Efficiency,energy,energy,91290,"FTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; ```. Now you can load the shared library in any consecutive root session to; use the `atlfast` classes. ``` {.cpp}; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; ```. This is an example of a generated header file:. ``` {.cpp}; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; ```. ## Compression and Performance. ROOT uses a compression algorithm based on the well-known `gzip`; algorithm. It supports nine levels of compression. The default for ROOT; is one. The compression level can be set with the method; `TFile::SetCompressionLevel`. The experience with this algorithm shows; that a compression level of 1.3 for raw data files and around two on; most DST files is the optimum. The choice of one for the default is a; compromise between the time it takes to read and write the object vs.; the disk space savings. To specify no compression, set the level to zero. We recommend using compression when the time spent in I/O is small; compared to the total processing time. If the I/O operation is increased; by a ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:92660,Energy Efficiency,charge,charge,92660,"set with the method; `TFile::SetCompressionLevel`. The experience with this algorithm shows; that a compression level of 1.3 for raw data files and around two on; most DST files is the optimum. The choice of one for the default is a; compromise between the time it takes to read and write the object vs.; the disk space savings. To specify no compression, set the level to zero. We recommend using compression when the time spent in I/O is small; compared to the total processing time. If the I/O operation is increased; by a factor of 5 it is still a small percentage of the total time and it; may compress the data by a factor of 10. On the other hand if the time; spend on I/O is large, compression may have a large impact on the; program's performance. The compression factor, i.e. the savings of disk space, varies with the; type of data. A buffer with a same value array is compressed so that the; value is only written once. For example, a track has the mass of a pion; that it is always the same, and the charge of the pion that is either; positive or negative. For 1000 pions, the mass will be written only; once, and the charge only twice (positive and negative). When the data; is sparse, i.e. when there are many zeros, the compression factor is; also high. +---------------------+------------------+-------------------+-------------------+; | Compression level | Bytes | Write Time (sec) | Read Time (sec.) |; +---------------------+------------------+-------------------+-------------------+; | 0 | 1,004,998 | 4.77 | 0.07 |; +---------------------+------------------+-------------------+-------------------+; | 1 | 438,366 | 6.67 | 0.05 |; +---------------------+------------------+-------------------+-------------------+; | 5 | 429,871 | 7.03 | 0.06 |; +---------------------+------------------+-------------------+-------------------+; | 9 | 426,899 | 8.47 | 0.05 |; +---------------------+------------------+-------------------+-------------------+. The time to uncompress an objec",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:92778,Energy Efficiency,charge,charge,92778,"1.3 for raw data files and around two on; most DST files is the optimum. The choice of one for the default is a; compromise between the time it takes to read and write the object vs.; the disk space savings. To specify no compression, set the level to zero. We recommend using compression when the time spent in I/O is small; compared to the total processing time. If the I/O operation is increased; by a factor of 5 it is still a small percentage of the total time and it; may compress the data by a factor of 10. On the other hand if the time; spend on I/O is large, compression may have a large impact on the; program's performance. The compression factor, i.e. the savings of disk space, varies with the; type of data. A buffer with a same value array is compressed so that the; value is only written once. For example, a track has the mass of a pion; that it is always the same, and the charge of the pion that is either; positive or negative. For 1000 pions, the mass will be written only; once, and the charge only twice (positive and negative). When the data; is sparse, i.e. when there are many zeros, the compression factor is; also high. +---------------------+------------------+-------------------+-------------------+; | Compression level | Bytes | Write Time (sec) | Read Time (sec.) |; +---------------------+------------------+-------------------+-------------------+; | 0 | 1,004,998 | 4.77 | 0.07 |; +---------------------+------------------+-------------------+-------------------+; | 1 | 438,366 | 6.67 | 0.05 |; +---------------------+------------------+-------------------+-------------------+; | 5 | 429,871 | 7.03 | 0.06 |; +---------------------+------------------+-------------------+-------------------+; | 9 | 426,899 | 8.47 | 0.05 |; +---------------------+------------------+-------------------+-------------------+. The time to uncompress an object is small compared to the compression; time and is independent of the selected compression level. Note that the; compres",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:6402,Integrability,depend,dependent,6402,"------------------------------------+; | 33 `->` 33 | `fUnits` | Number of bytes for file pointers |; | [41-\>41] | | |; +-------------------+------------------+---------------------------------------+; | 34 `->` 37 | `fCompress` | Zip compression level |; | [42-\>45] | | |; +-------------------+------------------+---------------------------------------+; | 38 `->` 41 | `fSeekInfo` | Pointer to **`TStreamerInfo`** record |; | [46-\>53] | | |; +-------------------+------------------+---------------------------------------+; | 42 `->` 45 | `fNBytesInfo` | Number of bytes in |; | [54-\>57] | | **`TStreamerInfo`** record |; +-------------------+------------------+---------------------------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available f",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43674,Integrability,depend,depends,43674,"file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvert",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:49560,Integrability,depend,depending,49560," saved as `int` with `nbits` bits precision. For; more details see the io tutorials `double32.C`. ![Compression and precision of Double32\_t](pictures/030000EA.png). ### Prevent Splitting (//|| ). If you want to prevent a data member from being split when writing it to; a tree, append the characters || right after the comment string. This; only makes sense for object data members. For example:. ``` {.cpp}; EventHeader fEvtHdr; //|| do not split the header; ```. ### Streamers with Special Additions. Most of the time you can let `rootcling` generate a `Streamer` for you.; However if you want to write your own `Streamer `you can do so. For some; classes, it may be necessary to execute some code before or after the; read or write block in the automatic `Streamer`. For example after the; execution of the read block, one can initialize some non persistent; members. There are two reasons why you would need to write your own; Streamer: 1) if you have a non-persistent data member that you want to; initialize to a value depending on the read data members; 2) if you want; or need to handle the schema evolution on your own. Note that an alternative; for those cases is to consider write a schema evolution rule. First, you need to tell `rootcling` not to build a `Streamer `for you.; The input to the `rootcling` command (in the `makefile`) is a list of; classes in a `LinkDef.h` file. For example, the list of classes for; `Event` is listed in `$ROOTSYS/test/EventLinkDef.h`. The ""`-`"" at the; end of the class name tells `rootcling` not to generate a `Streamer`. In; the example, you can see the `Event` class is the only one for which; `rootcling` is instructed not to generate a `Streamer`. ``` {.cpp}; #ifdef __ROOTCLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:55607,Integrability,depend,dependencies,55607,"such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circular dependencies and consume a large amount of disk space. The; network of references must be preserved on disk and recreated upon; reading the file. If you use independent I/O operations for pointers and their referenced; objects you can use the **`TRef`** class. Later in this section is an; example that compares disk space, memory usage, and I/O times of C++; pointers and **`TRef`**`s`. In general, a **`TRef`** is faster than C++; but the advantage of a C++ pointer is that it is already C++. ### Streaming C++ Pointers. When ROOT encounters a pointer data member it calls the `Streamer` of; the object and labels it with a unique object identifier. The object; identifier is unique for one I/O operation. If there is another pointer; to the object in the same I/O operation, the first object is referenced; i.e. it is not saved again. When reading the file, the object is rebuilt; and the references recalculated. ![Streaming object pointers](pictures/020000EC.jpg). In this way, the netw",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:71431,Integrability,depend,dependent,71431,"e `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a data member (i.e. make it not persistent), add; a ""`!`"" after the comment marks. For example the pointer \*`fPainter` of; a **`TH1`** is not persistent:. ``` {.cpp}; TVirtualHistPainter* fPainter //!pointer to histogram painter; ```. ### The TStreamerElement Class. A **`TStreamerElement`** describes a data member of a simple type,; object, array, pointer, or container. The offset in the; **`TStreamerElement`** is the starting address of the data for that data; member. ``` {.cpp}; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; ```. In this example, the **`TNamed`** data starts at byte 0, and; **`TAttLine`** starts at byte 28. The offset is machine and compiler; dependent and is computed when the `StreamerInfo` is analyzed. The types; are defined in the file `TStreamerInfo.h` and listed here:. ``` {.cpp}; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; ```. The method `TClass::GetStreamerInfo` analyzes the `StreamerInfo` the; same way it would be analyzed by referring to the class. While analyzing; the `StreamerInfo`, it computes the offsets. The type field is the type; of the **`TStreamerElement`**. It is specific to the `StreamerInfo`; definition. ### Example: TH1 StreamerInfo. In the `StreamerInfo` of the **`TH1`** class we see the four base; classes: **`TNamed`**, **`TAttLine`**, **`TAttFill`**,; `and `**`TAttMarker`**.",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:77112,Integrability,interface,interface,77112,"d in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The automatic data model schema evolution implemented in ROOT makes it possible; to read back the serialized data object in the situation when the definition of; the classes those objects represent changed slightly (some of the data members were; removed or some new ones added). It is also possible to manually specify the rules; for more sophisticated data transformations done while reading to load the serialized; objects into data structures that changed quite significantly. ROOT provides two interface enabling users to specify the conversion rules. The; first way is to define a rule in the dictionary file and the second way is to insert; it to the TClass object using the C++ API. There are two types of conversion rules. The first of them, the normal rules, are; the ones that should be used in the most of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either i",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81491,Integrability,wrap,wrapping,81491,"al to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95601,Integrability,protocol,protocol,95601," *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.or",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95651,Integrability,protocol,protocols,95651,"t, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); roo",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:96229,Integrability,interface,interface,96229,"argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; com",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:6584,Modifiability,variab,variable,6584,"mpression level |; | [42-\>45] | | |; +-------------------+------------------+---------------------------------------+; | 38 `->` 41 | `fSeekInfo` | Pointer to **`TStreamerInfo`** record |; | [46-\>53] | | |; +-------------------+------------------+---------------------------------------+; | 42 `->` 45 | `fNBytesInfo` | Number of bytes in |; | [54-\>57] | | **`TStreamerInfo`** record |; +-------------------+------------------+---------------------------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:7096,Modifiability,variab,variable,7096,"--------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record. If the key; is located past the 32 bit file limit (\> 2 GB) then some fields will be; 8 bytes instead of 4 bytes (values between the brackets):. +--------------------+-------------------+--------------------------------------+; | Byte | Value Name | Description |; +--------------------+-------------------+--------------------------------------+; | 1 `->` 4 | `Nbytes` | Length of compressed object (in |; | | | bytes) |; +--------------------+---",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:10890,Modifiability,inherit,inheritance,10890,"ect title |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `Title` | Title of the object |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:10992,Modifiability,inherit,inheritance,10992," ... `->` ... | `Title` | Title of the object |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:20259,Modifiability,variab,variable,20259,"4 points to an object of class: TH1F at 5038; ```. In addition to the list of keys, **`TFile`** also keeps two other lists:; **`TFile`**`::fFree` is a **`TList`** of free blocks used to recycle; freed up space in the file. ROOT tries to find the best free block. If a; free block matches the size of the new object to be stored, the object; is written in the free block and this free block is deleted from the; list. If not, the first free block bigger than the object is used.; `TFile::fListHead` contains a sorted list (**`TSortedList`**) of objects; in memory. The diagram below illustrates the logical view of the; **`TFile`** and **`TKey`**. ![ROOT File/Directory/Key description](pictures/030000E7.png). ### Viewing the Logical File Contents. **`TFile`** is a descendent of **`TDirectory`**, which means it behaves; like a **`TDirectory`**. We can list the contents, print the name, and; create subdirectories. In a ROOT session, you are always in a directory; and the directory you are in is called the current directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21211,Modifiability,variab,variable,21211,"directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21610,Modifiability,variab,variable,21610,"ith it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21681,Modifiability,variab,variable,21681,"ist its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");; root[] gDirectory->pwd(); AFile1.root:/; ```. If you create ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:25586,Modifiability,inherit,inherits,25586,"l; read it from the file and create an object in memory. Here we draw the; profile histogram, and then we list the contents. ``` {.cpp}; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. We now see a new line that starts with OBJ. This means that an object of; class **`TProfile`**, called `hprof` has been added in memory to this; directory. This new `hprof` in memory is independent from the `hprof` on; disk. If we make changes to the `hprof` in memory, they are not; propagated to the `hprof` on disk. A new version of `hprof` will be; saved once we call `Write`. You may wonder why `hprof` is added to the objects in the current; directory. `hprof` is of the class **`TProfile`** that inherits from; **`TH1D`**, which inherits from **`TH1`**. **`TH1`** is the basic; histogram. All histograms and trees are created in the current directory; (also see ""Histograms and the Current Directory""). The reference to ""all; histograms"" includes objects of any class descending directly or; indirectly from **`TH1`**. Hence, our **`TProfile`** `hprof` is created; in the current directory `f.`There was another side effect when we; called the `TH1::Draw` method. ROOT printed this statement:. ``` {.cpp}; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. It tells us that a **`TCanvas`** was created and it named it `c1`. This; is where ROOT is being nice, and it creates a canvas for drawing the; histogram if no canvas was named in the draw command, and if no active; canvas exists. The newly created canvas, however, is NOT listed in the; contents of the current directory. Why is that? The canvas is not added; to the current directory, because by default ONLY histograms and tr",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:25619,Modifiability,inherit,inherits,25619,"l; read it from the file and create an object in memory. Here we draw the; profile histogram, and then we list the contents. ``` {.cpp}; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. We now see a new line that starts with OBJ. This means that an object of; class **`TProfile`**, called `hprof` has been added in memory to this; directory. This new `hprof` in memory is independent from the `hprof` on; disk. If we make changes to the `hprof` in memory, they are not; propagated to the `hprof` on disk. A new version of `hprof` will be; saved once we call `Write`. You may wonder why `hprof` is added to the objects in the current; directory. `hprof` is of the class **`TProfile`** that inherits from; **`TH1D`**, which inherits from **`TH1`**. **`TH1`** is the basic; histogram. All histograms and trees are created in the current directory; (also see ""Histograms and the Current Directory""). The reference to ""all; histograms"" includes objects of any class descending directly or; indirectly from **`TH1`**. Hence, our **`TProfile`** `hprof` is created; in the current directory `f.`There was another side effect when we; called the `TH1::Draw` method. ROOT printed this statement:. ``` {.cpp}; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. It tells us that a **`TCanvas`** was created and it named it `c1`. This; is where ROOT is being nice, and it creates a canvas for drawing the; histogram if no canvas was named in the draw command, and if no active; canvas exists. The newly created canvas, however, is NOT listed in the; contents of the current directory. Why is that? The canvas is not added; to the current directory, because by default ONLY histograms and tr",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:28283,Modifiability,inherit,inherit,28283,"nvas fXlowNDC=0 fYlowNDC=0 fWNDC=1 fHNDC=1; Name= c1 Title= c1; Option=TFrame X1= -4.000000 Y1=0.000000 X2=4.000000 Y2=19.384882; OBJ: TProfile hprof Profile of pz versus px : 0; TPaveText X1=-4.900000 Y1=20.475282 X2=-0.950000 Y2=21.686837 title; TPaveStats X1=2.800000 Y1=17.446395 X2=4.800000 Y2=21.323371 stats; ```. Lets proceed with our example and draw one more histogram, and we see; one more OBJ entry. ``` {.cpp}; root[] hpx->Draw(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. `TFile::ls()` loops over the list of objects in memory and the list of; objects on disk. In both cases, it calls the `ls()` method of each; object. The implementation of the `ls` method is specific to the class; of the object, all of these objects are descendants of **`TObject`** and; inherit the **`TObject`**`::ls()` implementation. The histogram classes; are descendants of **`TNamed`** that in turn is a descent of; `TObject`. In this case, **`TNamed::ls()`** is executed, and; it prints the name of the class, and the name and title of the object.; Each directory keeps a list of its objects in the memory. You can get; this list by **`TDirectory::GetList()`**. To see the lists in memory; contents you can do:. ``` {.cpp}; root[]f->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; ```. Since the file `f` is the current directory (***`gDirectory`***), this; will yield the same result:. ``` {.cpp}; root[] gDirectory->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; ```. ### Saving Histograms to Disk. At this time, the objects in memory (OBJ) are identical to the objects; on disk (KEY). Let's change tha",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:33587,Modifiability,inherit,inherit,33587,"hod. ``` {.cpp}; h->SetDirectory(newDir);; ```. If the parameter is 0, the histogram is no longer associated with a; directory. ``` {.cpp}; h->SetDirectory(0);; ```. Once a histogram is removed from the directory, it will no longer be; deleted when the directory is closed. It is now your responsibility to; delete this histogram object once you are finished with it. To change; the default that automatically adds the histogram to the current; directory, you can call the static function:. ``` {.cpp}; TH1::AddDirectory(kFALSE);; ```. In this case, you will need to do all the bookkeeping for all the; created histograms. ### Saving Objects to Disk. In addition to histograms and trees, you can save any object in a ROOT; file. For example to save a canvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:34311,Modifiability,inherit,inherit,34311,"anvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the key and use the; option` TObject::kSingleKey`. For example:. ``` {.cpp}; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; ```. ### A TFile Object Going Out of Scope. There is another important point to remember about `TFile::Close` and; **`TFile::Write`**. When a variable is declared on the stack in a function; such as in the code below, it will be deleted when it goes out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:34352,Modifiability,inherit,inherit,34352,"anvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the key and use the; option` TObject::kSingleKey`. For example:. ``` {.cpp}; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; ```. ### A TFile Object Going Out of Scope. There is another important point to remember about `TFile::Close` and; **`TFile::Write`**. When a variable is declared on the stack in a function; such as in the code below, it will be deleted when it goes out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:35060,Modifiability,variab,variable,35060,"of;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the key and use the; option` TObject::kSingleKey`. For example:. ``` {.cpp}; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; ```. ### A TFile Object Going Out of Scope. There is another important point to remember about `TFile::Close` and; **`TFile::Write`**. When a variable is declared on the stack in a function; such as in the code below, it will be deleted when it goes out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a **`TFile`** object is deleted an implicit call to; `TFile::Close` is made. This will save only the file descriptor to disk.; It contains the file header, the `StreamerInfo `list, the key list, the; free segment list, and the end address. See ""The Physical Layout of ROOT; Files"". The `TFile::Close` does not make a call to `Write()`, which; means that the objects in memory will not be saved in the file. You need; to explicitly call `TFile::Write()` to save the object in memory to file; before the exit of the function. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:35310,Modifiability,variab,variable,35310,"ollection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the key and use the; option` TObject::kSingleKey`. For example:. ``` {.cpp}; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; ```. ### A TFile Object Going Out of Scope. There is another important point to remember about `TFile::Close` and; **`TFile::Write`**. When a variable is declared on the stack in a function; such as in the code below, it will be deleted when it goes out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a **`TFile`** object is deleted an implicit call to; `TFile::Close` is made. This will save only the file descriptor to disk.; It contains the file header, the `StreamerInfo `list, the key list, the; free segment list, and the end address. See ""The Physical Layout of ROOT; Files"". The `TFile::Close` does not make a call to `Write()`, which; means that the objects in memory will not be saved in the file. You need; to explicitly call `TFile::Write()` to save the object in memory to file; before the exit of the function. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a **`TFile`** object `f`, that is available on a global; scope, and it will still be available when exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.r",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:36958,Modifiability,variab,variable,36958," f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a **`TFile`** object `f`, that is available on a global; scope, and it will still be available when exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets you organize its contents into; subdirectories, and **`TFile`** being a descendent of **`TDirectory`**; inherits this ability. Here is an example of a ROOT file with multiple; subdirectories as seen in the ROOT browser. To add a subdirectory to a; file use `TDirectory::mkdir`. The example below opens the file for; writing and creates a subdirectory called ""Wed011003"". Listing the; contents of the file shows the new directory in the file and the; **`TDirectory`** object in memory. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; ```. ``` {.cpp}; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirecto",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:37270,Modifiability,inherit,inherits,37270,"hen exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets you organize its contents into; subdirectories, and **`TFile`** being a descendent of **`TDirectory`**; inherits this ability. Here is an example of a ROOT file with multiple; subdirectories as seen in the ROOT browser. To add a subdirectory to a; file use `TDirectory::mkdir`. The example below opens the file for; writing and creates a subdirectory called ""Wed011003"". Listing the; contents of the file shows the new directory in the file and the; **`TDirectory`** object in memory. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; ```. ``` {.cpp}; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirectory Wed011003;1 Wed011003; ```. We can change the current directory by navigating into the subdirectory,; and after changing directory; we can see that ***`gDirectory`*** is now; ""`Wed011003`"". ``` {.cpp}; root[] f->cd(""Wed011003""); root[] gDirectory->pwd(); AFile.root:/Wed011003; ```. In addition to ***`gDirectory`*",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:40752,Modifiability,variab,variable,40752,"11003/histo;1"",h); ```. If file is written, a copy of `histo` will be in the top directory. This; is an effective way to copy an object from one directory to another. In; contrast, in the code box below, `histo` will be in memory in the; subdirectory because we changed the current directory. ``` {.cpp}; root[] f->cd(""Wed011003""); root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); ```. Note that there is no warning if the retrieving was not successful. You; need to explicitly check the value of h, and if it is null, the object; could not be found. For example, if you did not give the path name the; histogram cannot be found and the pointer to h is null:. ``` {.cpp}; root[] TH1 *h; gDirectory->GetObject(""Wed011003/histo;1"",h); root[] h; (class TH1*)0x10767de0; root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); root[] h; (class TH1*)0x0; ```. To remove a subdirectory you need to use `TDirectory::Delete`. There is; no **`TDirectory::rmdir`**. The Delete method takes a string containing; the variable name and cycle number as a parameter. ``` {.cpp}; void Delete(const char *namecycle); ```. The `namecycle` string has the format `name;cycle`. The next are some; rules to remember:. - `name` = \* means all, but don't remove the subdirectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41955,Modifiability,variab,variable,41955,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:42119,Modifiability,variab,variable,42119,"ory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43000,Modifiability,inherit,inheritance,43000,"other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generat",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43161,Modifiability,inherit,inheritance,43161,"if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44212,Modifiability,inherit,inherits,44212,"le data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->Wr",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47474,Modifiability,variab,variable,47474,"o the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min` and `max` can be explicit values or expressions of values known; to Cling (e.g. `pi`). If `nbit",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47637,Modifiability,variab,variable,47637,">; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min` and `max` can be explicit values or expressions of values known; to Cling (e.g. `pi`). If `nbits` is present, the member is saved as `int` with `nbits` bits precision. For; more details see the io tutorials `double32.C`. ![Compression and precision ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47674,Modifiability,variab,variable,47674,">; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min` and `max` can be explicit values or expressions of values known; to Cling (e.g. `pi`). If `nbits` is present, the member is saved as `int` with `nbits` bits precision. For; more details see the io tutorials `double32.C`. ![Compression and precision ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79406,Modifiability,variab,variables,79406,"""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81350,Modifiability,variab,variables,81350,": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the r",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81546,Modifiability,variab,variables,81546,"al to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81627,Modifiability,variab,variables,81627,"st has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81669,Modifiability,variab,variable,81669,"ulating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:82264,Modifiability,variab,variables,82264,"ippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution. If you have written your own `Streamer` as described in the section; ""Streamers with Special Additions"", you will have to manually add code; for each version and manage the evolution of your class. When you add or; remove data members, you must modify the `Streamer` by hand. ROOT; assumes that you have increased the class version numbe",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:96419,Modifiability,plug-in,plug-in,96419,"r; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communi",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98196,Modifiability,plug-in,plug-in,98196," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:51753,Performance,load,loaded,51753,"s a; parameter, and first checks to see if this is a case of reading or; writing the buffer. ``` {.cpp}; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; fTransient = gDirectory; //save current directory; fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. ### Writing Objects. The `Streamer` decomposes the objects into data members and writes them; to a buffer. It does not write the buffer to a file, it simply populates; a buffer with bytes representing the object. This allows us to write the; buffer to a file or do anything else we could do with the buffer. For; example, we can write it to a socket to send it over the network. This; is beyond the scope of this chapter, but it is worthwhile to emphasize; the need and advantage of separating the creation of the buffer from its; use. Let us look how a buffer is written to a file. The dictionary for a; class needs to be loaded before any object of that type can be saved. The `TObject::Write` method does the following:. - Creates a **`TKey`** object in the current directory. - Creates a **`TBuffer`** object which is part of the newly created; **`TKey`**. - Fills the **`TBuffer`** with a call to the `class::Streamer` method. - Creates a second buffer for compression, if needed. - Reserves space by scanning the **`TFree`** list. At this point, the; size of the buffer is known. - Writes the buffer to the file. - Releases the **`TBuffer`** part of the key. In other words, the `TObject::Write` calls the `Streamer` method of the; class to build the buffer. The buffer is in the key and the key is; written to disk. Once written to disk the memory consumed by the buffer; part is released. The key part of the **`TKey`** is kept. ![A diagram of a streamed TH1F in the buffer](pictures/020000EB.jpg). The key consumes about 60 bytes, whereas the buffer, since it contains; the object data, can be very large. ### Ignore Ob",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54030,Performance,perform,performance,54030,"ject::Streamer`, and the **`TObject`** part; of the class is not streamed to the file. This is useful in case you do; not use the **`TObject`** `fBits` and `fUniqueID `data members. You gain; space on the file, and you do not loose functionality if you do not use; the `fBits` and `fUniqueID. `See ""The Role of TObject"" on the use of; `fBits` and `fUniqueID`. ### Streaming a TClonesArray. When writing a **`TClonesArray`** it bypasses by default the; `Streamer `of the member class and uses a more efficient internal; mechanism to write the members to the file. You can override the default; and specify that the member class `Streamer `is used by setting the; `TClonesArray::BypassStreamer` bit to false:. ``` {.cpp}; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; ```. When the `kBypassStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54259,Performance,optimiz,optimized,54259,"a members. You gain; space on the file, and you do not loose functionality if you do not use; the `fBits` and `fUniqueID. `See ""The Role of TObject"" on the use of; `fBits` and `fUniqueID`. ### Streaming a TClonesArray. When writing a **`TClonesArray`** it bypasses by default the; `Streamer `of the member class and uses a more efficient internal; mechanism to write the members to the file. You can override the default; and specify that the member class `Streamer `is used by setting the; `TClonesArray::BypassStreamer` bit to false:. ``` {.cpp}; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; ```. When the `kBypassStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54579,Performance,optimiz,optimized,54579,"ile. You can override the default; and specify that the member class `Streamer `is used by setting the; `TClonesArray::BypassStreamer` bit to false:. ``` {.cpp}; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; ```. When the `kBypassStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circula",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54686,Performance,perform,performance,54686,"ile. You can override the default; and specify that the member class `Streamer `is used by setting the; `TClonesArray::BypassStreamer` bit to false:. ``` {.cpp}; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; ```. When the `kBypassStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circula",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54895,Performance,optimiz,optimization,54895,"assStreamer` bit is set, the automatically generated; `Streamer `can call directly the method **`TClass::WriteBuffer`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circular dependencies and consume a large amount of disk space. The; network of references must be preserved on disk and recreated upon; reading the file. If you use independent I/O operations for pointers and their referenced; objects you can use the **`TRef`** class. Lat",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:54945,Performance,optimiz,optimized,54945,"`**.; Bypassing the `Streamer` improves the performance when writing/reading; the objects in the **`TClonesArray`**. However, the drawback is when a; **`TClonesArray`** is written with `split=0` bypassing the `Streamer`,; the `StreamerInfo `of the class in the array being optimized, one cannot; later use the **`TClonesArray`** with `split > 0`. For example, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circular dependencies and consume a large amount of disk space. The; network of references must be preserved on disk and recreated upon; reading the file. If you use independent I/O operations for pointers and their referenced; objects you can use the **`TRef`** class. Later in this section is an; example that compares disk space, memory usage, and I/O times of C++; pointers and **`TRef",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:55385,Performance,optimiz,optimized,55385,"e, there is; a problem with the following scenario: a class `Foo` has a; **`TClonesArray`** of `Bar` objects the `Foo` object is written with; `split=0` to `Tree` `T1`. In this case the `StreamerInfo` for the class; `Bar` is created in optimized mode in such a way that data members of; the same type are written as an array improving the I/O performance. In; a new program, `T1` is read and a new `Tree` `T2` is created with the; object `Foo` in `split > 1`. When the `T2 `branch is created, the `StreamerInfo` for the class `Bar`; is created with no optimization (mandatory for the split mode). The; optimized Bar `StreamerInfo` is going to be used to read the; **`TClonesArray`** in `T1`. The result will be `Bar` objects with data; member values not in the right sequence. The solution to this problem is; to call `BypassStreamer(kFALSE)` for the **`TClonesArray`**. In this; case, the normal `Bar::Streamer` function will be called. The; `Bar::Streamer` function works OK independently if the `Bar`; `StreamerInfo `had been generated in optimized mode or not. ## Pointers and References in Persistency. An object pointer as a data member presents a challenge to the streaming; software. If the object pointed to is saved every time, it could create; circular dependencies and consume a large amount of disk space. The; network of references must be preserved on disk and recreated upon; reading the file. If you use independent I/O operations for pointers and their referenced; objects you can use the **`TRef`** class. Later in this section is an; example that compares disk space, memory usage, and I/O times of C++; pointers and **`TRef`**`s`. In general, a **`TRef`** is faster than C++; but the advantage of a C++ pointer is that it is already C++. ### Streaming C++ Pointers. When ROOT encounters a pointer data member it calls the `Streamer` of; the object and labels it with a unique object identifier. The object; identifier is unique for one I/O operation. If there is another pointer; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:74891,Performance,optimiz,optimized,74891,"pe=65 histogram options; TList* fFunctions offset=548 type=63 ->Pointer to list of functions; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:75040,Performance,perform,performance,75040,"pe= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<V",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:75053,Performance,optimiz,optimization,75053,"pe= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<V",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:77010,Performance,load,load,77010,"ame>,<VersionNumber>); ```. The version number identifies this particular version of the class. When; a class has version 0 it is not stored in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The automatic data model schema evolution implemented in ROOT makes it possible; to read back the serialized data object in the situation when the definition of; the classes those objects represent changed slightly (some of the data members were; removed or some new ones added). It is also possible to manually specify the rules; for more sophisticated data transformations done while reading to load the serialized; objects into data structures that changed quite significantly. ROOT provides two interface enabling users to specify the conversion rules. The; first way is to define a rule in the dictionary file and the second way is to insert; it to the TClass object using the C++ API. There are two types of conversion rules. The first of them, the normal rules, are; the ones that should be used in the most of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79649,Performance,cache,cached,79649,"s"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list ha",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:85057,Performance,load,loaded,85057,"between `Streamer` writers and readers are frequent; and increase as the number of classes increase. We recommend you use; `rootcling` generated `Streamers` whenever you can, and profit from the; automatic schema evolution. ### Building Class Definitions with the StreamerInfo. A ROOT file's `StreamerInfo `list contains the description of all; versions of all classes in the file. When a file is opened the; `StreamerInfo `is read into memory and it provides enough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy u",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:85360,Performance,load,load,85360,"contains the description of all; versions of all classes in the file. When a file is opened the; `StreamerInfo `is read into memory and it provides enough information to; make the file browsable. The `TStreamerInfo `enables us to recreate a; header file for the class in case the compiled class is not available.; This is done with the `TFile::MakeProject` method. It creates a; directory with the header files for the named classes and a `makefile`; to compile a shared library with the class definitions. ### Example: MakeProject. To explain the details, we use the example of the `ATLFast` project that; is a fast simulation for the ATLAS experiment. The complete source for; `ATLFast` can be down loaded at; <ftp://root.cern.ch/root/atlfast.tar.gz>. Once we compile and run; `ATLFast` we get a ROOT file called `atlfast.root`, containing the; `ATLFast` objects. When we open the file, we get a warning that the file; contains classes that are not in the dictionary. This is correct; since we did not load the class definitions. ``` {.cpp}; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; ```. We can see the `StreamerInfo `for the classes:. ``` {.cpp}; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; ```. However, when we try to u",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:89256,Performance,load,loads,89256," creates as in; ""new"", in addition if the directory does exist, all existing files; are deleted before creating the new files. - ""`update`"" The new classes are added to the existing directory and; the existing classes are replaced with the new definition. If the; directory does not exist, it creates it as in ""new"". - ""+"": This option can be used in combination with the other three. It; will create the necessary files to easily build a shared library; containing the class definitions.Specifically it will:. - Generate a script called `MAKE` that builds the shared library; containing the definition of all classes in the directory. - Generate a `LinkDef.h `files to use with `rootcling` in `MAKE`. - Run `rootcling` to generate a `<dirname>ProjectDict.cxx` file. - Compile the \<`dirname>ProjectDict.cxx `with the current options in; `compiledata.h`. - Build a shared library` <dirname>.so`. - ""++"":This option can be used instead of the single ""+"". It does; everything the single ""+"" does, and dynamically loads the shared; library `<dirname>.so`. This example makes a directory called `MyProject` that will contain all; class definitions from the `atlfast.root` file. The necessary `makefile`; to build a shared library are also created, and since the '++' is; appended, the shared library is also loaded. ``` {.cpp}; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; ```. The contents of `MyProject`:. ``` {.cpp}; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjec",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:89549,Performance,load,loaded,89549,"w definition. If the; directory does not exist, it creates it as in ""new"". - ""+"": This option can be used in combination with the other three. It; will create the necessary files to easily build a shared library; containing the class definitions.Specifically it will:. - Generate a script called `MAKE` that builds the shared library; containing the definition of all classes in the directory. - Generate a `LinkDef.h `files to use with `rootcling` in `MAKE`. - Run `rootcling` to generate a `<dirname>ProjectDict.cxx` file. - Compile the \<`dirname>ProjectDict.cxx `with the current options in; `compiledata.h`. - Build a shared library` <dirname>.so`. - ""++"":This option can be used instead of the single ""+"". It does; everything the single ""+"" does, and dynamically loads the shared; library `<dirname>.so`. This example makes a directory called `MyProject` that will contain all; class definitions from the `atlfast.root` file. The necessary `makefile`; to build a shared library are also created, and since the '++' is; appended, the shared library is also loaded. ``` {.cpp}; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; ```. The contents of `MyProject`:. ``` {.cpp}; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; ```. Now you can load the shared library in any consecutive root session to; use the `atlfast` classes. ``` {.cpp}; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; ``",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:90321,Performance,load,load,90321," contain all; class definitions from the `atlfast.root` file. The necessary `makefile`; to build a shared library are also created, and since the '++' is; appended, the shared library is also loaded. ``` {.cpp}; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; ```. The contents of `MyProject`:. ``` {.cpp}; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; ```. Now you can load the shared library in any consecutive root session to; use the `atlfast` classes. ``` {.cpp}; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; ```. This is an example of a generated header file:. ``` {.cpp}; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtua",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:92391,Performance,perform,performance,92391,"on() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; ```. ## Compression and Performance. ROOT uses a compression algorithm based on the well-known `gzip`; algorithm. It supports nine levels of compression. The default for ROOT; is one. The compression level can be set with the method; `TFile::SetCompressionLevel`. The experience with this algorithm shows; that a compression level of 1.3 for raw data files and around two on; most DST files is the optimum. The choice of one for the default is a; compromise between the time it takes to read and write the object vs.; the disk space savings. To specify no compression, set the level to zero. We recommend using compression when the time spent in I/O is small; compared to the total processing time. If the I/O operation is increased; by a factor of 5 it is still a small percentage of the total time and it; may compress the data by a factor of 10. On the other hand if the time; spend on I/O is large, compression may have a large impact on the; program's performance. The compression factor, i.e. the savings of disk space, varies with the; type of data. A buffer with a same value array is compressed so that the; value is only written once. For example, a track has the mass of a pion; that it is always the same, and the charge of the pion that is either; positive or negative. For 1000 pions, the mass will be written only; once, and the charge only twice (positive and negative). When the data; is sparse, i.e. when there are many zeros, the compression factor is; also high. +---------------------+------------------+-------------------+-------------------+; | Compression level | Bytes | Write Time (sec) | Read Time (sec.) |; +---------------------+------------------+-------------------+-------------------+; | 0 | 1,004,998 | 4.77 | 0.07 |; +---------------------+------------------+-------------------+-------------------+; | 1 | 438,366 | 6.67 | 0.05 |; +---------------------+------------------",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98094,Performance,load,loaded,98094," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98181,Performance,load,loaded,98181," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:228,Safety,recover,recovery,228,"# Input/Output; \index{I/O}. This chapter covers the saving and reading of objects to and from ROOT; files. It begins with an explanation of the physical layout of a ROOT; file. It includes a discussion on compression, and file recovery. Then; we explain the logical file, the class **`TFile`** and its methods. We; show how to navigate in a file, how to save objects and read them back.; We also include a discussion on `Streamers`. `Streamers` are the methods; responsible to capture an objects current state to save it to disk or; send it over the network. At the end of the chapter is a discussion on; the two specialized ROOT files: **`TNetFile`** and **`TWebFile`**. ## The Physical Layout of ROOT Files. A ROOT file is like a UNIX file directory. It can contain directories; and objects organized in unlimited number of levels. It also is stored; in machine independent format (ASCII, IEEE floating point, Big Endian; byte ordering). To look at the physical layout of a ROOT file, we first; create one. This example creates a ROOT file and 15 histograms, fills; each histogram with 1000 entries from a Gaussian distribution, and; writes them to the file. ``` {.cpp}; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of Histograms; TH1F* h; // create a pointer to a histogram; // make and fill 15 histograms and add them to the object array; for (Int_t i = 0; i < 15; i++) {; sprintf(name,""h%d"",i);; sprintf(title,""histo nr:%d"",i);; h = new TH1F(name,title,100,-4,4);; Hlist.Add(h);; h->FillRandom(""gaus"",1000);; }; // open a file and write the array to the file; TFile f(""demo.root"",""recreate"");; Hlist.Write();; f.Close();; }; ```. The example begins with a call to the **`TFile`** constructor. This; class is describing the ROOT file (that has the extension ""`.root`""). In; the next section, we will cover **`TFile`** in details. The last line of; the example closes the file. To view its contents we need to open it; again, and to create a **`TBrowser`** object by:. ``` ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:14998,Safety,recover,recover,14998,"e output of `TFile::Map()` are the list of; keys, the list of free segments, and the address where the data ends..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When w",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15097,Safety,recover,recovery,15097,"ds..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery at",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15126,Safety,redund,redundant,15126,"ds..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery at",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15325,Safety,recover,recovery,15325," KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file se",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15531,Safety,recover,recovery,15531,"tes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15718,Safety,recover,recovery,15718,"rrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class;",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15788,Safety,recover,recover,15788,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15851,Safety,recover,recovered,15851,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15928,Safety,abort,aborted,15928,"e file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; roo",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16104,Safety,recover,recovery,16104,"ides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16236,Safety,recover,recover,16236,", it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16257,Safety,recover,recovered,16257,", it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:56889,Safety,avoid,avoid,56889,"ares disk space, memory usage, and I/O times of C++; pointers and **`TRef`**`s`. In general, a **`TRef`** is faster than C++; but the advantage of a C++ pointer is that it is already C++. ### Streaming C++ Pointers. When ROOT encounters a pointer data member it calls the `Streamer` of; the object and labels it with a unique object identifier. The object; identifier is unique for one I/O operation. If there is another pointer; to the object in the same I/O operation, the first object is referenced; i.e. it is not saved again. When reading the file, the object is rebuilt; and the references recalculated. ![Streaming object pointers](pictures/020000EC.jpg). In this way, the network of pointers and their objects is rebuilt and; ready to use the same way it was used before it was persistent. If the; pointer hold the address of an object which in embedded in another; object (as opposed to being pointed to by a pointer), the object will be; duplicate at read time. To avoid this, make the pointer a transient data; member. ### Motivation for the TRef Class. If the object is split into several files or into several branches of; one or more `TTrees`, standard C++ pointers cannot be used because each; I/O operation will write the referenced objects, and multiple copies; will exist. In addition, if the pointer is read before the referenced; object, it is null and may cause a run time system error. To address; these limitations, ROOT offers the **`TRef`** class. **`TRef`** allows referencing an object in a different branch and/or in; a different file. **`TRef`** also supports the complex situation where a; **`TFile`** is updated multiple times on the same machine or a different; machine. When a **`TRef`** is read before its referenced object, it is; null. As soon as the referenced object is read, the **`TRef`** points to; it. In addition, one can specify an action to be taken by **`TRef`** in; the case it is read before its reference object (see""Action on Demand""; below). ### Usi",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:62760,Safety,avoid,avoid,62760,"(`TObjArray *fObjects`) that keeps; track of all referenced objects. If a referenced object has a; `fUniqueID`, a pointer to this unique object may be found using; `fObjects->At(fUniqueID)`. In the same way, when a **`TRef::GetObject`**; is called, `GetObject` uses its own `fUniqueID` to find the pointer to; the referenced object. See `TProcessID::GetObjectWithID` and; `PutObjectWithID`. #### Object Number. When an object is referenced, a unique identifier is computed and stored; in both the `fUniqueID` of the referenced and referencing object. This; `uniqueID` is computed by incrementing by one the static global in; `TProcessID::fgNumber`. The `fUniqueID` is the serial object number in; the current session. One can retrieve the current `fgNumber` value by; calling the static function `TProcessID::GetObjectCount` at any time or; can set this number by **`TProcessID::SetObjectCount`**. To avoid a; growing table of `fObjects` in `TProcessID`, in case, for example, one; processes many events in a loop, it might be necessary to reset the; object number at the end of processing of one event. See an example in; `$ROOTSYS/test/Event.cxx` (look at function `Build`). The value of; `ObjectNumber `may be saved at the beginning of one event and reset to; this original value at the end of the event. These actions may be; nested. ``` {.cpp}; saveNumber = TProcessID::GetObjectCount();; ...; TProcessID::SetObjectCount(savedNumber);; ```. ### Action on Demand. The normal behavior of a **`TRef`** has been described above. In; addition, **`TRef`** supports ""Actions on Demand"". It may happen that; the referenced object is not yet in the memory, on a separate file or; not yet computed. In this case, **`TRef`** is able to execute; automatically an action:. - Call to a compiled function (static function of member function). - Call to an interpreted function. - Execution of a Cling script. #### How to Select This Option?. In the definition of the **`TRef`** data member in the original clas",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16503,Security,access,access,16503,"ed in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TKey Name = h6, Title = histo nr:6, Cycle = 1; TKey Name = h7, Title = histo nr:7, Cycle = 1; TKey Name = h8, Title = histo nr:8, Cycle = 1; TKey Name = h9, Title = histo nr:9, Cycle = 1; TKey Name = h10, Title = histo nr:10, ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16552,Security,access,access,16552,"ed in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TKey Name = h6, Title = histo nr:6, Cycle = 1; TKey Name = h7, Title = histo nr:7, Cycle = 1; TKey Name = h8, Title = histo nr:8, Cycle = 1; TKey Name = h9, Title = histo nr:9, Cycle = 1; TKey Name = h10, Title = histo nr:10, ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:61643,Security,access,accessible,61643,"ect, which provides a globally unique; identifier. The **`TUUID`** class implements the UUID (Universally; Unique Identifier), also known as GUID (Globally Unique Identifier). A; UUID is 128 bits long, and if generated according to this algorithm, is; either guaranteed to be different from all other UUID generated until; 3400 A.D. or extremely likely to be different. The **`TROOT`** constructor automatically creates a **`TProcessID`**.; When a **`TFile`** contains referenced objects, the **`TProcessID`**; object is written to the file. If a file has been written in multiple; sessions (same machine or not), a **`TProcessID`** is written for each; session. The **`TProcessID`** objects are used by **`TRef`** to uniquely; identify the referenced **`TObject`**. When a referenced object is read from a file (its bit `kIsReferenced` is; set), this object is entered into the objects table of the corresponding; **`TProcessID`**. Each **`TFile`** has a list of **`TProcessIDs`** (see; `TFile::fProcessIDs`) also accessible from `TProcessID::fgPIDs`; (for all files). When this object is deleted, it is removed from the; table via the cleanup mechanism invoked by the **`TObject`** destructor.; Each **`TProcessID`** has a table (`TObjArray *fObjects`) that keeps; track of all referenced objects. If a referenced object has a; `fUniqueID`, a pointer to this unique object may be found using; `fObjects->At(fUniqueID)`. In the same way, when a **`TRef::GetObject`**; is called, `GetObject` uses its own `fUniqueID` to find the pointer to; the referenced object. See `TProcessID::GetObjectWithID` and; `PutObjectWithID`. #### Object Number. When an object is referenced, a unique identifier is computed and stored; in both the `fUniqueID` of the referenced and referencing object. This; `uniqueID` is computed by incrementing by one the static global in; `TProcessID::fgNumber`. The `fUniqueID` is the serial object number in; the current session. One can retrieve the current `fgNumber` value by; ca",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:67647,Security,access,access,67647,"piled or interpreted function `GetWebHistogram()` would have been; called instead of the Cling script `GetWebHistogram.C.`. ### Array of TRef. When storing multiple **`TRef`**s, it is more efficient to use a; **`TRefArray`**. The efficiency is due to having a single pointer `fPID`; for all `TRefs` in the array. It has a dynamic compact table of; `fUniqueIDs`. We recommend that you use a **`TRefArray`** rather then a; collection of `TRefs`. Example:. - Suppose a `TObjArray *mytracks` containing a list of `Track`; objects. - Suppose a `TRefArray *pions` containing pointers to the pion tracks; in `mytracks`. This list is created with statements like:; `pions->Add(track);`. - Suppose a `TRefArray *muons` containing pointers to the muon tracks; in `mytracks`. The 3 arrays `mytracks`,` pions` and `muons` may be written separately. ## Schema Evolution. Schema evolution is a problem faced by long-lived data. When a schema; changes, existing persistent data can become inaccessible unless the; system provides a mechanism to access data created with previous; versions of the schema. In the lifetime of collaboration, the class; definitions (i.e. the schema) are likely to change frequently. Not only; can the class itself change, but any of its parent classes or data; member classes can change also. This makes the support for schema; evolution necessary. ROOT fully supports schema evolution. The next figure below illustrates; some of the scenarios. ![The ROOT schema evolution](pictures/020000ED.jpg). The top half represents different versions of the shared library with; the class definitions. These are the in-memory class versions. The; bottom half represents data files that contain different versions of the; classes. - An old version of a shared library and a file with new class; definitions - this can be the case when someone has not updated the; library and is reading a new file. - Reading a file with a shared library that is missing a class; definition (i.e. missing class D). ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:78420,Security,checksum,checksum,78420," of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in a LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. - For dictionaries created from a LinkDef file:. ``` {.cpp}; #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:78982,Security,checksum,checksum,78982,"other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in a LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. - For dictionaries created from a LinkDef file:. ``` {.cpp}; #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79660,Security,access,accessible,79660,"s"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list ha",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:80529,Security,checksum,checksum,80529,";; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be define",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:80551,Security,checksum,checksums,80551,";; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be define",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:82860,Security,access,accessed,82860,"ct class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution. If you have written your own `Streamer` as described in the section; ""Streamers with Special Additions"", you will have to manually add code; for each version and manage the evolution of your class. When you add or; remove data members, you must modify the `Streamer` by hand. ROOT; assumes that you have increased the class version number in the; `ClassDef` statement and introduced the relevant test in the read part; of the Streamer. For example, if a new version of the `Event` class; above includes a new member: `Int_t fNew` the `ClassDef` statement; should be changed to `ClassDef(Event,2)` and the following lines should; be added to the read part of the `Streamer`:. ``` {.cpp}; if (R__v > 1) R__b >> fNew;; else fNew = 0; // set to some default value; ```. If, in the same new version 2 you remove the member `fH`, you must add; the following code to read the histogram object i",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95103,Security,access,access,95103,"cant,; the macro was modified to create 1000 histograms. We have included two; more examples to show the impact of compression on Trees in the next; chapter. ### Using the General Open Function of TFile. To make life simple we provide a general function to open any type of; file (except shared memory files of class **`TMapFile`**). This; functionality is provided by the static `TFile::Open()` function:. ``` {.cpp}; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`T",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:95550,Security,access,accessed,95550," *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.or",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:259,Testability,log,logical,259,"# Input/Output; \index{I/O}. This chapter covers the saving and reading of objects to and from ROOT; files. It begins with an explanation of the physical layout of a ROOT; file. It includes a discussion on compression, and file recovery. Then; we explain the logical file, the class **`TFile`** and its methods. We; show how to navigate in a file, how to save objects and read them back.; We also include a discussion on `Streamers`. `Streamers` are the methods; responsible to capture an objects current state to save it to disk or; send it over the network. At the end of the chapter is a discussion on; the two specialized ROOT files: **`TNetFile`** and **`TWebFile`**. ## The Physical Layout of ROOT Files. A ROOT file is like a UNIX file directory. It can contain directories; and objects organized in unlimited number of levels. It also is stored; in machine independent format (ASCII, IEEE floating point, Big Endian; byte ordering). To look at the physical layout of a ROOT file, we first; create one. This example creates a ROOT file and 15 histograms, fills; each histogram with 1000 entries from a Gaussian distribution, and; writes them to the file. ``` {.cpp}; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of Histograms; TH1F* h; // create a pointer to a histogram; // make and fill 15 histograms and add them to the object array; for (Int_t i = 0; i < 15; i++) {; sprintf(name,""h%d"",i);; sprintf(title,""histo nr:%d"",i);; h = new TH1F(name,title,100,-4,4);; Hlist.Add(h);; h->FillRandom(""gaus"",1000);; }; // open a file and write the array to the file; TFile f(""demo.root"",""recreate"");; Hlist.Write();; f.Close();; }; ```. The example begins with a call to the **`TFile`** constructor. This; class is describing the ROOT file (that has the extension ""`.root`""). In; the next section, we will cover **`TFile`** in details. The last line of; the example closes the file. To view its contents we need to open it; again, and to create a **`TBrowser`** object by:. ``` ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:19800,Testability,log,logical,19800,"class: TH1F at 2240; key: h7 points to an object of class: TH1F at 2582; key: h8 points to an object of class: TH1F at 2937; key: h9 points to an object of class: TH1F at 3293; key: h10 points to an object of class: TH1F at 3639; key: h11 points to an object of class: TH1F at 3986; key: h12 points to an object of class: TH1F at 4339; key: h13 points to an object of class: TH1F at 4694; key: h14 points to an object of class: TH1F at 5038; ```. In addition to the list of keys, **`TFile`** also keeps two other lists:; **`TFile`**`::fFree` is a **`TList`** of free blocks used to recycle; freed up space in the file. ROOT tries to find the best free block. If a; free block matches the size of the new object to be stored, the object; is written in the free block and this free block is deleted from the; list. If not, the first free block bigger than the object is used.; `TFile::fListHead` contains a sorted list (**`TSortedList`**) of objects; in memory. The diagram below illustrates the logical view of the; **`TFile`** and **`TKey`**. ![ROOT File/Directory/Key description](pictures/030000E7.png). ### Viewing the Logical File Contents. **`TFile`** is a descendent of **`TDirectory`**, which means it behaves; like a **`TDirectory`**. We can list the contents, print the name, and; create subdirectories. In a ROOT session, you are always in a directory; and the directory you are in is called the current directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimp",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44147,Testability,test,test,44147,"ey in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {;",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44845,Testability,test,test,44845,"creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. When writing an `Event` object, `TClass::WriteBuffer` is called.; `WriteBuffer` writes the current version number of the `Event class,`; and its contents into the buffer `R__b`. The `Streamer `calls; **`TClass::ReadBuffer`** when reading an `Event` object. The `ReadBuffer`; method reads the information from buffer `R__b` into the `Event`; object. ### Transient Data Members (//!). To prevent a data member from being written to the file, insert a ""`!`""; as the first character after the comment marks. It tells ROOT not to; save that data member in a root file when saving the class. For e",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:49995,Testability,test,test,49995," do not split the header; ```. ### Streamers with Special Additions. Most of the time you can let `rootcling` generate a `Streamer` for you.; However if you want to write your own `Streamer `you can do so. For some; classes, it may be necessary to execute some code before or after the; read or write block in the automatic `Streamer`. For example after the; execution of the read block, one can initialize some non persistent; members. There are two reasons why you would need to write your own; Streamer: 1) if you have a non-persistent data member that you want to; initialize to a value depending on the read data members; 2) if you want; or need to handle the schema evolution on your own. Note that an alternative; for those cases is to consider write a schema evolution rule. First, you need to tell `rootcling` not to build a `Streamer `for you.; The input to the `rootcling` command (in the `makefile`) is a list of; classes in a `LinkDef.h` file. For example, the list of classes for; `Event` is listed in `$ROOTSYS/test/EventLinkDef.h`. The ""`-`"" at the; end of the class name tells `rootcling` not to generate a `Streamer`. In; the example, you can see the `Event` class is the only one for which; `rootcling` is instructed not to generate a `Streamer`. ``` {.cpp}; #ifdef __ROOTCLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ class EventHeader+;; ```. The ""`+`"" sign tells `rootcling` to use the new `Streamer `system; introduced in ROOT 3.0. The following is an example of a customized; `Streamer `for `Event`. The `Streamer` takes a **`TBuffer`** as a; parameter, and first checks to see if this is a case of reading or; writing the buffer. ``` {.cpp}; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; f",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:58254,Testability,test,test,58254,"read before the referenced; object, it is null and may cause a run time system error. To address; these limitations, ROOT offers the **`TRef`** class. **`TRef`** allows referencing an object in a different branch and/or in; a different file. **`TRef`** also supports the complex situation where a; **`TFile`** is updated multiple times on the same machine or a different; machine. When a **`TRef`** is read before its referenced object, it is; null. As soon as the referenced object is read, the **`TRef`** points to; it. In addition, one can specify an action to be taken by **`TRef`** in; the case it is read before its reference object (see""Action on Demand""; below). ### Using TRef. A **`TRef`** is a lightweight object pointing to any **`TObject`**. This; object can be used instead of normal C++ pointers in case:. - The referenced object R and the pointer P are not written to the; same file. - P is read before R. - R and P are written to different Tree branches. Below is a line from the example in `$ROOTSYS/test/Event.cxx.`. ``` {.cpp}; TRef fLastTrack; //pointer to last track; ...; Track *track = (Track*)fTracks->ConstructedAt(fNtrack++);; track->Set(random);; // Save reference to last Track in the collection of Tracks; fLastTrack = track;; ```. The `track` and its reference `fLastTrack` can be written with two; separate I/O calls in the same or in different files, in the same or in; different branches of a **`TTree`**. If the **`TRef`** is read and the; referenced object has not yet been read, **`TRef`** will return a null; pointer. As soon as the referenced object will be read, **`TRef`** will; point to it. ### How Does It Work?. A **`TRef`** is itself a **`TObject`** with an additional transient; pointer `fPID`. When a **`TRef`** is used to point to a; **`TObject`**` *R`, for example in a class with. ``` {.cpp}; TRef P;; ```. one can do:. ``` {.cpp}; P = R; //to set the pointer; ```. When the statement `P = R `is executed, the following happens:. - The pointer `fPID`",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:62992,Testability,test,test,62992,"o this unique object may be found using; `fObjects->At(fUniqueID)`. In the same way, when a **`TRef::GetObject`**; is called, `GetObject` uses its own `fUniqueID` to find the pointer to; the referenced object. See `TProcessID::GetObjectWithID` and; `PutObjectWithID`. #### Object Number. When an object is referenced, a unique identifier is computed and stored; in both the `fUniqueID` of the referenced and referencing object. This; `uniqueID` is computed by incrementing by one the static global in; `TProcessID::fgNumber`. The `fUniqueID` is the serial object number in; the current session. One can retrieve the current `fgNumber` value by; calling the static function `TProcessID::GetObjectCount` at any time or; can set this number by **`TProcessID::SetObjectCount`**. To avoid a; growing table of `fObjects` in `TProcessID`, in case, for example, one; processes many events in a loop, it might be necessary to reset the; object number at the end of processing of one event. See an example in; `$ROOTSYS/test/Event.cxx` (look at function `Build`). The value of; `ObjectNumber `may be saved at the beginning of one event and reset to; this original value at the end of the event. These actions may be; nested. ``` {.cpp}; saveNumber = TProcessID::GetObjectCount();; ...; TProcessID::SetObjectCount(savedNumber);; ```. ### Action on Demand. The normal behavior of a **`TRef`** has been described above. In; addition, **`TRef`** supports ""Actions on Demand"". It may happen that; the referenced object is not yet in the memory, on a separate file or; not yet computed. In this case, **`TRef`** is able to execute; automatically an action:. - Call to a compiled function (static function of member function). - Call to an interpreted function. - Execution of a Cling script. #### How to Select This Option?. In the definition of the **`TRef`** data member in the original class,; do:. ``` {.cpp}; TRef fRef; //EXEC:execName points to something; ```. When the special keyword `""EXEC:""` is found in the",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:65713,Testability,test,test,65713," with:. ``` {.cpp}; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; ```. The parameter `actionCommand` is a string containing a Cling instruction.; Examples:. ``` {.cpp}; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; ```. When a `TRef` is de-referenced via **`TRef::GetObject`, its; **`TExec`** is automatically executed. The **`TExec`** function/script; can do one or more of the following:**. - Load a file containing the referenced object. This function; typically looks in the file catalog. - Compute a pointer to the referenced object and communicate this; pointer back to the calling function **`TRef`**`::SetObject` via:. ``` {.cpp}; TRef::SetObject(object); ```. As soon as an object is returned to `GetObject`, the `fUniqueID` of the; **`TRef`** is set to the `fUniqueID` of the referenced object. At the; next call to `GetObject`, the pointer stored in; `fPid:fObjects[fUniqueID]` will be returned directly. An example of; action on demand is in `$ROOTSYS/test/Event.h`:. ``` {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram; ```. When calling `fWebHistogram.GetObject()`, the function `GetObject` will; automatically invoke the script `GetWebHistogram.C` via the interpreter.; An example of a `GetWebHistogram.C` script is shown below:. ``` {.cpp}; void GetWebHistogram() {; TFile *f=TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetObject(h6);; }; ```. In the above example, a call to `fWebHistogram.GetObject()` executes the; script with the function `GetWebHistogram`. This script connects a file; with histograms: `pippa.root` on the ROOT Web site and returns the; object `h6` to **`TRef`**`::GetObject`. ``` {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram(); ```. Note that if the definition of the `TRef fWebHistogram` had been changed; the compiled or interpreted function `GetWebHistogram()` would have been; called ins",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:83334,Testability,test,test,83334,"ared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution. If you have written your own `Streamer` as described in the section; ""Streamers with Special Additions"", you will have to manually add code; for each version and manage the evolution of your class. When you add or; remove data members, you must modify the `Streamer` by hand. ROOT; assumes that you have increased the class version number in the; `ClassDef` statement and introduced the relevant test in the read part; of the Streamer. For example, if a new version of the `Event` class; above includes a new member: `Int_t fNew` the `ClassDef` statement; should be changed to `ClassDef(Event,2)` and the following lines should; be added to the read part of the `Streamer`:. ``` {.cpp}; if (R__v > 1) R__b >> fNew;; else fNew = 0; // set to some default value; ```. If, in the same new version 2 you remove the member `fH`, you must add; the following code to read the histogram object into some temporary; object and delete it:. ``` {.cpp}; if (R__v) < 2 {; TH1F *dummy = 0;; R__b >> dummy;; delete dummy;; }; ```. Our experience with manual schema evolution shows that it is easy to; make and mismatches between `Streamer` writers and readers are frequent; and increase as the number of classes increase. We recommend you use; `rootcling` generated `Streamers` whenever you can, and profit from the; automatic schema evolution. ### Building Class Defini",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:94901,Testability,log,login,94901,"ten objects. Consequently, a ROOT; file may contain objects with different compression levels. This table; shows four runs of the demo script that creates 15 histograms with; different compression parameters. To make the numbers more significant,; the macro was modified to create 1000 histograms. We have included two; more examples to show the impact of compression on Trees in the next; chapter. ### Using the General Open Function of TFile. To make life simple we provide a general function to open any type of; file (except shared memory files of class **`TMapFile`**). This; functionality is provided by the static `TFile::Open()` function:. ``` {.cpp}; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98721,Testability,test,test,98721," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:11107,Usability,simpl,simply,11107,"+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 number bins(1D),cells(2D)+U/Overflows; TAxis fXaxis offset=0 type=61 X axis descriptor; T",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41931,Usability,simpl,simple,41931," next are some; rules to remember:. - `name` = \* means all, but don't remove the subdirectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the p",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41972,Usability,simpl,simple,41972,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:42047,Usability,simpl,simple,42047," means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; s",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43196,Usability,simpl,simple,43196,"; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits f",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43289,Usability,simpl,simple,43289,"s, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44250,Usability,simpl,simple,44250,"fer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. When writing an `Event` object, `TC",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:46743,Usability,simpl,simple,46743,". It tells ROOT not to; save that data member in a root file when saving the class. For example,; in this version of Event, the `fPt` and `fTransient` data members are; not persistent. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; ```. ### The Pointer to Objects (//-\>). The string ""`->`"" in the comment field of the members `*fH` and; `*fTracks` instruct the automatic `Streamer` to assume these will point; to valid objects and the `Streamer `of the objects can be called rather; than the more expensive `R__b << fH`. It is important to note that no; check is done on the validity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47394,Usability,simpl,simple,47394,"lidity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min`",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:51280,Usability,simpl,simply,51280," globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ class EventHeader+;; ```. The ""`+`"" sign tells `rootcling` to use the new `Streamer `system; introduced in ROOT 3.0. The following is an example of a customized; `Streamer `for `Event`. The `Streamer` takes a **`TBuffer`** as a; parameter, and first checks to see if this is a case of reading or; writing the buffer. ``` {.cpp}; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; fTransient = gDirectory; //save current directory; fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. ### Writing Objects. The `Streamer` decomposes the objects into data members and writes them; to a buffer. It does not write the buffer to a file, it simply populates; a buffer with bytes representing the object. This allows us to write the; buffer to a file or do anything else we could do with the buffer. For; example, we can write it to a socket to send it over the network. This; is beyond the scope of this chapter, but it is worthwhile to emphasize; the need and advantage of separating the creation of the buffer from its; use. Let us look how a buffer is written to a file. The dictionary for a; class needs to be loaded before any object of that type can be saved. The `TObject::Write` method does the following:. - Creates a **`TKey`** object in the current directory. - Creates a **`TBuffer`** object which is part of the newly created; **`TKey`**. - Fills the **`TBuffer`** with a call to the `class::Streamer` method. - Creates a second buffer for compression, if needed. - Reserves space by scanning the **`TFree`** list. At this point, the; size of the buffer is known. - Writes the buffer to the file. - Releases the **`TBuffer`** part of the",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:69697,Usability,simpl,simple,69697," class definition is lost, or unavailable. - The current version of a shared library and an old file with old; class versions (backward compatibility). This is often the case when; reading old data. - Reading a file with a shared library built with `MakeProject`. This; is the case when someone has already read the data without a shared; library and has used ROOT `MakeProject` feature to reconstruct the; class definitions and shared library (`MakeProject` is explained in; detail later on). In case of a mismatch between the in-memory version and the persistent; version of a class, ROOT maps the persistent one to the one in memory.; This allows you to change the class definition at will, for example:. - Change the order of data members in the class. - Add new data members. By default, the value of the missing member; will be 0 or in case of an object it will be set to null. - Remove data members. - Move a data member to a base class or vice-versa. - Change the type of a member if it is a simple type or a pointer to a; simple type. If a loss of precision occurs, a warning is given. - Add or remove a base class. ![The schema evolution for objects written on disk and in memory](pictures/020000EE.jpg). ROOT supports schema evolution by keeping a class description of each; version of the class that was ever written to disk, with the class. When; it writes an object to file, it also writes the description of the; current class version along with it. This description is implemented in; the `StreamerInfo `class. ### The TStreamerInfo Class. Each class has a list of `StreamerInfo` objects, one for each version of; the class if that version was written to disk at least once. When; reading an object from a file, the system uses the `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:69728,Usability,simpl,simple,69728," class definition is lost, or unavailable. - The current version of a shared library and an old file with old; class versions (backward compatibility). This is often the case when; reading old data. - Reading a file with a shared library built with `MakeProject`. This; is the case when someone has already read the data without a shared; library and has used ROOT `MakeProject` feature to reconstruct the; class definitions and shared library (`MakeProject` is explained in; detail later on). In case of a mismatch between the in-memory version and the persistent; version of a class, ROOT maps the persistent one to the one in memory.; This allows you to change the class definition at will, for example:. - Change the order of data members in the class. - Add new data members. By default, the value of the missing member; will be 0 or in case of an object it will be set to null. - Remove data members. - Move a data member to a base class or vice-versa. - Change the type of a member if it is a simple type or a pointer to a; simple type. If a loss of precision occurs, a warning is given. - Add or remove a base class. ![The schema evolution for objects written on disk and in memory](pictures/020000EE.jpg). ROOT supports schema evolution by keeping a class description of each; version of the class that was ever written to disk, with the class. When; it writes an object to file, it also writes the description of the; current class version along with it. This description is implemented in; the `StreamerInfo `class. ### The TStreamerInfo Class. Each class has a list of `StreamerInfo` objects, one for each version of; the class if that version was written to disk at least once. When; reading an object from a file, the system uses the `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:71019,Usability,simpl,simple,71019," written to disk, with the class. When; it writes an object to file, it also writes the description of the; current class version along with it. This description is implemented in; the `StreamerInfo `class. ### The TStreamerInfo Class. Each class has a list of `StreamerInfo` objects, one for each version of; the class if that version was written to disk at least once. When; reading an object from a file, the system uses the `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a data member (i.e. make it not persistent), add; a ""`!`"" after the comment marks. For example the pointer \*`fPainter` of; a **`TH1`** is not persistent:. ``` {.cpp}; TVirtualHistPainter* fPainter //!pointer to histogram painter; ```. ### The TStreamerElement Class. A **`TStreamerElement`** describes a data member of a simple type,; object, array, pointer, or container. The offset in the; **`TStreamerElement`** is the starting address of the data for that data; member. ``` {.cpp}; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; ```. In this example, the **`TNamed`** data starts at byte 0, and; **`TAttLine`** starts at byte 28. The offset is machine and compiler; dependent and is computed when the `StreamerInfo` is analyzed. The types; are defined in the file `TStreamerInfo.h` and listed here:. ``` {.cpp}; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; ```. The method `TClass::GetStreamerInfo` analyzes th",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:74969,Usability,simpl,simple,74969,"pe= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<V",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:75581,Usability,simpl,simple,75581,"081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<VersionNumber>); ```. The version number identifies this particular version of the class. When; a class has version 0 it is not stored in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:94325,Usability,simpl,simple,94325,"-------+; | 5 | 429,871 | 7.03 | 0.06 |; +---------------------+------------------+-------------------+-------------------+; | 9 | 426,899 | 8.47 | 0.05 |; +---------------------+------------------+-------------------+-------------------+. The time to uncompress an object is small compared to the compression; time and is independent of the selected compression level. Note that the; compression level may be changed at any time, but the new compression; level will only apply to newly written objects. Consequently, a ROOT; file may contain objects with different compression levels. This table; shows four runs of the demo script that creates 15 histograms with; different compression parameters. To make the numbers more significant,; the macro was modified to create 1000 histograms. We have included two; more examples to show the impact of compression on Trees in the next; chapter. ### Using the General Open Function of TFile. To make life simple we provide a general function to open any type of; file (except shared memory files of class **`TMapFile`**). This; functionality is provided by the static `TFile::Open()` function:. ``` {.cpp}; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:97532,Usability,simpl,simple,97532,"ver.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in th",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98267,Usability,simpl,simply,98267," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,documentation/users-guide/InputOutput.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:85,Availability,avail,available,85,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:321,Availability,down,download,321,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:761,Availability,avail,available,761,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:776,Availability,down,download,776,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:1596,Availability,avail,available,1596," early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Introduction chapter for an; explanation of the directory structure. ## Installing from the Source. The ROOT's source code sits in the GitHub repository <https://github.com/root-project/root>; all the details and options to buld ROOT from sources are given in; <https://root.cern/building-root>. In short, the steps to build ROOT from the sources are the following:. 1. Clone the repository:; ``` {.cpp}; $ git clone https://github.com/root-project/root.git; ```. 2. Make a directory for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4.",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:1610,Availability,down,downloading,1610," early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Introduction chapter for an; explanation of the directory structure. ## Installing from the Source. The ROOT's source code sits in the GitHub repository <https://github.com/root-project/root>; all the details and options to buld ROOT from sources are given in; <https://root.cern/building-root>. In short, the steps to build ROOT from the sources are the following:. 1. Clone the repository:; ``` {.cpp}; $ git clone https://github.com/root-project/root.git; ```. 2. Make a directory for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4.",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:1663,Availability,down,downloaded,1663,"uires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Introduction chapter for an; explanation of the directory structure. ## Installing from the Source. The ROOT's source code sits in the GitHub repository <https://github.com/root-project/root>; all the details and options to buld ROOT from sources are given in; <https://root.cern/building-root>. In short, the steps to build ROOT from the sources are the following:. 1. Clone the repository:; ``` {.cpp}; $ git clone https://github.com/root-project/root.git; ```. 2. Make a directory for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4. Setup and run ROOT; ``` {.cpp}; $ source bin/thisroot.sh; $ root; ```. ###",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:1740,Availability,down,downloaded,1740,"ersions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Introduction chapter for an; explanation of the directory structure. ## Installing from the Source. The ROOT's source code sits in the GitHub repository <https://github.com/root-project/root>; all the details and options to buld ROOT from sources are given in; <https://root.cern/building-root>. In short, the steps to build ROOT from the sources are the following:. 1. Clone the repository:; ``` {.cpp}; $ git clone https://github.com/root-project/root.git; ```. 2. Make a directory for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4. Setup and run ROOT; ``` {.cpp}; $ source bin/thisroot.sh; $ root; ```. #### Staying up-to-date. To keep your local ROOT sourc",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:45,Deployability,install,install,45,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:212,Deployability,install,install,212,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:289,Deployability,install,install,289,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:603,Deployability,release,release,603,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:621,Deployability,release,release,621,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:869,Deployability,release,releases,869,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:1647,Deployability,install,install,1647,"ery large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Introduction chapter for an; explanation of the directory structure. ## Installing from the Source. The ROOT's source code sits in the GitHub repository <https://github.com/root-project/root>; all the details and options to buld ROOT from sources are given in; <https://root.cern/building-root>. In short, the steps to build ROOT from the sources are the following:. 1. Clone the repository:; ``` {.cpp}; $ git clone https://github.com/root-project/root.git; ```. 2. Make a directory for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4. Setup and run ROOT; ``` {.cpp}; $ sourc",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9652,Deployability,update,updated,9652,"nd header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular backg",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:5318,Energy Efficiency,power,power,5318,"he specified path:. ``` {.cpp}; Root.ShowPath: false; ```. Activate memory statistics. ``` {.cpp}; Root.ObjectStat: 0; ```. Global debug mode. When `>0` turns on progressively more details; debugging. ``` {.cpp}; Root.Debug: 0; Root.Stacktrace: yes; ```. Settings for X11 behaviour. ``` {.cpp}; X11.Sync: no; X11.FindBestVisual: yes; ```. Default editor in use. ``` {.cpp}; Unix.*.Editor: vi; WinNT.*.Editor: notepad; ```. Default 3d Viewer. By default 3-D views are shown in the pad, if the; next line is activated, the default viewer will be OpenGL. ``` {.cpp}; Viewer3D.DefaultDrawOption: ogl; ```. Default Fitter (current choices are `Minuit`, `Minuit2`, `Fumili` and; `Fumili2`). ``` {.cpp}; Root.Fitter: Minuit; ```. Specify list of file endings which **`TTabCom`** (TAB completion) should; ignore. ``` {.cpp}; TabCom.FileIgnore: .cpp:.h:.cmz; ```. ### TCanvas Specific Settings. Opaque move and resize show full pad during the operation instead of; only the outline. Especially for resize you will need serious CPU power.; `UseScreenFactor=true` means to size canvas according to size of screen,; so a canvas still looks good on a low resolution laptop screen without; having to change canvas size in macros. ``` {.cpp}; Canvas.MoveOpaque: false; Canvas.ResizeOpaque: false; Canvas.UseScreenFactor: true; ```. Hight color 2 is the red one. ``` {.cpp}; Canvas.HighLightColor: 2; ```. Next three settings are related to different user interface parts of; canvas window. If they are set to true, the corresponding event status; bar, tool bar, graphics editor will be activated by default. ``` {.cpp}; Canvas.ShowEventStatus: false; Canvas.ShowToolBar: false; Canvas.ShowEditor: false; ```. AutoExec allows **`TExec`** objects to be executed on mouse and key; events. ``` {.cpp}; Canvas.AutoExec: true; ```. Canvas print directory is set to the current one by default:. ``` {.cpp}; Canvas.PrintDirectory .; ```. Printer settings:. ``` {.cpp}; WinNT.*.Print.Command: AcroRd32.exe; #Unix.*.Print.Comm",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:500,Integrability,depend,depending,500,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:5736,Integrability,interface,interface,5736,"3d Viewer. By default 3-D views are shown in the pad, if the; next line is activated, the default viewer will be OpenGL. ``` {.cpp}; Viewer3D.DefaultDrawOption: ogl; ```. Default Fitter (current choices are `Minuit`, `Minuit2`, `Fumili` and; `Fumili2`). ``` {.cpp}; Root.Fitter: Minuit; ```. Specify list of file endings which **`TTabCom`** (TAB completion) should; ignore. ``` {.cpp}; TabCom.FileIgnore: .cpp:.h:.cmz; ```. ### TCanvas Specific Settings. Opaque move and resize show full pad during the operation instead of; only the outline. Especially for resize you will need serious CPU power.; `UseScreenFactor=true` means to size canvas according to size of screen,; so a canvas still looks good on a low resolution laptop screen without; having to change canvas size in macros. ``` {.cpp}; Canvas.MoveOpaque: false; Canvas.ResizeOpaque: false; Canvas.UseScreenFactor: true; ```. Hight color 2 is the red one. ``` {.cpp}; Canvas.HighLightColor: 2; ```. Next three settings are related to different user interface parts of; canvas window. If they are set to true, the corresponding event status; bar, tool bar, graphics editor will be activated by default. ``` {.cpp}; Canvas.ShowEventStatus: false; Canvas.ShowToolBar: false; Canvas.ShowEditor: false; ```. AutoExec allows **`TExec`** objects to be executed on mouse and key; events. ``` {.cpp}; Canvas.AutoExec: true; ```. Canvas print directory is set to the current one by default:. ``` {.cpp}; Canvas.PrintDirectory .; ```. Printer settings:. ``` {.cpp}; WinNT.*.Print.Command: AcroRd32.exe; #Unix.*.Print.Command: a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; ```. Default histogram binnings used by `TTree::Draw()` method. ``` {.cpp}; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:10006,Integrability,interface,interface,10006,"Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular background and foreground colors in use:. ``` {.cpp}; Gui.BackgroundColor: #c0c0c0; Gui.ForegroundColor: black; ```. Selection background and foreground colors in use:. ``` {.cpp}; Gui.SelectBackgroundColor: #000080; Gui.SelectForegroundColor: white; ```. Document background and foreground colors in use:. ``` {.cpp}; Gui.DocumentBackgroundColor: white; Gui.DocumentF",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:14680,Integrability,protocol,protocol,14680,"he master to enable the parallel startup of workers using threads; set next to ""`yes`"" (default is ""`no`""):. ``` {.cpp}; Proof.ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:826,Modifiability,evolve,evolves,826,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:12660,Modifiability,variab,variable,12660,"ied on the browser objects - can be `name`,; `type`, `size`, `date`:. ``` {.cpp}; Browser.SortBy: name; ```. Number of items in a group view:. ``` {.cpp}; Browser.GroupView: 10000; ```. Show or not hidden items:. ``` {.cpp}; Browser.ShowHidden: no; ```. Create a thumbnail view after executing the macro (default is `yes`). ``` {.cpp}; Browser.AutoThumbnail: yes; ```. ### TRint Specific Settings. Rint (interactive ROOT executable) specific alias, logon and logoff; macros. ``` {.cpp}; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ```. Record ROOT session commands in a given history file (default is; `$(HOME)/.root_hist`). If set to ""`-`"", it turn off the command; recording. ``` {.cpp}; Rint.History: $(HOME)/.root_hist; ```. Next two lines set the history file size handling. Once `HistSize` is; reached, the last `HistSave` entries are removed. If `HistSize` is set; to 0, it turns off command recording. Both values can be overridden by; environment variable `ROOT_HIST=size[:save]`, where the ""`:save`"" part; is optional. ``` {.cpp}; Rint.HistSize: 500; Rint.HistSave: 400; ```. ### ACLiC Specific Settings. `ACLiC.Linkdef` specifies the suffix that will be added to the script; name to try to locate a custom linkdef file when generating the; dictionary. ``` {.cpp}; ACLiC.Linkdef: _linkdef; ```. The top directory for storing the libraries produced by ACLiC is set by:. ``` {.cpp}; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; ```. The additional include directives for ACLiC compilations are set by:. ``` {.cpp}; ACLiC.IncludePaths: -I/where/the/includes/are; ```. ### PROOF Related Variables. PROOF debug options. ``` {.cpp}; Proof.DebugLevel: 0; Proof.DebugMask:-1; ```. PROOF GDB hooks allows a debugger to be attached early in the startup; phase of `proofserv: `0 - don't wait; 1 - master proofserv enters wait; loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters; wait loop. ``` {.cpp}; Proof.GdbHook: 0; ```. On the master t",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:3469,Performance,load,loader,3469,"y for building; ``` {.cpp}; $ mkdir build; $ cd build; ```. 3. Run cmake and make; ``` {.cpp}; $ cmake ../root; $ make -j8; ```. 4. Setup and run ROOT; ``` {.cpp}; $ source bin/thisroot.sh; $ root; ```. #### Staying up-to-date. To keep your local ROOT source up-to-date with the GitHub repository; you should regularly run the command:. ``` {.cpp}; % git pull; ```. ## File system.rootrc. ROOT Environment settings are handled via the class **`TEnv`**.; `gEnv->Print()`shows which values are active. Any settings can be; obtained by `TEnv::GetValue` methods that return an integer, double or; character value for a named resource. If the resource is not found, the; default value (given as the second parameter) is returned. ``` {.cpp}; fShowEventStatus = gEnv->GetValue(""Canvas.ShowEventStatus"",kFALSE);; ```. Via the method `TEnv::SetValue` allows you can set the value of a; resource or create a new resource:. ``` {.cpp}; gEnv->SetValue(""Root.ObjectStat"",1);; ```. Path used by dynamic loader to find shared libraries and macros. Paths; are different for Unix and Windows. The example shows the defaults for; all ROOT applications for either Unix or Windows:. ``` {.cpp}; Unix.*.Root.DynamicPath: .:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:$(ROOTSYS)/macros; WinNT.*.Root.DynamicPath: .;$(ROOTSYS)/bin;$(PATH); WinNT.*.Root.MacroPath: .;$(ROOTSYS)/macros; ```. Path where to look for `TrueType` fonts:. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; *.*.Root.TTFontPath: $(ROOTSYS)/fonts; ```. Use `Net* API` functions:. ``` {.cpp}; WinNT.UseNetAPI: true; ```. Use thread library (if exists). ``` {.cpp}; Unix.*.Root.UseThreads: false; ```. Select the compression algorithm (0=old zlib, 1=new zlib). Setting this; to \`0' may be a security vulnerability. ``` {.cpp}; Root.ZipMode: 1; ```. Show where item is found in the specified path:. ``` {.cpp}; Root.ShowPath: false; ```. Activate memory statistics. ``` {.cpp}; Root.ObjectStat: 0; ```. Global debug mode. When `>0` turns on progressively more det",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9384,Safety,detect,detecting,9384,"eople?`). ``` {.cpp}; Root.Html.XWho:; ```. If set to Doc++, allow method documentation in front of method even for; methods in the source file (default: `""""`). ``` {.cpp}; Root.Html.DescriptionStyle:; ```. Search path for the source and header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9524,Safety,detect,detecting,9524,"urce file (default: `""""`). ``` {.cpp}; Root.Html.DescriptionStyle:; ```. Search path for the source and header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9636,Safety,detect,detecting,9636,"nd header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular backg",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9840,Safety,detect,detecting,9840,"; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular background and foreground colors in use:. ``` {.cpp}; Gui.BackgroundColor: #c0c0c0; Gui.ForegroundColor: black; ```. Selection background and foreground colors in use:. ``` {.cpp}; Gui.SelectBackgroundColor: #000080; Gui.S",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15171,Safety,timeout,timeout,15171,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:895,Security,access,access,895,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:4209,Security,secur,security,4209,"``` {.cpp}; fShowEventStatus = gEnv->GetValue(""Canvas.ShowEventStatus"",kFALSE);; ```. Via the method `TEnv::SetValue` allows you can set the value of a; resource or create a new resource:. ``` {.cpp}; gEnv->SetValue(""Root.ObjectStat"",1);; ```. Path used by dynamic loader to find shared libraries and macros. Paths; are different for Unix and Windows. The example shows the defaults for; all ROOT applications for either Unix or Windows:. ``` {.cpp}; Unix.*.Root.DynamicPath: .:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:$(ROOTSYS)/macros; WinNT.*.Root.DynamicPath: .;$(ROOTSYS)/bin;$(PATH); WinNT.*.Root.MacroPath: .;$(ROOTSYS)/macros; ```. Path where to look for `TrueType` fonts:. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; *.*.Root.TTFontPath: $(ROOTSYS)/fonts; ```. Use `Net* API` functions:. ``` {.cpp}; WinNT.UseNetAPI: true; ```. Use thread library (if exists). ``` {.cpp}; Unix.*.Root.UseThreads: false; ```. Select the compression algorithm (0=old zlib, 1=new zlib). Setting this; to \`0' may be a security vulnerability. ``` {.cpp}; Root.ZipMode: 1; ```. Show where item is found in the specified path:. ``` {.cpp}; Root.ShowPath: false; ```. Activate memory statistics. ``` {.cpp}; Root.ObjectStat: 0; ```. Global debug mode. When `>0` turns on progressively more details; debugging. ``` {.cpp}; Root.Debug: 0; Root.Stacktrace: yes; ```. Settings for X11 behaviour. ``` {.cpp}; X11.Sync: no; X11.FindBestVisual: yes; ```. Default editor in use. ``` {.cpp}; Unix.*.Editor: vi; WinNT.*.Editor: notepad; ```. Default 3d Viewer. By default 3-D views are shown in the pad, if the; next line is activated, the default viewer will be OpenGL. ``` {.cpp}; Viewer3D.DefaultDrawOption: ogl; ```. Default Fitter (current choices are `Minuit`, `Minuit2`, `Fumili` and; `Fumili2`). ``` {.cpp}; Root.Fitter: Minuit; ```. Specify list of file endings which **`TTabCom`** (TAB completion) should; ignore. ``` {.cpp}; TabCom.FileIgnore: .cpp:.h:.cmz; ```. ### TCanvas Specific Settings. Opaque move and resize ",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:14185,Security,access,access,14185,"clude directives for ACLiC compilations are set by:. ``` {.cpp}; ACLiC.IncludePaths: -I/where/the/includes/are; ```. ### PROOF Related Variables. PROOF debug options. ``` {.cpp}; Proof.DebugLevel: 0; Proof.DebugMask:-1; ```. PROOF GDB hooks allows a debugger to be attached early in the startup; phase of `proofserv: `0 - don't wait; 1 - master proofserv enters wait; loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters; wait loop. ``` {.cpp}; Proof.GdbHook: 0; ```. On the master to enable the parallel startup of workers using threads; set next to ""`yes`"" (default is ""`no`""):. ``` {.cpp}; Proof.ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read tim",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:12121,Testability,log,logon,12121,"oltipBackgroundColor: LightYellow; Gui.TooltipForegroundColor: black; ```. Path where all GUI icons in use can be found:. ``` {.cpp}; Gui.IconPath: $(HOME)/icons:$(ROOTSYS)/icons:.; ```. Mime type file setting:. ``` {.cpp}; Gui.MimeTypeFile: $(HOME)/.root.mimes; ```. If `$(HOME)/.root.mimes` does not exists, defaults to this:. ``` {.cpp}; #Gui.MimeTypeFile: $(ROOTSYS)/etc/root.mimes; ```. ### TBrowser Settings. Current icon style selection - can be either `small`, `big`, `list`,; `details`:. ``` {.cpp}; Browser.IconStyle: small; ```. Current sorting rule applied on the browser objects - can be `name`,; `type`, `size`, `date`:. ``` {.cpp}; Browser.SortBy: name; ```. Number of items in a group view:. ``` {.cpp}; Browser.GroupView: 10000; ```. Show or not hidden items:. ``` {.cpp}; Browser.ShowHidden: no; ```. Create a thumbnail view after executing the macro (default is `yes`). ``` {.cpp}; Browser.AutoThumbnail: yes; ```. ### TRint Specific Settings. Rint (interactive ROOT executable) specific alias, logon and logoff; macros. ``` {.cpp}; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ```. Record ROOT session commands in a given history file (default is; `$(HOME)/.root_hist`). If set to ""`-`"", it turn off the command; recording. ``` {.cpp}; Rint.History: $(HOME)/.root_hist; ```. Next two lines set the history file size handling. Once `HistSize` is; reached, the last `HistSave` entries are removed. If `HistSize` is set; to 0, it turns off command recording. Both values can be overridden by; environment variable `ROOT_HIST=size[:save]`, where the ""`:save`"" part; is optional. ``` {.cpp}; Rint.HistSize: 500; Rint.HistSave: 400; ```. ### ACLiC Specific Settings. `ACLiC.Linkdef` specifies the suffix that will be added to the script; name to try to locate a custom linkdef file when generating the; dictionary. ``` {.cpp}; ACLiC.Linkdef: _linkdef; ```. The top directory for storing the libraries produced by ACLiC is set by:. ``` {.cpp}; ACLiC.BuildDi",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:12131,Testability,log,logoff,12131,"oltipBackgroundColor: LightYellow; Gui.TooltipForegroundColor: black; ```. Path where all GUI icons in use can be found:. ``` {.cpp}; Gui.IconPath: $(HOME)/icons:$(ROOTSYS)/icons:.; ```. Mime type file setting:. ``` {.cpp}; Gui.MimeTypeFile: $(HOME)/.root.mimes; ```. If `$(HOME)/.root.mimes` does not exists, defaults to this:. ``` {.cpp}; #Gui.MimeTypeFile: $(ROOTSYS)/etc/root.mimes; ```. ### TBrowser Settings. Current icon style selection - can be either `small`, `big`, `list`,; `details`:. ``` {.cpp}; Browser.IconStyle: small; ```. Current sorting rule applied on the browser objects - can be `name`,; `type`, `size`, `date`:. ``` {.cpp}; Browser.SortBy: name; ```. Number of items in a group view:. ``` {.cpp}; Browser.GroupView: 10000; ```. Show or not hidden items:. ``` {.cpp}; Browser.ShowHidden: no; ```. Create a thumbnail view after executing the macro (default is `yes`). ``` {.cpp}; Browser.AutoThumbnail: yes; ```. ### TRint Specific Settings. Rint (interactive ROOT executable) specific alias, logon and logoff; macros. ``` {.cpp}; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ```. Record ROOT session commands in a given history file (default is; `$(HOME)/.root_hist`). If set to ""`-`"", it turn off the command; recording. ``` {.cpp}; Rint.History: $(HOME)/.root_hist; ```. Next two lines set the history file size handling. Once `HistSize` is; reached, the last `HistSave` entries are removed. If `HistSize` is set; to 0, it turns off command recording. Both values can be overridden by; environment variable `ROOT_HIST=size[:save]`, where the ""`:save`"" part; is optional. ``` {.cpp}; Rint.HistSize: 500; Rint.HistSave: 400; ```. ### ACLiC Specific Settings. `ACLiC.Linkdef` specifies the suffix that will be added to the script; name to try to locate a custom linkdef file when generating the; dictionary. ``` {.cpp}; ACLiC.Linkdef: _linkdef; ```. The top directory for storing the libraries produced by ACLiC is set by:. ``` {.cpp}; ACLiC.BuildDi",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:7311,Usability,guid,guide,7311,"ns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; ```. Default histogram binnings used by `TTree::Draw()` method. ``` {.cpp}; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. Default statistics names used for parameters in **`TPaveStats`**:. ``` {.cpp}; Hist.Stats.Entries Entries; Hist.Stats.Mean Mean; Hist.Stats.MeanX Mean x; Hist.Stats.MeanY Mean y; Hist.Stats.RMS RMS; Hist.Stats.RMSX RMS x; Hist.Stats.RMSY RMS y; Hist.Stats.Underflow Underflow; Hist.Stats.Overflow Overflow; Hist.Stats.Integral Integral; Hist.Stats.Skewness Skewness; Hist.Stats.SkewnessX Skewness x; Hist.Stats.SkewnessY Skewness y; Hist.Stats.Kurtosis Kurtosis; Hist.Stats.KurtosisX Kurtosis x; Hist.Stats.KurtosisY Kurtosis y; ```. ### THtml Specific Settings. See the reference guide documentation of **`THtml`** class at; <https://root.cern/doc/master/classTHtml.html> for more details. XHTML content charset (see; <http://www.w3.org/TR/2002/REC-xhtml1-20020801>, default: ISO-8859-1) is; set by:. ``` {.cpp}; Root.Html.Charset:; ```. Stem of a search engine for the documentation, where `%s` is replaced by; the term entered in the search text box (example:; `http://www.google.com/search?q=%s+site%3Aroot.cern.ch%2Froot%2Fhtml`,; default is `""""`). ``` {.cpp}; Root.Html.Search:; ```. Link to the site's search engine (default: `""""`, example:; `http://root.cern.ch/root/Search.phtml`). ``` {.cpp}; Root.Html.SearchEngine:; ```. String to prepend to `TClass::GetImplFileName()` names containing; directories when looking for source files (default: `""""`, `e`xample:; `../root`). ``` {.cpp}; Root.Html.SourcePrefix:; ```. Link stem to `ViewCVS` entry for classes, where a class name is assumed; to match a file name (default: `""""`, example:; `http://root.cern.ch/viewcvs`). ``` {.cpp}; Root.Html.Vie",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15679,Usability,guid,guides,15679,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15692,Usability,guid,guide,15692,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,documentation/users-guide/InstallandBuild.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7395,Availability,reliab,reliable,7395,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7408,Availability,robust,robust,7408,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8834,Availability,down,download,8834,"main. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GN",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9187,Availability,down,download,9187,"inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9295,Availability,down,downloading,9295,"ble mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10953,Availability,echo,echo,10953,"RC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+---------",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:11095,Availability,down,download,11095,"q Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13182,Availability,avail,available,13182,"d system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depe",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20184,Availability,avail,available,20184," thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20472,Availability,error,error,20472,"`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to create Graphical User Interface `hist`: Histogramming; `image`: Image Process",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:23491,Availability,avail,available,23491,"irectory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:23506,Availability,down,downloading,23506,"irectory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:23538,Availability,down,downloading,23538,"### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; I",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24803,Availability,avail,available,24803,"ysics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the current pages. ![](pictures/03000006.png). ![Example of function documentation, with automatically generated LaTeX-like graphics](pictures/03000007.png). ![Inheritance tre",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1336,Deployability,continuous,continuous,1336,"e Large Hadron Collider, where the data is; a few orders of magnitude larger than anything seen before. At the same time, computer science had made leaps of progress; especially in the area of Object Oriented Design, and René and Fons; were ready to take advantage of it. ROOT was developed in the context of the NA49 experiment at CERN. NA49; has generated an impressive amount of data, around 10 Terabytes per; run. This rate provided the ideal environment to develop and test the; next generation data analysis. ROOT was, and still is, developed in the ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT for",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1891,Deployability,release,released,1891,"he ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several authors wrote this book and you may see a ""change of voice""; from one chapter to the next. We felt we could accept this in order to; have the expert explain what they know best. If you would like to; contribute a chapter or add to ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5761,Deployability,patch,patch,5761,"rst, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7487,Deployability,integrat,integrated,7487,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8779,Deployability,install,install,8779,"ise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8797,Deployability,install,install,8797,"main. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GN",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9092,Deployability,install,installation,9092,"abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SG",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9505,Deployability,install,installed,9505," contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework i",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9545,Deployability,install,install,9545,"er than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical dire",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10586,Deployability,install,installation,10586,"h cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash sc",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10672,Deployability,install,installed,10672,"ms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13309,Deployability,install,installed,13309,"or projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 syst",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22744,Deployability,release,release,22744,"trix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22829,Deployability,release,release,22829,"trix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24396,Deployability,release,release,24396,"y contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1296,Energy Efficiency,power,powerful,1296,"W the twenty-year-old FORTRAN libraries had reached their; limits. Although still very popular, these tools could not scale up to; the challenges offered by the Large Hadron Collider, where the data is; a few orders of magnitude larger than anything seen before. At the same time, computer science had made leaps of progress; especially in the area of Object Oriented Design, and René and Fons; were ready to take advantage of it. ROOT was developed in the context of the NA49 experiment at CERN. NA49; has generated an impressive amount of data, around 10 Terabytes per; run. This rate provided the ideal environment to develop and test the; next generation data analysis. ROOT was, and still is, developed in the ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, an",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4643,Energy Efficiency,energy,energy,4643,"Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8434,Energy Efficiency,reduce,reduced,8434," the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed.",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18458,Energy Efficiency,green,green,18458,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5038,Integrability,interface,interfaces,5038," for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5157,Integrability,rout,routing,5157,"1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5618,Integrability,rout,route,5618,"lving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6436,Integrability,rout,routing,6436,"ework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6528,Integrability,interface,interfaces,6528,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7487,Integrability,integrat,integrated,7487,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7885,Integrability,interface,interfaces,7885,"rocessor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9054,Integrability,depend,depending,9054,"ers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ comp",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13522,Integrability,interface,interface,13522," (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML docum",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13590,Integrability,interface,interface,13590,"----------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13651,Integrability,interface,interface,13651,"OOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathem",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13914,Integrability,depend,depend,13914,"-------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extr",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14102,Integrability,depend,depend,14102,"prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProo",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14257,Integrability,interface,interface,14257,"t relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14382,Integrability,interface,interface,14382,"ipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the int",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14928,Integrability,interface,interface,14928,"s which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the g",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15080,Integrability,interface,interface,15080,"ves. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to mi",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15170,Integrability,interface,interface,15170,". - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than hav",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15212,Integrability,interface,interface,15212,"`libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The c",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15274,Integrability,interface,interface,15274," X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials;",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15392,Integrability,interface,interface,15392," HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container cla",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15593,Integrability,interface,interface,15593," `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15697,Integrability,interface,interface,15697,"al functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCl",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15928,Integrability,interface,interface,15928,"mory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15983,Integrability,depend,dependencies,15983,"s the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16074,Integrability,depend,dependencies,16074,"l ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16852,Integrability,depend,depends,16852,"` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16892,Integrability,depend,dependencies,16892," ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if t",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16934,Integrability,depend,depending,16934," ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if t",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18045,Integrability,depend,depends,18045,"a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager *",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18077,Integrability,depend,dependent,18077,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18146,Integrability,depend,dependency,18146,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19056,Integrability,depend,dependencies,19056," are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19367,Integrability,protocol,protocol,19367,". plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20122,Integrability,depend,depends,20122,"ry will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating min",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20343,Integrability,depend,depends,20343,"fio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4281,Modifiability,variab,variable,4281,". The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only inter",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4331,Modifiability,variab,variable,4331,"xity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4417,Modifiability,variab,variable,4417,"nd these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7431,Modifiability,inherit,inherited,7431,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8201,Modifiability,inherit,inheritance,8201,"d be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the sour",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8233,Modifiability,extend,extend,8233,"d be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the sour",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8332,Modifiability,flexible,flexible,8332," are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8603,Modifiability,variab,variables,8603," the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed.",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10863,Modifiability,variab,variable,10863,"(IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:12205,Modifiability,config,config,12205,"` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17355,Modifiability,config,config,17355,"o is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17416,Modifiability,config,config,17416,"o is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17494,Modifiability,config,config,17494,"ibrary (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager o",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18394,Modifiability,plugin,plugin,18394,"uned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin clas",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18510,Modifiability,plugin,plugin,18510,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18525,Modifiability,plugin,plugin,18525,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18634,Modifiability,plugin,plugin,18634,"will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains m",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18708,Modifiability,plugin,plugin,18708,"ve a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->Add",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18974,Modifiability,plugin,plugin,18974," are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19083,Modifiability,plugin,plugin,19083," are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19142,Modifiability,plugin,plugins,19142,"ference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19294,Modifiability,plugin,plugin,19294,"latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this informa",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19330,Modifiability,plugin,plugin,19330,"latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this informa",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19390,Modifiability,plugin,plugin,19390,". plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19648,Modifiability,plugin,plugin,19648," be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user w",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24634,Modifiability,inherit,inheritance,24634,"inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the cu",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:25904,Modifiability,inherit,inherit,25904,"uaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the current pages. ![](pictures/03000006.png). ![Example of function documentation, with automatically generated LaTeX-like graphics](pictures/03000007.png). ![Inheritance tree, showing what the current class derives from, and which classes inherit from it](pictures/03000008.png). ![HTML version of the source file linking all types and most functions](pictures/03000009.png); ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16107,Performance,load,load,16107,"l ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16173,Performance,load,load,16173,"l ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16802,Performance,load,load,16802,"oolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histog",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17923,Performance,load,loads,17923,"ifferent consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet lo",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18060,Performance,load,loaded,18060,"a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager *",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18309,Performance,load,loaded,18309,"n. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be im",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18495,Performance,load,loaded,18495,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18877,Performance,load,load,18877,"ist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18910,Performance,load,loaded,18910,"ist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19112,Performance,load,loaded,19112," are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19188,Performance,load,loaded,19188,"ference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19481,Performance,load,loaded,19481,"e of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) erro",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19843,Performance,load,load,19843," histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20218,Performance,load,load,20218," thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20363,Performance,load,load,20363,"col string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to cr",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20403,Performance,load,loading,20403,"`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to create Graphical User Interface `hist`: Histogramming; `image`: Image Process",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20464,Performance,load,loader,20464,"`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to create Graphical User Interface `hist`: Histogramming; `image`: Image Process",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1925,Security,expose,expose,1925,"he ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several authors wrote this book and you may see a ""change of voice""; from one chapter to the next. We felt we could accept this in order to; have the expert explain what they know best. If you would like to; contribute a chapter or add to ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:2624,Security,access,access,2624,"ring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several authors wrote this book and you may see a ""change of voice""; from one chapter to the next. We felt we could accept this in order to; have the expert explain what they know best. If you would like to; contribute a chapter or add to a section, please contact; <rootdoc@cern.ch>. We count on you to send us suggestions on; additional topics or on the topics that need more documentation.; Please send your comments, corrections, questions, and suggestions to; the `rootdoc` list: <rootdoc@cern.ch>. We attempt to give the user insight into the many capabilities of; ROOT. The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10793,Security,access,access,10793,"A64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.ex",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:12444,Security,authenticat,authenticate,12444,"` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:12715,Security,authenticat,authenticated,12715,"` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:12859,Security,access,access,12859,"` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17002,Security,access,access,17002," ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if t",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17893,Security,access,access,17893,"ifferent consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet lo",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18625,Security,access,access,18625,"will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains m",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22403,Security,access,access,22403,"ph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to create Graphical User Interface `hist`: Histogramming; `image`: Image Processing `io`: Input/Output `math`: Maths and; Statistics functions `matrix`: Matrices (**`TMatrix`**) examples; `mlp`: Neural networks with **`TMultiLayerPerceptron`** `net`: Network; classes (client/server examples) `physics`: LorentzVectors, phase; space `pyroot`: Python tutorials `pythia`: Example with `pythia8`; `quadp`: Quadratic Programming `smatrix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contai",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22466,Security,access,access,22466,"(**`TMatrix`**) examples; `mlp`: Neural networks with **`TMultiLayerPerceptron`** `net`: Network; classes (client/server examples) `physics`: LorentzVectors, phase; space `pyroot`: Python tutorials `pythia`: Example with `pythia8`; `quadp`: Quadratic Programming `smatrix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:864,Testability,test,test,864,"# Introduction. In the mid 1990's, René Brun and Fons Rademakers had many years of; experience developing interactive tools and simulation packages. They; had lead successful projects such as PAW, PIAF, and GEANT, and they; knew PAW the twenty-year-old FORTRAN libraries had reached their; limits. Although still very popular, these tools could not scale up to; the challenges offered by the Large Hadron Collider, where the data is; a few orders of magnitude larger than anything seen before. At the same time, computer science had made leaps of progress; especially in the area of Object Oriented Design, and René and Fons; were ready to take advantage of it. ROOT was developed in the context of the NA49 experiment at CERN. NA49; has generated an impressive amount of data, around 10 Terabytes per; run. This rate provided the ideal environment to develop and test the; next generation data analysis. ROOT was, and still is, developed in the ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1713,Testability,test,tested,1713,"ent at CERN. NA49; has generated an impressive amount of data, around 10 Terabytes per; run. This rate provided the ideal environment to develop and test the; next generation data analysis. ROOT was, and still is, developed in the ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several aut",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7476,Testability,test,tested,7476,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:11204,Testability,test,test,11204,"oft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+-------------------------------------------",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22629,Testability,test,test,22629,"rk; classes (client/server examples) `physics`: LorentzVectors, phase; space `pyroot`: Python tutorials `pythia`: Example with `pythia8`; `quadp`: Quadratic Programming `smatrix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the correspondi",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22639,Testability,test,test,22639,"ors, phase; space `pyroot`: Python tutorials `pythia`: Example with `pythia8`; `quadp`: Quadratic Programming `smatrix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src`",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22816,Testability,test,test,22816,"trix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22955,Testability,test,test,22955,"oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contains all header files. It is especially; important because the header files contain the class definitions. ### \$ROOTSYS/\<library\>. The directories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h,",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4086,Usability,simpl,simplicity,4086,"topics that need more documentation.; Please send your comments, corrections, questions, and suggestions to; the `rootdoc` list: <rootdoc@cern.ch>. We attempt to give the user insight into the many capabilities of; ROOT. The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; serv",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6508,Usability,learn,learn,6508,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6578,Usability,learn,learning,6578,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9856,Usability,UX,UX,9856,"s or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; env",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17216,Usability,guid,guide,17216,"ibCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17263,Usability,guid,guide,17263,"ibCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18130,Usability,guid,guide,18130,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18198,Usability,guid,guide,18198,"n. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be im",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24487,Usability,guid,guide,24487,"rectories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source informat",MatchSource.DOCS,documentation/users-guide/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:537,Availability,avail,available,537,"# Linear Algebra in ROOT. The linear algebra package is supposed to give a complete environment in; ROOT to perform calculations like equation solving and eigenvalue; decompositions. Most calculations are performed in double precision. For; backward compatibility, some classes are also provided in single; precision like **`TMatrixF`**, **`TMatrixFSym`** and **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; clas",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:971,Availability,mainten,maintenance,971,"# Linear Algebra in ROOT. The linear algebra package is supposed to give a complete environment in; ROOT to perform calculations like equation solving and eigenvalue; decompositions. Most calculations are performed in double precision. For; backward compatibility, some classes are also provided in single; precision like **`TMatrixF`**, **`TMatrixFSym`** and **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; clas",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1526,Availability,avail,available,1526,"ses, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the classes at the top, see ""Matrix; Eigen Analysis"". In both cases, only some matrix types can be analyzed.; For instance, **`TDecompChol`** will only accept symmetric mat",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:2183,Availability,avail,available,2183,"ifferent matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the classes at the top, see ""Matrix; Eigen Analysis"". In both cases, only some matrix types can be analyzed.; For instance, **`TDecompChol`** will only accept symmetric matrices as; defined **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**)",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:2683,Availability,error,error,2683,"rix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the classes at the top, see ""Matrix; Eigen Analysis"". In both cases, only some matrix types can be analyzed.; For instance, **`TDecompChol`** will only accept symmetric matrices as; defined **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**) or; sparse (**`TMatrixDSparse`**);. - `size` - number of rows and columns;. - `index` - range start of row and column index. By default these; start at zero;. - `sparse` `map` - this property is only relevant for a sparse matrix.; It indicates where elements are unequal zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+-------------------------------------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:4783,Availability,toler,tolerance,4783,"qual zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+----------------------------------------------+; | `Int_t GetNoElements` `()` | number of elements, for a dense matrix this |; | | equals: `fNrows x fNcols` |; +-----------------------------+----------------------------------------------+; | `Double_t GetTol` `()` | tolerance number which is used in |; | | decomposition operations |; +-----------------------------+----------------------------------------------+; | `Int_t *GetRowIndexArray` | for sparse matrices, access to the row index |; | `()` | of `fNrows+1` entries |; +-----------------------------+----------------------------------------------+; | `Int_t *GetColIndexArray` | for sparse matrices, access to the column |; | `()` | index of `fNelems` entries |; +-----------------------------+----------------------------------------------+. The last two methods in this table are specific to the sparse matrix,; which is implemented according to the Harwell-Boeing format. Here,",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:7386,Availability,toler,tolerance,7386," irow = 0; irow < a.getNrows(); irow++) {; const Int_t sIndex = rIndex[irow];; const Int_t eIndex = rIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = cIndex[index];; const Double_t data = pData[index];; printf(""data(%d,%d) = %.4en"",irow+a.GetfRowLwb(),; icol+a.GetColLwb(),data);; }; }; ```. ### Setting Properties. The following table shows the methods to set some of the matrix; properties. The resizing procedures will maintain the matrix elements; that overlap with the old shape. The optional last argument `nr_zeros`; is only relevant for sparse matrices. If supplied, it sets the number of; non-zero elements. If it is smaller than the number overlapping with the; old matrix, only the first (row-wise)` nr_zeros` are copied to the new; matrix. +-----------------------------------------+----------------------------------+; | Method | Descriptions |; +=========================================+==================================+; | `SetTol` `(Double_t tol)` | set the tolerance number |; +-----------------------------------------+----------------------------------+; | `ResizeTo` `(Int_t nrows,Int_t ncols,` | change matrix shape to `nrows` x |; | | `ncols`. Index will start at |; | ` Int_t nr_nonzeros=-1)` | zero |; +-----------------------------------------+----------------------------------+; | `ResizeTo(Int_t row_lwb,Int_t row_upb,` | change matrix shape to |; | | |; | `Int_t col_lwb,Int_t col_upb,` | `row_lwb:row_upb` x |; | | `col_lwb:col_upb` |; | `Int_t nr_nonzeros=-1)` | |; +-----------------------------------------+----------------------------------+; | `SetRowIndexArray` `(Int_t *data)` | for sparse matrices, set the row |; | | index. The array data should |; | | contains at least` fNrows+1` |; | | entries column lower-bound index |; +-----------------------------------------+----------------------------------+; | `SetColIndexArray` `(Int_t *data)` | for sparse matrices, set the |; | | column index. The array data |; | | sh",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:11826,Availability,avail,available,11826,"----------------------+; | `TMatrixDSparse(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb |; | )` |; | |; | `TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb, |; | ` |; | |; | ` Int_t nr_nonzeros,Int_t *row,Int_t *col,Double_t *data)` |; +--------------------------------------------------------------------------+. If only the matrix shape is defined in the constructor, matrix data has; to be supplied and possibly the sparse structure. In ""Setting; Properties"" was discussed how to set the sparse structure. Several methods exist to fill a matrix with data:. `SetMatrixArray(const Double_t*data,Option_t*option="""")`, copies the; array data. If option`=""F""`, the array fills the matrix column-wise else; row-wise. This option is only implemented for **`TMatrixD`** and; **`TMatrixDSym`**. It is expected that the array data contains at least; `fNelems` entries. `SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Double_t *data)`, is; only available for sparse matrices. The three arrays should each contain; `nr` entries with row index, column index and data entry. Only the; entries with non-zero data value are inserted!. `operator() `or `operator[]`, these operators provide the easiest way to; fill a matrix but are in particular for a sparse matrix expensive. If no; entry for slot (`i,j`) is found in the sparse index table it will be; entered, which involves some memory management! Therefore, before; invoking this method in a loop it is wise to set the index table first; through a call to the `SetSparseIndex` method. `SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixDBase &source)`, the; matrix to be inserted at position `(row_lwb,col_lwb)` can be both, dense; or sparse. `Use(...)` allows inserting another matrix or data array without; actually copying the data. Next table shows the different flavors for; the different matrix types. +------------------------------------------------------------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:19043,Availability,toler,tolerance,19043,"+--------------------------+-------------------+----------------+; | element wise subtraction | `C=r-A` | overwrites $A$ |; | | `C=A-r` | |; | | `A-=r` | |; +--------------------------+-------------------+----------------+; | matrix multiplication | `C=r*A` | overwrites $A$ |; | | `C=A*r` | |; | | `A*=r` | |; +--------------------------+-------------------+----------------+. ### Comparisons and Boolean Operations. The following table shows element wise comparisons between two matrices:. +------------------------------------------+----------+-----------------------------+; | Format | Output | Description |; +------------------------------------------+----------+-----------------------------+; | `A == B` | `Bool_t` | equal to |; +------------------------------------------+----------+-----------------------------+; | `A != B ` | matrix | Not equal |; | | | |; | `A > B ` | matrix | Greater than |; | | | |; | `A >= B ` | matrix | Greater than or equal to |; | | | |; | `A < B ` | matrix | Smaller than |; | | | |; | `A <= B` | matrix | Smaller than or equal to |; +------------------------------------------+----------+-----------------------------+; | `AreCompatible(A,B) ` | `Bool_t` | Compare matrix properties |; | | | |; | `Compare(A,B) ` | | return summary of |; | | | comparison |; | `VerifyMatrixIdentity(A,B,verb, maxDev)` | `Bool_t` | |; | | | Check matrix identity |; | | | within `maxDev` tolerance |; +------------------------------------------+----------+-----------------------------+. The following table shows element wise comparisons between matrix and real:. +---------------------------------------+----------+-----------------------------+; | Format | Output | Description |; +---------------------------------------+----------+-----------------------------+; | `A == r` | `Bool_t` | equal to |; | | | |; | A != r | `Bool_t` | Not equal |; | | | |; | A \> r | `Bool_t` | Greater than |; | | `Bool_t` | |; | A \>= r | | Greater than or equal to |; | | `Bool_t` | |; | A \",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:19907,Availability,toler,tolerance,19907,"`A < B ` | matrix | Smaller than |; | | | |; | `A <= B` | matrix | Smaller than or equal to |; +------------------------------------------+----------+-----------------------------+; | `AreCompatible(A,B) ` | `Bool_t` | Compare matrix properties |; | | | |; | `Compare(A,B) ` | | return summary of |; | | | comparison |; | `VerifyMatrixIdentity(A,B,verb, maxDev)` | `Bool_t` | |; | | | Check matrix identity |; | | | within `maxDev` tolerance |; +------------------------------------------+----------+-----------------------------+. The following table shows element wise comparisons between matrix and real:. +---------------------------------------+----------+-----------------------------+; | Format | Output | Description |; +---------------------------------------+----------+-----------------------------+; | `A == r` | `Bool_t` | equal to |; | | | |; | A != r | `Bool_t` | Not equal |; | | | |; | A \> r | `Bool_t` | Greater than |; | | `Bool_t` | |; | A \>= r | | Greater than or equal to |; | | `Bool_t` | |; | A \< r | `Bool_t` | Smaller than |; | | | |; | A \<= r | | Smaller than or equal to |; +---------------------------------------+----------+-----------------------------+; | `VerifyMatrixValue(A,r,verb, maxDev)` | `Bool_t` | Compare matrix value with r |; | | | within `maxDev` tolerance |; +---------------------------------------+----------+-----------------------------+. ### Matrix Norms. +----------------------+--------------+----------------------------------------+; | Format | Output | Description |; +----------------------+--------------+----------------------------------------+; | `A.RowNorm()` | `Double_t` | norm induced by the infinity vector |; | | | norm, max*i*$\sum_{i}|A_{ij}|$ |; | `A.NormInf()` | `Double_t` | |; | | | max*i*$\sum_{i}|A_{ij}|$ |; | `A.ColNorm()` | `Double_t` | |; | | | norm induced by the 1 vector norm, |; | `A.Norm1()` | `Double_t` | max*j*$\sum_{i}|A_{ij}|$ |; | | | |; | `A.E2Norm()` | `Double_t` | max*j*$\sum_{i}|A_{ij}|$ |; | | | |; |",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:26919,Availability,avail,available,26919,"lumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ |; | | x_{n0} & & x_{nj} & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & ... & & & \\ |; | `TMatrixDDiag const(X)` | & & ... & & \\ |; | `TMatrixDDiag(X)` | & & & ... & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDSub const(X,i,l,j,k)` | & & x_{ij} & ... & x_{ik} \\ |; | `TMatrixDSub(X,i,l,j,k)` | & & x_{lj} & ... & x_{lk} \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+. ### View Operators. For the matrix views **`TMatrixDRow`**, **`TMatrixDColumn`** and; **`TMatrixDDiag`**, the necessary assignment operators are available to; interact with the vector class **`TVectorD`**. The sub matrix view; **`TMatrixDSub`** has links to the matrix classes **`TMatrixD`** and; **`TMatrixDSym`**. The next table summarizes how the access individual; matrix elements in the matrix views:. +----------------------------------------+-----------------------------------+; | Format | Comment |; +----------------------------------------+-----------------------------------+; | `TMatrixDRow(A,i)(j)` | element $A_{ij}$ |; | `TMatrixDRow(A,i)[j]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDColumn(A,j)(i)` | element $A_{ij}$ |; | `TMatrixDColumn(A,j)[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDDiag(A(i)` | element $A_{ij}$ |; | `TMatrixDDiag(A[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDSub(A(i)` | element $A_{ij}$ |; | `TMatrixDSu",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:39599,Availability,toler,tolerance,39599,"lve method, because the; decomposition class checks before invoking `Solve` that the matrix has; been decomposed. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; ```. In the next example, we show again the same decomposition but now; performed in a loop and all necessary steps are manually invoked. This; example also demonstrates another very important point concerning memory; management! Note that the vector, matrix and decomposition class are; constructed outside the loop since the dimensions of vector/matrix are; constant. If we would have replaced `lu.SetMatrix(a)` by **`TDecompLU`**; `lu(a)`, we would construct/deconstruct the array elements of `lu` on; the stack*.*. ``` {.cpp}; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; ```. ### Tolerances and Scaling. The tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:39991,Availability,toler,tolerance,39991,"formed in a loop and all necessary steps are manually invoked. This; example also demonstrates another very important point concerning memory; management! Note that the vector, matrix and decomposition class are; constructed outside the loop since the dimensions of vector/matrix are; constant. If we would have replaced `lu.SetMatrix(a)` by **`TDecompLU`**; `lu(a)`, we would construct/deconstruct the array elements of `lu` on; the stack*.*. ``` {.cpp}; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; ```. ### Tolerances and Scaling. The tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:40050,Availability,toler,tolerance,40050,"ctor, matrix and decomposition class are; constructed outside the loop since the dimensions of vector/matrix are; constant. If we would have replaced `lu.SetMatrix(a)` by **`TDecompLU`**; `lu(a)`, we would construct/deconstruct the array elements of `lu` on; the stack*.*. ``` {.cpp}; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; ```. ### Tolerances and Scaling. The tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*l",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:40636,Availability,toler,tolerance,40636,"tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure)",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:40832,Availability,toler,tolerance,40832," not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A g",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:41494,Availability,toler,tolerance,41494,"uccessful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned as its determinant shows. We construct a vector `b` by; summing the matrix rows. Therefore, the components of ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:51587,Availability,error,errors,51587,"the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b` the execution time is measured for solving the linear; equation `A*x=b`. The same factorizations are used as in the matrix; inversion. However, only 1 forward/back-substitution has to be used; instead of msize as in the inversion of (msize x msize) matrix. As a; consequence the same differences are observed but less amplified. CLHEP; shows the same numerical issues as in step the matrix inversion. Since; ROOT3.10 has no dedicated equation solver, the solution is calculated; through `x=A-1*b`. This will be slower and numerically not as stable. 4. $(A^{T}*A)^{-1}*A^{T}$ timing results for calculation of the pseudo inverse; of matrix a. The sequence of operations measures the impact of several; calls to constructors and destruc",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:8542,Energy Efficiency,allocate,allocate,8542,"Int_t col_lwb,Int_t col_upb,` | `row_lwb:row_upb` x |; | | `col_lwb:col_upb` |; | `Int_t nr_nonzeros=-1)` | |; +-----------------------------------------+----------------------------------+; | `SetRowIndexArray` `(Int_t *data)` | for sparse matrices, set the row |; | | index. The array data should |; | | contains at least` fNrows+1` |; | | entries column lower-bound index |; +-----------------------------------------+----------------------------------+; | `SetColIndexArray` `(Int_t *data)` | for sparse matrices, set the |; | | column index. The array data |; | | should contains at least |; | | `fNelems` entries |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` `(Int_t nelems new)` | allocate memory for a sparse map |; | | of `nelems_new` elements and |; | | copy (if exists) at most |; | | `nelems_new` matrix elements |; | | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:39772,Energy Efficiency,monitor,monitor,39772," = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; ```. In the next example, we show again the same decomposition but now; performed in a loop and all necessary steps are manually invoked. This; example also demonstrates another very important point concerning memory; management! Note that the vector, matrix and decomposition class are; constructed outside the loop since the dimensions of vector/matrix are; constant. If we would have replaced `lu.SetMatrix(a)` by **`TDecompLU`**; `lu(a)`, we would construct/deconstruct the array elements of `lu` on; the stack*.*. ``` {.cpp}; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; ```. ### Tolerances and Scaling. The tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If on",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:40820,Energy Efficiency,monitor,monitor,40820," not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A g",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:41483,Energy Efficiency,reduce,reduce,41483,"uccessful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned as its determinant shows. We construct a vector `b` by; summing the matrix rows. Therefore, the components of ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1337,Integrability,interface,interface,1337,"d **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33828,Integrability,interface,interface,33828,"ogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +----------------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:47636,Integrability,depend,depends,47636,"entity matrix.; The columns of $V$ represent the; eigenvectors in the sense that $A.V = V.D$. If $A$ is not; symmetric, the eigenvalue matrix $D$ is block; diagonal with the real eigenvalues in 1-by-1 blocks and any complex; eigenvalues, `a+i*b`, in 2-by-2 blocks, `[a,b;-b,a]`. That is, if the; complex eigenvalues look like:. $$; \left(\begin{array}{cccccc}; u+iv & . & . & . & . & . \\; . & u-iv & . & . & . & . \\; . & . & a+ib & . & . & . \\; . & . & . & a-ib & . & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); $$; then $D$ looks like:; $$; \left(\begin{array}{cccccc}; u & v & . & . & . & . \\; -v & u & . & . & . & . \\; . & . & a & b & . & . \\; . & . & . & -b & a & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); $$. This keeps $V$ a real matrix in both symmetric; and non-symmetric cases, and $A.V = V.D$. The matrix $V$ may be badly conditioned,; or even singular, so the validity of the equation $A = V.D.V^{-1}$ depends upon the; condition number of $V$. Next table shows the; methods of the classes **`TMatrixDEigen`** and **`TMatrixDSymEigen`** to; obtain the eigenvalues and eigenvectors. Obviously,; **`MatrixDSymEigen`** constructors can only be called with; **`TMatrixDSym`**:. +------------------------------+-----------+------------------------------------+; | Format | Output | Description |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenVectors` `()` | `TMatrixD | eigenvectors for both |; | | ` | `TMatrixDEigen` and |; | | | `TMatrixDSymEigen` |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenValues` `()` | `TVectorD | eigenvalues vector for |; | | ` | `TMatrixDSymEigen` |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenValues()` | `TMatrixD | eigenvalues matrix for |; | | ` | `TMatrixDEigen` |; +------------------------------+-----------+-----------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:49966,Integrability,depend,dependence,49966,"Eigen` |; +------------------------------+-----------+------------------------------------+. Below, usage of the eigenvalue class is shown in an example where it is; checked that the square of the singular values of a matrix; $c$ are identical to the eigenvalues; of $c^{T}$. $c$:. ``` {.cpp}; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instan",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50314,Integrability,rout,routines,50314,",10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain s",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50866,Integrability,rout,routine,50866,". `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b`",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:51717,Integrability,rout,routines,51717,"ion followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b` the execution time is measured for solving the linear; equation `A*x=b`. The same factorizations are used as in the matrix; inversion. However, only 1 forward/back-substitution has to be used; instead of msize as in the inversion of (msize x msize) matrix. As a; consequence the same differences are observed but less amplified. CLHEP; shows the same numerical issues as in step the matrix inversion. Since; ROOT3.10 has no dedicated equation solver, the solution is calculated; through `x=A-1*b`. This will be slower and numerically not as stable. 4. $(A^{T}*A)^{-1}*A^{T}$ timing results for calculation of the pseudo inverse; of matrix a. The sequence of operations measures the impact of several; calls to constructors and destructors in the `C++` packages versus a `C`; library like `GSL`. ![Speed comparison between the different matrix packages](pictures/030",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:2272,Modifiability,inherit,inherit,2272,"tten to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the classes at the top, see ""Matrix; Eigen Analysis"". In both cases, only some matrix types can be analyzed.; For instance, **`TDecompChol`** will only accept symmetric matrices as; defined **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**) or; sparse (**`TMatrixDSparse`**);. - `size` - number of rows and columns;. - `index` - range start of",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:108,Performance,perform,perform,108,"# Linear Algebra in ROOT. The linear algebra package is supposed to give a complete environment in; ROOT to perform calculations like equation solving and eigenvalue; decompositions. Most calculations are performed in double precision. For; backward compatibility, some classes are also provided in single; precision like **`TMatrixF`**, **`TMatrixFSym`** and **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; clas",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:205,Performance,perform,performed,205,"# Linear Algebra in ROOT. The linear algebra package is supposed to give a complete environment in; ROOT to perform calculations like equation solving and eigenvalue; decompositions. Most calculations are performed in double precision. For; backward compatibility, some classes are also provided in single; precision like **`TMatrixF`**, **`TMatrixFSym`** and **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; clas",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:2337,Performance,perform,performed,2337,"uld look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the classes at the top, see ""Matrix; Eigen Analysis"". In both cases, only some matrix types can be analyzed.; For instance, **`TDecompChol`** will only accept symmetric matrices as; defined **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**) or; sparse (**`TMatrixDSparse`**);. - `size` - number of rows and columns;. - `index` - range start of row and column index. By default these; start at zero;. - `sparse` `ma",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:32073,Performance,perform,perform,32073,"--+---------------------------------------+; | | `TMatrixDColumn(A,j1) *=` | multiply column $j2$ with column $j1$ |; | | `TMatrixDColumn const(A,j2)` | element wise |; +-----------------------+---------------------------------+---------------------------------------+; | multiply matrix slice | `TMatrixDDiag(A) *=` | multiply $B$ diagonal with $A$ |; | | `TMatrixDDiag const(B)` | diagonal element wise |; +-----------------------+---------------------------------+---------------------------------------+; | | `TMatrixDSub(A,i1,l1,j1,k1) *=` | multiply sub matrix of $A$ with |; | | `TMatrixDSub(B,i2,l2,j2,k2)` | sub matrix of $B$ |; +-----------------------+---------------------------------+---------------------------------------+; | | `TMatrixDSub(A,i,l,j,k) *= B` | multiply sub matrix of $A$ with |; | | | matrix of $B$ |; +-----------------------+---------------------------------+---------------------------------------+. In the current implementation of the matrix views, the user could; perform operations on a symmetric matrix that violate the symmetry. No; checking is done. For instance, the following code violates the; symmetry. ``` {.cpp}; TMatrixDSym A(5);; A.UnitMatrix();; TMatrixDRow(A,1)[0] = 1;; TMatrixDRow(A,1)[2] = 1;; ```. ### View Examples. Inserting row `i1 `into row` i2` of matrix $A$; can easily accomplished through:. ``` {.cpp}; TMatrixDRow(A,i1) = TMatrixDRow(A,i2); ```. Which more readable than:. ``` {.cpp}; const Int_t ncols = A.GetNcols();; Double_t *start = A.GetMatrixArray();; Double_t *rp1 = start+i*ncols;; const Double_t *rp2 = start+j*ncols;; while (rp1 < start+ncols) *rp1++ = *rp2++;; ```. Check that the columns of a Haar -matrix of order `order` are indeed; orthogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1;",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33489,Performance,perform,performs,33489," *start = A.GetMatrixArray();; Double_t *rp1 = start+i*ncols;; const Double_t *rp2 = start+j*ncols;; while (rp1 < start+ncols) *rp1++ = *rp2++;; ```. Check that the columns of a Haar -matrix of order `order` are indeed; orthogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+----------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:34271,Performance,perform,perform,34271,"x Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Solve(TVectorD &b)` | solve `Ax=b`; vector` b` is |; | | supplied through the argument and |; | | replaced with solution `x` |; +-----------------------------------------------------+--------------------------------------+; | `TVectorD Solve(const TVectorD &b,Bool_t &ok)` | solve `Ax=b; x` is returned |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Solve(TMatrixDColumn &b)` | solve |; | | `Ax=column(B,j)`;` column(",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:38952,Performance,perform,performed,38952,"sed, bit `kMatrixSet` must have been set. |; | | |; | `kDetermined` | `det` $A$ calculated, bit `kDecomposed` must have been set. |; | | |; | `kCondition` | ||*A*||1 ||*A*-1||1 is calculated bit `kDecomposed` must have been set. |; | | |; | `kSingular` | $A$ is singular |; +---------------+-------------------------------------------------------------------------+. The state is reset by assigning a new matrix through; `SetMatrix(TMatrixD &A)` for **`TDecompBK`** and **`TDecompChol`**; (actually `SetMatrix(`**`TMatrixDSym &A)`** and; `SetMatrix(`**`TMatrixDSparse`** `&A)` for **`TMatrixDSparse`**). As the code example below shows, the user does not have to worry about; the decomposition step before calling a solve method, because the; decomposition class checks before invoking `Solve` that the matrix has; been decomposed. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; ```. In the next example, we show again the same decomposition but now; performed in a loop and all necessary steps are manually invoked. This; example also demonstrates another very important point concerning memory; management! Note that the vector, matrix and decomposition class are; constructed outside the loop since the dimensions of vector/matrix are; constant. If we would have replaced `lu.SetMatrix(a)` by **`TDecompLU`**; `lu(a)`, we would construct/deconstruct the array elements of `lu` on; the stack*.*. ``` {.cpp}; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; ```. ### Tolerances and Scaling. The tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most othe",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:40573,Performance,perform,perform,40573,"tolerance parameter `fTol` (a member of the base class; **`TDecompBase`**) plays a crucial role in all operations of the; decomposition classes. It gives the user a tool to monitor and steer the; operations its default value is $\varepsilon$ where $1+\varepsilon=1$. If you do not want to be bothered by the following considerations, like; in most other linear algebra packages, just set the tolerance with; `SetTol` to an arbitrary small number. The tolerance number is used by; each decomposition method to decide whether the matrix is near singular,; except of course SVD that can handle singular matrices. This will be; checked in a different way for any decomposition. For instance in LU, a; matrix is considered singular in the solving stage when a diagonal; element of the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure)",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50288,Performance,optimiz,optimized,50288,",10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain s",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:51403,Performance,multi-thread,multi-threading,51403,"ested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b` the execution time is measured for solving the linear; equation `A*x=b`. The same factorizations are used as in the matrix; inversion. However, only 1 forward/back-substitution has to be used; instead of msize as in the inversion of (msize x msize) matrix. As a; consequence the same differences are observed but less amplified. CLHEP; shows the same numerical issues as in step the matrix inversion. Since; ROOT3.10 has no dedicated equation solver, the solution is calculated; through `x=A-1*b`. Thi",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:41420,Safety,detect,detect,41420,"the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:42582,Safety,predict,predicts,42582,"re). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned as its determinant shows. We construct a vector `b` by; summing the matrix rows. Therefore, the components of the solution; vector `x` should be exactly 1. Our rule of thumb to the 2.1012; condition number predicts that the solution accuracy should be around. `15 - 12 = 3`. digits. Indeed, the largest deviation is 0.00055 in component 6. ``` {.cpp}; TMatrixDSym H = THilbertMatrixDSym(10);; TVectorD rowsum(10);; for (Int_t irow = 0; irow < 10; irow++); for (Int_t icol = 0; icol < 10; icol++); rowsum(irow) += H(irow,icol);; TDecompLU lu(H);; Bool_t ok;; TVectorD x = lu.Solve(rowsum,ok);; Double_t d1,d2;; lu.Det(d1,d2);; cout << ""cond:"" << lu.Condition() << endl;; cout << ""det :"" << d1*TMath:Power(2.,d2) << endl;; cout << ""tol :"" << lu.GetTol() << endl;; x.Print();; cond:3.9569e+12; det :2.16439e-53; tol :2.22045e-16; Vector 10 is as follows; | 1 |; ------------------; 0 |1; 1 |1; 2 |0.999997; 3 |1.00003; 4 |0.999878; 5 |1.00033; 6 |0.999452; 7 |1.00053; 8 |0.999723; 9 |1.00006; ```. ### LU. Decompose an `nxn` matrix $A$. ``` {.cpp}; PA = LU; ```. *P* permutation matrix stored in the index array `fIndex`: `j=fIndex[i]`; indicates that row j and row` i `should be swapped. Sign of the; permutation, $-1^n$, ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:483,Security,access,access,483,"# Linear Algebra in ROOT. The linear algebra package is supposed to give a complete environment in; ROOT to perform calculations like equation solving and eigenvalue; decompositions. Most calculations are performed in double precision. For; backward compatibility, some classes are also provided in single; precision like **`TMatrixF`**, **`TMatrixFSym`** and **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; clas",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:3532,Security,access,access,3532,"ned **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**) or; sparse (**`TMatrixDSparse`**);. - `size` - number of rows and columns;. - `index` - range start of row and column index. By default these; start at zero;. - `sparse` `map` - this property is only relevant for a sparse matrix.; It indicates where elements are unequal zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+-------------------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:4983,Security,access,access,4983,"qual zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+----------------------------------------------+; | `Int_t GetNoElements` `()` | number of elements, for a dense matrix this |; | | equals: `fNrows x fNcols` |; +-----------------------------+----------------------------------------------+; | `Double_t GetTol` `()` | tolerance number which is used in |; | | decomposition operations |; +-----------------------------+----------------------------------------------+; | `Int_t *GetRowIndexArray` | for sparse matrices, access to the row index |; | `()` | of `fNrows+1` entries |; +-----------------------------+----------------------------------------------+; | `Int_t *GetColIndexArray` | for sparse matrices, access to the column |; | `()` | index of `fNelems` entries |; +-----------------------------+----------------------------------------------+. The last two methods in this table are specific to the sparse matrix,; which is implemented according to the Harwell-Boeing format. Here,",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:5175,Security,access,access,5175,"qual zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+----------------------------------------------+; | `Int_t GetNoElements` `()` | number of elements, for a dense matrix this |; | | equals: `fNrows x fNcols` |; +-----------------------------+----------------------------------------------+; | `Double_t GetTol` `()` | tolerance number which is used in |; | | decomposition operations |; +-----------------------------+----------------------------------------------+; | `Int_t *GetRowIndexArray` | for sparse matrices, access to the row index |; | `()` | of `fNrows+1` entries |; +-----------------------------+----------------------------------------------+; | `Int_t *GetColIndexArray` | for sparse matrices, access to the column |; | `()` | index of `fNelems` entries |; +-----------------------------+----------------------------------------------+. The last two methods in this table are specific to the sparse matrix,; which is implemented according to the Harwell-Boeing format. Here,",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:24856,Security,access,access,24856,"generated with elements |; | | | uniformly distributed |; | | | between $\alpha$ and $\beta$ |; +--------------------------+------------+---------------------------------------------+. Output **`TMatrixX`** indicates that the returned matrix is of the same; type as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:25230,Security,access,access,25230,"as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ |; | | x_{n0} & & x_{nj} & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & ... & & & \\ |; | `TMatrixDDiag const(X)` |",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:27124,Security,access,access,27124,"ray}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & ... & & & \\ |; | `TMatrixDDiag const(X)` | & & ... & & \\ |; | `TMatrixDDiag(X)` | & & & ... & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDSub const(X,i,l,j,k)` | & & x_{ij} & ... & x_{ik} \\ |; | `TMatrixDSub(X,i,l,j,k)` | & & x_{lj} & ... & x_{lk} \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+. ### View Operators. For the matrix views **`TMatrixDRow`**, **`TMatrixDColumn`** and; **`TMatrixDDiag`**, the necessary assignment operators are available to; interact with the vector class **`TVectorD`**. The sub matrix view; **`TMatrixDSub`** has links to the matrix classes **`TMatrixD`** and; **`TMatrixDSym`**. The next table summarizes how the access individual; matrix elements in the matrix views:. +----------------------------------------+-----------------------------------+; | Format | Comment |; +----------------------------------------+-----------------------------------+; | `TMatrixDRow(A,i)(j)` | element $A_{ij}$ |; | `TMatrixDRow(A,i)[j]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDColumn(A,j)(i)` | element $A_{ij}$ |; | `TMatrixDColumn(A,j)[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDDiag(A(i)` | element $A_{ij}$ |; | `TMatrixDDiag(A[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDSub(A(i)` | element $A_{ij}$ |; | `TMatrixDSub(A,rl,rh,cl,ch)(i,j)` | |; | | element $A_{rl+i,cl+j}$ |; +----------------------------------------+-----------------------------------+. The next two tables show the possible operations with real numbers, and; the operations between the matrix vie",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50355,Testability,test,tested,50355,");; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1392,Usability,guid,guide,1392,"d **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:9377,Usability,clear,clear,9377,"s |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` `(Int_t nelems new)` | allocate memory for a sparse map |; | | of `nelems_new` elements and |; | | copy (if exists) at most |; | | `nelems_new` matrix elements |; | | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index range.; Finally, one can also define the matrix data in the constructor. In; Matrix Operators and Methods we will encounter more fancy constructors; that will allow arithmetic operations. +--------------------------------------------------------------------------+; | `TMatrixD(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)` |; | |; | `TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= |; | """")` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,` |; | |; | ` const Double_t *data,Option_t *option="""")` |; +-----",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:9657,Usability,simpl,simplest,9657," | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index range.; Finally, one can also define the matrix data in the constructor. In; Matrix Operators and Methods we will encounter more fancy constructors; that will allow arithmetic operations. +--------------------------------------------------------------------------+; | `TMatrixD(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)` |; | |; | `TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= |; | """")` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,` |; | |; | ` const Double_t *data,Option_t *option="""")` |; +--------------------------------------------------------------------------+; | `TMatrixDSym(Int_t nrows)` |; | |; | `TMatrixDSym(Int_t row_lwb,Int_t row_upb) ` |; | |; | `TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option="""")` |; | |; | `TMatrixDSym(Int_t row_lwb",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:25052,Usability,simpl,simply,25052,"generated with elements |; | | | uniformly distributed |; | | | between $\alpha$ and $\beta$ |; +--------------------------+------------+---------------------------------------------+. Output **`TMatrixX`** indicates that the returned matrix is of the same; type as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ ",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33806,Usability,simpl,simple,33806,"ogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +----------------------",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50404,Usability,clear,clearly,50404,"gen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the i",MatchSource.DOCS,documentation/users-guide/LinearAlgebra.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1180,Availability,error,error,1180,"evelopments have been concentrated in providing first versions of the; `MathCore` and `MathMore` libraries, included in ROOT v5.08. Other; recent developments include the new version of `MINUIT`, which has been; re-designed and re-implemented in the C++ language. It is integrated in; ROOT. In addition, an optimized package for describing small matrices; and vector with fixed sizes and their operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- mult",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2947,Availability,avail,available,2947,"rithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms o",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:5465,Availability,down,downloding,5465,"andom number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, like common probability and cumulative; (quantile) distributions. - geometrical functions. For more details, se",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:5703,Availability,avail,available,5703," naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, like common probability and cumulative; (quantile) distributions. - geometrical functions. For more details, see the reference documentation of **`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice tha",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:15727,Availability,avail,available,15727,"ed using TUUID; TRandom1 r1(0);; TRandom2 r2(0);; TRandom3 r3(0);; // seed generated using machine clock (different every second); TRandom r0(0);; ```. ### Random Number Distributions. The **`TRandom`** base class provides functions, which can be used by; all the other derived classes for generating random variates according; to predefined distributions. In the simplest cases, like in the case of; the exponential distribution, the non-uniform random number is obtained; by applying appropriate transformations. In the more complicated cases,; random variates are obtained using acceptance-rejection methods, which; require several random numbers. ``` {.cpp}; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; ```. The following table shows the various distributions that can be; generated using methods of the **`TRandom`** classes. More information; is available in the reference documentation for **`TRandom`**. In; addition, random numbers distributed according to a user defined; function, in a limited interval, or to a user defined histogram, can be; generated in a very efficient way using **`TF1::`**GetRandom() or; **`TH1::`**GetRandom(). +-------------------------------------------+--------------------------------+; | Distributions | Description |; +-------------------------------------------+--------------------------------+; | `Double_t Uniform(Double_t x1,Double_t x2 | Uniform random numbers between |; | )` | `x1,x2` |; +-------------------------------------------+--------------------------------+; | `Double_t Gaus(Double_t mu,Double_t sigma | Gaussian random numbers. |; | )` | |; | | Default values: `mu=0`, |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+; | `Double_t Exp(Double_t tau)` | Exponential random numbers |; | | with mean tau. |; +-------------------------------------------+------------",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18827,Availability,avail,available,18827," | `Sphere(Double_t &x,Double_t &y,` | Generate a random 3D point |; | | `(x,y,z)` in |; | ` Double_t &z,Double_t r)` | |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For continuous 1D distribution object via the class; **`TUnuranContDist`** that can be created for example from a; **`TF1`** function providing the pdf (probability density function); . The user can optionally provide additional information via; `TUnuranContDist::SetDomain(min,max)` like the `domain()` for; generating numbers in a restricted region. `",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:24602,Availability,error,error,24602,"|; +--------------------+---------------+----------------+----------------+----------------+. ## Mathematical Functions. The mathematical functions are present in both `MathCore` and `MathMore`; libraries. All mathematical functions are implemented as free functions; in the namespace **`ROOT::Math`**. The most used functions are in the; `MathCore` library while the others are in the `MathMore` library. The; functions in `MathMore` are all using the implementation of the GNU; Scientific Library (GSL). The naming of the special functions is the; same defined in the C++; [Technical Report on Standard Library extensions](Technical Report on; Standard Library extensions).; The special functions are defined in the header file `Math/SpecFunc.h`. ### Special Functions in MathCore. - `ROOT::Math::beta(double x,double y) - `evaluates the beta function:; $$B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}$$. - `double ROOT::Math::erf(double x)` - evaluates the error function; encountered in integrating the normal; distribution:; $$erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt$$. - `double ROOT::Math::erfc(double x)` - evaluates the complementary; error function:; $$erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt$$. - `double ROOT::Math::tgamma(double x)` - calculates the gamma; function:; $$\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt$$. ### Special Functions in MathMore. - `double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -`computes; the associated Legendre polynomials (with `m>=0`, `l>=m` and; `|x|<1)`:; $$P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)$$. - `double ROOT::Math::comp_ellint_1(double k)` - calculates the; complete elliptic integral of the first kind (with $0 \le k^2 \le 1$:; $$; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; $$. - `double ROOT::Math::comp_ellint_2(double k)` - calculates the; complete elliptic integral of the second kind (with $0 \le k^2 \le 1",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:24801,Availability,error,error,24801,"ore` and `MathMore`; libraries. All mathematical functions are implemented as free functions; in the namespace **`ROOT::Math`**. The most used functions are in the; `MathCore` library while the others are in the `MathMore` library. The; functions in `MathMore` are all using the implementation of the GNU; Scientific Library (GSL). The naming of the special functions is the; same defined in the C++; [Technical Report on Standard Library extensions](Technical Report on; Standard Library extensions).; The special functions are defined in the header file `Math/SpecFunc.h`. ### Special Functions in MathCore. - `ROOT::Math::beta(double x,double y) - `evaluates the beta function:; $$B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}$$. - `double ROOT::Math::erf(double x)` - evaluates the error function; encountered in integrating the normal; distribution:; $$erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt$$. - `double ROOT::Math::erfc(double x)` - evaluates the complementary; error function:; $$erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt$$. - `double ROOT::Math::tgamma(double x)` - calculates the gamma; function:; $$\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt$$. ### Special Functions in MathMore. - `double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -`computes; the associated Legendre polynomials (with `m>=0`, `l>=m` and; `|x|<1)`:; $$P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)$$. - `double ROOT::Math::comp_ellint_1(double k)` - calculates the; complete elliptic integral of the first kind (with $0 \le k^2 \le 1$:; $$; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; $$. - `double ROOT::Math::comp_ellint_2(double k)` - calculates the; complete elliptic integral of the second kind (with $0 \le k^2 \le 1$):; $$; E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta; $$. - `double ROOT::Math::comp_ellint_3(double n,double k)` - calculates; the compl",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34134,Availability,avail,available,34134,"Math/ProbFunc.h`. The majority of the CDF's are present in the; `MathCore`, apart from the `chisquared`, `fdistribution`, `gamma` and; `tdistribution`, which are in the `MathMore` library. #### Inverse of the Cumulative Distribution Functions(Quantiles). For almost all the cumulative distribution functions (`_cdf`) and their; complements (`_cdf_c`) present in the library, we provide the inverse; functions. The inverse of the cumulative distribution function is called; in statistics quantile function. The functions with the extension; `_quantile` calculate the inverse of the cumulative distribution; function (lower tail integral of the probability density function),; while those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48772,Availability,toler,tolerance,48772,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50747,Availability,avail,available,50747,"for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Mat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50927,Availability,toler,tolerance,50927,"ific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ER",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:51278,Availability,toler,tolerances,51278,"part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55567,Availability,toler,tolerance,55567,"h::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva G",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55621,Availability,toler,tolerance,55621," integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration reg",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55700,Availability,toler,tolerance,55700,"several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteratio",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55882,Availability,error,error,55882,"f the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56718,Availability,error,error,56718,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58668,Availability,avail,available,58668,"se of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:60947,Availability,toler,tolerance,60947,"s enumeration and the corresponding classes. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorMultiDim::kADAPTIVE` | `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a deta",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:60975,Availability,toler,tolerance,60975,"s enumeration and the corresponding classes. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorMultiDim::kADAPTIVE` | `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a deta",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61549,Availability,toler,tolerance,61549,"lgorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function fro",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:64904,Availability,toler,tolerance,64904,"ry implementing the Brent method (not using the derivatives); and one in the *MathMore* library implementing several different methods, using in some case the derivatives. #### `ROOT::Math::BrentMinimizer1D`. This class implements the Brent method to minimize one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66061,Availability,avail,available,66061,"slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the functio",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66358,Availability,toler,tolerance,66358,"lt); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the function.; In that case a `ROOT::Math::IGradientFunctionOneDim` object must be provided. ## Generic Vectors for 2, 3 and 4 Dimensions (GenVector). `GenVector` is a package intended to represent vectors and their; operations and transformations, such ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68785,Availability,avail,available,68785,"rovided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case,",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:71502,Availability,avail,available,71502,"arameter of the class. Various classes exist to; describe the various coordinates systems:. 2D coordinate system classes:. - **`ROOT::Math::Cartesian2D`**, based on (`x,y`);. - **`ROOT::Math::Polar2D`**, based on (`r,phi`);. 3D coordinate system classes:. - **`ROOT::Math::Cartesian3D`**, based on (`x,y,z`);. - **`ROOT::Math::Polar3D`**, based on (`r,theta,phi`);. - **`ROOT::Math::Cylindrical3D`**, based on (`rho,z,phi`). - **`ROOT::Math::CylindricalEta3D`**, based on (`rho,eta,phi`), where; `eta` is the pseudo-rapidity;. 4D coordinate system classes:. - **`ROOT::Math::PxPyPzE4D`**, based on based on (`px,py,pz,E`);. - **`ROOT::Math::PxPyPzM4D`**, based on based on (`px,py,pz,M`);. - **`ROOT::Math::PtEtaPhiE4D`**, based on based on (`pt,eta,phi,E`);. - **`ROOT::Math::PtEtaPhiM4D`**, based on based on (`pt,eta,phi,M`);. Users can define the vectors according to the coordinate type, which is; the most efficient for their use. Transformations between the various; coordinate systems are available through copy constructors or the; assignment (=) operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:71921,Availability,avail,available,71921,"Math::Cylindrical3D`**, based on (`rho,z,phi`). - **`ROOT::Math::CylindricalEta3D`**, based on (`rho,eta,phi`), where; `eta` is the pseudo-rapidity;. 4D coordinate system classes:. - **`ROOT::Math::PxPyPzE4D`**, based on based on (`px,py,pz,E`);. - **`ROOT::Math::PxPyPzM4D`**, based on based on (`px,py,pz,M`);. - **`ROOT::Math::PtEtaPhiE4D`**, based on based on (`pt,eta,phi,E`);. - **`ROOT::Math::PtEtaPhiM4D`**, based on based on (`pt,eta,phi,M`);. Users can define the vectors according to the coordinate type, which is; the most efficient for their use. Transformations between the various; coordinate systems are available through copy constructors or the; assignment (=) operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformation",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:72622,Availability,error,errors,72622,") operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:73103,Availability,avail,available,73103,"between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (**`ROOT::Math::RotationZ`**); and described by just one angle. - 3D transformation: we describe the transformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the C",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:77767,Availability,avail,available,77767," their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float's. To use them, one; must include the header file `Math/Vector3D.h`. The following typedef's,; defined in the header file `Math/Vector3Dfwd.h`, are available for the; different instantiations of the template class; `ROOT::Math::`**`DisplacementVector3D`**:. - `ROOT::Math::`**`XYZVector`** vector based on `x,y,z` coordinates; (Cartesian) in double precision. - `ROOT::Math::`**`XYZVectorF`** vector based on `x,y,z` coordinates; (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DVector`** vector based on `r,theta,phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DVectorF`** vector based on `r,theta,phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiVector`** vector based on `rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiVectorF`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in float; precision. #### Cons",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:78874,Availability,avail,available,78874,"Vector3D`**:. - `ROOT::Math::`**`XYZVector`** vector based on `x,y,z` coordinates; (Cartesian) in double precision. - `ROOT::Math::`**`XYZVectorF`** vector based on `x,y,z` coordinates; (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DVector`** vector based on `r,theta,phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DVectorF`** vector based on `r,theta,phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiVector`** vector based on `rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiVectorF`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in float; precision. #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; ```. Note that each vector type is constructed by passing its coordinate; representation, so a `XYZVector(1,2,3)` is different from a; `Polar3DVector(1,2,3)`. In addition, the vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`; and `z()`. This can be another 3D vector based on a different coordinate; system type. It can be even any vector of a different package, like the; CLHEP **`HepThreeVector`** that implements the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:79787,Availability,avail,available,79787,". #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; ```. Note that each vector type is constructed by passing its coordinate; representation, so a `XYZVector(1,2,3)` is different from a; `Polar3DVector(1,2,3)`. In addition, the vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`; and `z()`. This can be another 3D vector based on a different coordinate; system type. It can be even any vector of a different package, like the; CLHEP **`HepThreeVector`** that implements the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:80963,Availability,avail,available,80963,"tesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a **`XYZVector`** or `SetR()` for a polar; vector. Attempting to do a `SetX()` on a polar vector will not compile. ``` {.cpp}; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; ```. In addition, there are setter methods from C arrays or iterator. ``` {.cpp}; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; ```. or, for example, from an `std::vector` using the iterator. ``` {.cpp}; std::vector w(3);; // set (x,y,z) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; ```. #### Arithmetic Operations. The following operations are possible between vector classes, even of; different coordinate system types: (`v1,v2` are any type of; **`ROOT::Math::DisplacementVector3D`** classes, `v3` is the same type; of `v1`; `a` is ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:82974,Availability,avail,available,82974,".cpp}; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; ```. #### Comparison. For `v1` and `v2` of the same type (same coordinate system and same; scalar type):. ``` {.cpp}; v1 == v2;; v1 != v2;; ```. #### Dot and Cross Product. We support the dot and cross products, through the `Dot()` and `Cross()`; method, with any vector (`q`) implementing `x()`, `y()` and `z()`. ``` {.cpp}; XYZVector v1(x,y,z);; double s = v1.Dot(q);; XYZVector v2 = v1.Cross(q);; ```. Note that the multiplication between two vectors using the operator `*`; is not supported because it is ambiguous. #### Other Methods. ``` {.cpp}; XYZVector u = v1.Unit(); //return unit vector parallel to v1; ```. ### Example: 3D Point Classes. To use all possible types of 3D points one must include the header file; `Math/Point3D.h`. The following typedef's defined in the header file; `Math/Point3Dfwd.h`, are available for different instantiations of the; template class **`ROOT::Math`**`::`**`PositionVector3D`**:. - `ROOT::Math::`**`XYZPoint`** point based on `x`, `y`, `z`; coordinates (Cartesian) in double precision. - `ROOT::Math::`**`XYZPointF`** point based on `x`, `y`, `z`; coordinates (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DPoint`** point based on `r`, `theta`, `phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DPointF`** point based on `r`, `theta`, `phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiPoint`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in double precision. - `ROOT::Math::`**`RhoZPhiPointF`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in float precision. - `ROOT::Math::`**`RhoEtaPhiPoint`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiPointF`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:84126,Availability,avail,available,84126,"nt based on `x`, `y`, `z`; coordinates (Cartesian) in double precision. - `ROOT::Math::`**`XYZPointF`** point based on `x`, `y`, `z`; coordinates (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DPoint`** point based on `r`, `theta`, `phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DPointF`** point based on `r`, `theta`, `phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiPoint`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in double precision. - `ROOT::Math::`**`RhoZPhiPointF`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in float precision. - `ROOT::Math::`**`RhoEtaPhiPoint`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiPointF`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta instead of `z`) in float; precision. #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZPoint p1; //an empty vector (x=0, y=0, z=0); XYZPoint p2(1,2,3); //; ```. Note that each point type is constructed by passing its coordinate; representation, so a `XYZPoint(1,2,3)` is different from a; `Polar3DPoint(1,2,3)`. In addition the point classes can be constructed; by any vector, which implements the accessors `x()`, `y()` and `z()`.; This can be another 3D point based on a different coordinate system type; or even any vector of a different package, like the CLHEP; **`HepThreePoint`** that implements the required signatures. ``` {.cpp}; XYZPoint p1(1,2,3);; RhoEtaPHiPoint r2(v1);; CLHEP::HepThreePoint q(1,2,3);; XYZPoint p3(q);; ```. #### Coordinate Accessors and Setter Methods. For the points classes we have the same getter and setter methods as for; the vector classes. See ""Example: 3D Vector Classes"". #### Point-Vector Operations. The following operations are possible between points and vector classes:; (`p1`, `p2` and `p3` are instantia",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:86147,Availability,avail,available,86147,"` of the; same type; `v1` and `v2` are `ROOT::Math::`**`DisplacementVector3D`**; objects). ``` {.cpp}; p1 += v1;; p1 -= v1;; p3 = p1 + v1; // p1 and p3 are the same type; p3 = v1 + p1; // p3 is based on the same coordinate system as v1; p3 = p1 - v1;; p3 = v1 - p1;; v2 = p1 - p2; // difference between points returns a vector v2; // based on the same coordinate system as p1; ```. Note that the addition between two points is **NOT** possible and the; difference between points returns a vector. #### Other Operations. Exactly as for the 3D Vectors, the following operations are allowed:. - comparison of points. - scaling and division of points with a scalar. - dot and cross product with any type of vector. ### Example: LorentzVector Classes. As in the 3D case, typedef's are defined for user convenience. and can; be used by including the header file `Math/Vector4D.h`. The following; typedef's, defined in the header file `Math/Vector4Dfwd.h`, are; available for the different instantiations of the template class; **`ROOT::Math::LorentzVector`**:. - `ROOT::Math::`**`XYZTVector`** vector based on `x`, `y`, `z`, `t`; coordinates (Cartesian) in double precision. - `ROOT::Math::`**`XYZTVectorF`** vector based on `x`, `y`, `z`, `t`; coordinates (Cartesian) in float precision. - `ROOT::Math::`**`PtEtaPhiEVector`** vector based on `pt(rho)`,; `eta`, `phi` and `E(t)` coordinates in double precision. - `ROOT::Math::`**`PtEtaPhiMVector`** vector based on `pt(rho)`,; `eta`, `phi` and `M(t)` coordinates in double precision. - `ROOT::Math::`**`PxPyPzMVector`** vector based on `px`, `py`, `pz`; and `M(mass)` coordinates in double precision. The metric used for all the LorentzVector is (`-,-,-,+`) . #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:86962,Availability,avail,available,86962," case, typedef's are defined for user convenience. and can; be used by including the header file `Math/Vector4D.h`. The following; typedef's, defined in the header file `Math/Vector4Dfwd.h`, are; available for the different instantiations of the template class; **`ROOT::Math::LorentzVector`**:. - `ROOT::Math::`**`XYZTVector`** vector based on `x`, `y`, `z`, `t`; coordinates (Cartesian) in double precision. - `ROOT::Math::`**`XYZTVectorF`** vector based on `x`, `y`, `z`, `t`; coordinates (Cartesian) in float precision. - `ROOT::Math::`**`PtEtaPhiEVector`** vector based on `pt(rho)`,; `eta`, `phi` and `E(t)` coordinates in double precision. - `ROOT::Math::`**`PtEtaPhiMVector`** vector based on `pt(rho)`,; `eta`, `phi` and `M(t)` coordinates in double precision. - `ROOT::Math::`**`PxPyPzMVector`** vector based on `px`, `py`, `pz`; and `M(mass)` coordinates in double precision. The metric used for all the LorentzVector is (`-,-,-,+`) . #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:87886,Availability,avail,available,87886," Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCo",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:89115,Availability,avail,available,89115,"v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e for a PtEtaPhiEVector; v2.SetCoordinates(c1,c2,c3,c4);; //sets cartesian components for PtEtaPhiEVector; v2.SetXYZ(x,y,z,t);; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a `XYZTVector` or `SetPt()` for a; **`PtEtaPhiEVector`**. Attempting to do a `SetX()` on a non-Cartesian; vector will not compile. ``` {.cpp}; XYZTVector v1;; v1.SetX(1); //OK setting x for a cartesian vector; PtEtaPhiEVector v2;; v2.SetX(1); //ERROR: cannot set X for a non-cartesian; //vector. Method will not compile.; v2.SetR(1) // OK setting Pt for a PtEtaPhiEVector vector; ```. In addition, there are setter methods from C arrays or iterators. ``` {.cpp}; double d[4] = {1.,2.,3.,4.};; XYZTVector v;; //set (x,y,z,t) components of v using values from d; v.SetCoordinates(d);; ```. or for example from an `std::vector `using the iterators. ``` {.cpp}; std::vector w(4);; //set (x,y,z,t) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; ```. #### Arithmetic Operations. The following operations are possible between Lorentz vectors classes,; even of different coordinate system types: (`v` and` w` are two Lorentz; vector of the same type, `q `is ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:101795,Availability,avail,available,101795,"ath::MatRepSym`**) which contains only the `N*(N+1)/2`; independent element of a `NxN` symmetric matrix. It is not in the; mandate of this package to provide complete linear algebra; functionality. It provides basic matrix and vector functions such as; matrix-matrix, matrix-vector, vector-vector operations, plus some extra; functionality for square matrices, like inversion and determinant; calculation. The inversion is based on the optimized Cramer method for; squared matrices of size up to `6x6`. The `SMatrix` package contains only header files. Normally one does not; need to build any library. In the ROOT distribution a library,; `libSmatrix` is produced with the C++ dictionary information for squared; and symmetric matrices and vectors up to dimension 7 and based on; **`Double_t`**, **`Float_t`** and **`Double32_t`**. The following; paragraphs describe the main characteristics of the matrix and vector; classes. More detailed information about the `SMatrix` classes API is; available in the; [online reference documentation](online reference documentation). ### Example: Vector Class (SVector). The template class **`ROOT::Math::SVector`** represents `n`-dimensional; vectors for objects of arbitrary type. This class has 2 template; parameters, which define at compile time, its properties: 1) type of the; contained elements (for example *float* or *double*); 2) size of the; vector. The use of this dictionary is mandatory if one want to use; `Smatrix` in Cling and with I/O. #### Creating a Vector. The following constructors are available to create a vector:. - Default constructor for a zero vector (all elements equal to zero). - Constructor (and assignment) from a vector expression, like; `v=p*q+w`. Due to the expression template technique, no temporary; objects are created in this operation. - Constructor by passing directly the elements. This is possible only; for vectors up to size 10. - Constructor from an iterator copying the data referred by the; iterator. It is p",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:102355,Availability,avail,available,102355,"es. Normally one does not; need to build any library. In the ROOT distribution a library,; `libSmatrix` is produced with the C++ dictionary information for squared; and symmetric matrices and vectors up to dimension 7 and based on; **`Double_t`**, **`Float_t`** and **`Double32_t`**. The following; paragraphs describe the main characteristics of the matrix and vector; classes. More detailed information about the `SMatrix` classes API is; available in the; [online reference documentation](online reference documentation). ### Example: Vector Class (SVector). The template class **`ROOT::Math::SVector`** represents `n`-dimensional; vectors for objects of arbitrary type. This class has 2 template; parameters, which define at compile time, its properties: 1) type of the; contained elements (for example *float* or *double*); 2) size of the; vector. The use of this dictionary is mandatory if one want to use; `Smatrix` in Cling and with I/O. #### Creating a Vector. The following constructors are available to create a vector:. - Default constructor for a zero vector (all elements equal to zero). - Constructor (and assignment) from a vector expression, like; `v=p*q+w`. Due to the expression template technique, no temporary; objects are created in this operation. - Constructor by passing directly the elements. This is possible only; for vectors up to size 10. - Constructor from an iterator copying the data referred by the; iterator. It is possible to specify the *begin* and *end* of the; iterator or the *begin* and the *size*. Note that for the Vector the; iterator is not generic and must be of type `T*`, where `T` is the; type of the contained elements. In the following example we assume that we are using the namespace; **`ROOT::Math`**. ``` {.cpp}; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements ca",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:104179,Availability,error,error,104179,"ector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; ```. For the vector functions see later in the Matrix and Vector Operators; and Functions paragraph. ### Example: Matrix Class (SMatrix). The template class **`ROOT::Math::SMatrix`** represents a matrix of; arbitrary type with `nrows` `x` `ncol` dimension. The class has 4; template parameters, which define at compile time, its properties:. - type of the contained elements, T, for example float or double;. - number of rows;. - number of columns;. - representation type. This is a class describing the underlined; storage model of the Matrix. Presently exists only two types of this; class:. - **`ROOT::Math::Ma",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:104289,Availability,error,error,104289,"ssing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; ```. For the vector functions see later in the Matrix and Vector Operators; and Functions paragraph. ### Example: Matrix Class (SMatrix). The template class **`ROOT::Math::SMatrix`** represents a matrix of; arbitrary type with `nrows` `x` `ncol` dimension. The class has 4; template parameters, which define at compile time, its properties:. - type of the contained elements, T, for example float or double;. - number of rows;. - number of columns;. - representation type. This is a class describing the underlined; storage model of the Matrix. Presently exists only two types of this; class:. - **`ROOT::Math::MatRepStd`** for a general `nrows x ncols` matrix.; This class is itself a template on the contained type `T`, the; number of rows and the number of columns. It",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:106276,Availability,avail,available,106276,"he number of columns. Its data member is an; array `T[nrows*ncols]` containing the matrix data. The data are; stored in the row-major C convention. For example, for a matrix `M`,; of size `3x3`, the data `{a0,a1,...,a8}` are stored in the following; order:. $$; M =; \left(\begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8; \end{array}\right); $$. - **`ROOT::Math::MatRepSym`** for a symmetric matrix of size `NxN`.; This class is a template on the contained type and on the symmetric; matrix size `N`. It has as data member an array of type `T` of size; `N*(N+1)/2`, containing the lower diagonal block of the matrix. The; order follows the lower diagonal block, still in a row-major; convention. For example for a symmetric `3x3` matrix the order of; the `6` independent elements `{a0,a1,...,a5}` is:. $$; M =; \left(\begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5; \end{array}\right); $$. #### Creating a Matrix. The following constructors are available to create a matrix:. - Default constructor for a zero matrix (all elements equal to zero). - Constructor of an identity matrix. - Copy constructor (and assignment) for a matrix with the same; representation, or from a different one when possible, for example; from a symmetric to a general matrix. - Constructor (and assignment) from a matrix expression, like; `D=A*B+C`. Due to the expression template technique, no temporary; objects are created in this operation. In the case of an operation; like `A=A*B+C`, a temporary object is needed and it is created; automatically to store the intermediary result in order to preserve; the validity of this operation. - Constructor from a generic STL-like iterator copying the data; referred by the iterator, following its order. It is both possible; to specify the begin and end of the iterator or the begin and the; size. In case of a symmetric matrix, it is required only the; triangular block and the user can specify whether giving a block; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:110435,Availability,error,error,110435,"tric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; ```. There are methods to place and/or retrieve **`ROOT::Math::SVector`**; objects as rows or columns in (from) a matrix. In addition one can put; (get) a sub-matrix as another **`ROOT::Math::SMatrix`** object in a; matrix. If the size of the sub-vector or sub-matrix is larger than the; matrix size a static assert (a compilation error) is produced. The; non-const methods are:. ``` {.cpp}; SMatrix33 m;; SVector2 v2(1,2);; // place a vector in the first row from; // element (0,1) : m(0,1)=v2[0]; m.Place_in_row(v2,0,1);; // place the vector in the second column from; // (0,1) : m(0,1) = v2[0]; m.Place in_col(v2,0,1);; SMatrix22 m2;; // place m2 in m starting from the; // element (1,1) : m(1,1) = m2(0,0); m.Place_at(m2,1,1);; SVector3 v3(1,2,3);; // set v3 as the diagonal elements; // of m : m(i,i) = v3[i] for i=0,1,2; m.SetDiagonal(v3); ```. The const methods retrieving contents (getting slices of a matrix) are:. ``` {.cpp}; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:111930,Availability,avail,available,111930,"or i=0,1,2; m.SetDiagonal(v3); ```. The const methods retrieving contents (getting slices of a matrix) are:. ``` {.cpp}; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; ```. #### Linear Algebra Matrix Functions (Inversion, Determinant). Only limited linear algebra functionality is available for `SMatrix`. It; is possible for squared matrices `NxN`, to find the inverse or to; calculate the determinant. Different inversion algorithms are used if; the matrix is smaller than `6x6` or if it is symmetric. In the case of a; small matrix, a faster direct inversion is used. For a large; `(N>6) `symmetric matrix the Bunch-Kaufman diagonal pivoting method is; used while for a large `(N>6)` general matrix an LU factorization is; performed using the same algorithm as in the CERNLIB routine `dinv`. ``` {.cpp}; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calcula",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:116224,Availability,avail,available,116224," returns the scalar value resulting; from the matrix-vector product `vTMv`. - `ROOT::Math::Similarity(U,M)` returns the matrix resulting from the; product: `U M UT`. If `M` is symmetric, the returned resulting; matrix is also symmetric. - `ROOT::Math::SimilarityT(U,M)` returns the matrix resulting from the; product: `UT M U`. If `M` is symmetric, the returned resulting; matrix is also symmetric. The major vector functions are:. - `ROOT::Math::Dot(v1,v2)` returns the scalar value resulting from the; vector dot product. - `ROOT::Math::Cross(v1,v2)` returns the vector cross product for two; vectors of size 3. Note that the `Cross` product is not defined for; other vector sizes. - `ROOT::Math::Unit(v)` returns unit vector. One can use also the; `v.Unit() `method. - `ROOT::Math::TensorProd(v1,v2)` returns a general matrix `M `of size; `N1xN2` resulting from the tensor product between the vector `v1` of; size `N1` and `v2` of size `N2`:. For a list of all the available matrix and vector functions see the; `SMatrix` online reference documentation. #### Matrix and Vector I/O. One can print (or write in an output stream) Vectors and Matrices) using; the `Print` method or the `<<` operator:. ``` {.cpp}; // m is a SMatrix or a SVector object; m.Print(std::cout);; std::cout << m << std::endl;; ```. In the ROOT distribution, the Cling dictionary is generated for `SMatrix`; and `SVector` for for **`Double_t`**, **`Float_t`** and **`Double32_t`**; up to dimension 7. This allows the possibility to store them in a ROOT; file. ## ROOT Statistics Classes. ### Classes for Computing Limits and Confidence Levels. **`TFeldmanCousins`** class calculates the `CL` upper/lower limit for a; Poisson process using the Feldman-Cousins method (as described in PRD; V57 \#7, p3873-3889). No treatment is provided in this method for the; uncertainties in the signal or the background. **`TRolke`** computes confidence intervals for the rate of a Poisson; process in the presence of background and efficien",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119797,Availability,robust,robust,119797,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:431,Deployability,integrat,integrated,431,"# Math Libraries in ROOT. The aim of Math libraries in ROOT is to provide and to support a; coherent set of mathematical and statistical functions. The latest; developments have been concentrated in providing first versions of the; `MathCore` and `MathMore` libraries, included in ROOT v5.08. Other; recent developments include the new version of `MINUIT`, which has been; re-designed and re-implemented in the C++ language. It is integrated in; ROOT. In addition, an optimized package for describing small matrices; and vector with fixed sizes and their operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2043,Deployability,integrat,integration,2043,"d in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3834,Deployability,integrat,integration,3834,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3942,Deployability,integrat,integration,3942,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18626,Deployability,continuous,continuous,18626,"le_t | Generate a random 2D point |; | r)` | `(x,y)` in |; | | |; | | a circle of radius `r` |; +-------------------------------------------+--------------------------------+; | `Sphere(Double_t &x,Double_t &y,` | Generate a random 3D point |; | | `(x,y,z)` in |; | ` Double_t &z,Double_t r)` | |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For continuous 1D distribution object via the class; **`TUnuranContDist`** that can be created for example from a; **`TF1`** function providing the pdf (probability density funct",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:19469,Deployability,continuous,continuous,19469,"x) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For continuous 1D distribution object via the class; **`TUnuranContDist`** that can be created for example from a; **`TF1`** function providing the pdf (probability density function); . The user can optionally provide additional information via; `TUnuranContDist::SetDomain(min,max)` like the `domain()` for; generating numbers in a restricted region. ``` {.cpp}; // 1D case: create a distribution from two TF1 object; // pointers pdfFunc; TUnuranContDist dist( pdfFunc);; // initialize unuran passing the distribution and a string; // defining the method; unr.Init(dist, ""method=hinv"");; // sample distribution N times (generate N random numbers); for (int i = 0; i < N; ++i); double x = unr.Sample();; ```. - For multi-dimensional distribution via the class; **`TUnuranMultiContDist`**, which can be created from a the; multi-dimensional pdf. ``` {.cpp}; // Multi- dimensional case from a TF1 (TF2 or TF3) objects; TUnuranMultiContDist dist( pdfFuncMulti);; // the recommended method for multi-dimensional function is ""hitro""; unr.Init(dist,""method=hitro"");; // sample distribution N times",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:24633,Deployability,integrat,integrating,24633,"|; +--------------------+---------------+----------------+----------------+----------------+. ## Mathematical Functions. The mathematical functions are present in both `MathCore` and `MathMore`; libraries. All mathematical functions are implemented as free functions; in the namespace **`ROOT::Math`**. The most used functions are in the; `MathCore` library while the others are in the `MathMore` library. The; functions in `MathMore` are all using the implementation of the GNU; Scientific Library (GSL). The naming of the special functions is the; same defined in the C++; [Technical Report on Standard Library extensions](Technical Report on; Standard Library extensions).; The special functions are defined in the header file `Math/SpecFunc.h`. ### Special Functions in MathCore. - `ROOT::Math::beta(double x,double y) - `evaluates the beta function:; $$B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}$$. - `double ROOT::Math::erf(double x)` - evaluates the error function; encountered in integrating the normal; distribution:; $$erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt$$. - `double ROOT::Math::erfc(double x)` - evaluates the complementary; error function:; $$erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt$$. - `double ROOT::Math::tgamma(double x)` - calculates the gamma; function:; $$\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt$$. ### Special Functions in MathMore. - `double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -`computes; the associated Legendre polynomials (with `m>=0`, `l>=m` and; `|x|<1)`:; $$P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)$$. - `double ROOT::Math::comp_ellint_1(double k)` - calculates the; complete elliptic integral of the first kind (with $0 \le k^2 \le 1$:; $$; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; $$. - `double ROOT::Math::comp_ellint_2(double k)` - calculates the; complete elliptic integral of the second kind (with $0 \le k^2 \le 1",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48314,Deployability,integrat,integration,48314,"1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48654,Deployability,integrat,integrator,48654,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48760,Deployability,integrat,integration,48760,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48869,Deployability,integrat,integration,48869,"`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `RO",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48940,Deployability,integrat,integrator,48940,"into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some spe",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49028,Deployability,integrat,integrating,49028,"TF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integr",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49288,Deployability,integrat,integration,49288,"`. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49552,Deployability,integrat,integration,49552,"onality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-di",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49602,Deployability,integrat,integrated,49602,"tiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50876,Deployability,integrat,integration,50876,"ific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ER",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:51297,Deployability,integrat,integrators,51297,"part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:52709,Deployability,integrat,integration,52709,"::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kLEGENDRE);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:53442,Deployability,integrat,integration,53442,"ral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT:",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54392,Deployability,integrat,integration,54392,":Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` clas",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54618,Deployability,integrat,integrator,54618,"s; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54681,Deployability,integrat,integration,54681,"#include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative t",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54772,Deployability,integrat,integration,54772,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54835,Deployability,integrat,integration,54835,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54979,Deployability,integrat,integration,54979,"se);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55269,Deployability,integrat,integration,55269," integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It i",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55387,Deployability,integrat,integrator,55387,"placing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56063,Deployability,integrat,integration,56063," code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56438,Deployability,integrat,integration,56438,"grator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56576,Deployability,integrat,integration,56576,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56603,Deployability,integrat,integration,56603,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56767,Deployability,integrat,integration,56767,"sfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that whe",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57437,Deployability,integrat,integration,57437,"s.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57599,Deployability,integrat,integration,57599,"nto subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instan",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57715,Deployability,integrat,integration,57715,"st estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58177,Deployability,integrat,integration,58177,"USS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; st",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58290,Deployability,integrat,integration,58290,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58345,Deployability,integrat,integration,58345,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:60543,Deployability,integrat,integration,60543,"ntegral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. #### Multi-dimensions Integration Algorithms. Here is the types, that can be specified as enumeration and the corresponding classes. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorMultiDim::kADAPTIVE` | `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum a",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61228,Deployability,integrat,integration,61228," `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when usin",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61366,Deployability,integrat,integration,61366,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61689,Deployability,integrat,integration,61689," values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the thir",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61755,Deployability,integrat,integration,61755,"Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61855,Deployability,integrat,integration,61855,"Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61921,Deployability,integrat,integration,61921,"erance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61962,Deployability,integrat,integration,61962,"erance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62089,Deployability,configurat,configuration,62089," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62533,Deployability,integrat,integration,62533," can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62647,Deployability,integrat,integration,62647,"# `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62836,Deployability,integrat,integration,62836,"ical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; The algorithms supported are only bracketing algorithm which do not use derivatives information. Two classes exist. One in",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7233,Energy Efficiency,charge,charge,7233,"hing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, like common probability and cumulative; (quantile) distributions. - geometrical functions. For more details, see the reference documentation of **`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7476,Energy Efficiency,power,power,7476,"`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to ca",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:15950,Energy Efficiency,efficient,efficient,15950,"ndom Number Distributions. The **`TRandom`** base class provides functions, which can be used by; all the other derived classes for generating random variates according; to predefined distributions. In the simplest cases, like in the case of; the exponential distribution, the non-uniform random number is obtained; by applying appropriate transformations. In the more complicated cases,; random variates are obtained using acceptance-rejection methods, which; require several random numbers. ``` {.cpp}; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; ```. The following table shows the various distributions that can be; generated using methods of the **`TRandom`** classes. More information; is available in the reference documentation for **`TRandom`**. In; addition, random numbers distributed according to a user defined; function, in a limited interval, or to a user defined histogram, can be; generated in a very efficient way using **`TF1::`**GetRandom() or; **`TH1::`**GetRandom(). +-------------------------------------------+--------------------------------+; | Distributions | Description |; +-------------------------------------------+--------------------------------+; | `Double_t Uniform(Double_t x1,Double_t x2 | Uniform random numbers between |; | )` | `x1,x2` |; +-------------------------------------------+--------------------------------+; | `Double_t Gaus(Double_t mu,Double_t sigma | Gaussian random numbers. |; | )` | |; | | Default values: `mu=0`, |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+; | `Double_t Exp(Double_t tau)` | Exponential random numbers |; | | with mean tau. |; +-------------------------------------------+--------------------------------+; | `Double_t Landau(Double_t mean,Double_t s | Landau distributed random |; | igma)` | numbers. |; | | |; | | Default values: `mean=0`,",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:41111,Energy Efficiency,efficient,efficient,41111,"uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }; };; ```. * **`ROOT::Math::IParametricGradFunctionMultiDim`**:; Provides an interface for parametric gradient multi-dimensional functions. In addition to function evaluation it provides the gradient with respect to the parameters,; via the method `ParameterGradient()`. This interface is only used in case of some dedicated fitting algorithms, when is required or more efficient to provide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54763,Energy Efficiency,adapt,adaptive,54763,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55378,Energy Efficiency,adapt,adaptive,55378,"placing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56292,Energy Efficiency,adapt,adaptive,56292,"lass.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rul",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56553,Energy Efficiency,adapt,adaptiva,56553,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61208,Energy Efficiency,adapt,adaptive,61208," `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when usin",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61333,Energy Efficiency,adapt,adaptive,61333,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:71417,Energy Efficiency,efficient,efficient,71417,"ric Coordinate System. The vector classes are based on a generic type of coordinate system,; expressed as a template parameter of the class. Various classes exist to; describe the various coordinates systems:. 2D coordinate system classes:. - **`ROOT::Math::Cartesian2D`**, based on (`x,y`);. - **`ROOT::Math::Polar2D`**, based on (`r,phi`);. 3D coordinate system classes:. - **`ROOT::Math::Cartesian3D`**, based on (`x,y,z`);. - **`ROOT::Math::Polar3D`**, based on (`r,theta,phi`);. - **`ROOT::Math::Cylindrical3D`**, based on (`rho,z,phi`). - **`ROOT::Math::CylindricalEta3D`**, based on (`rho,eta,phi`), where; `eta` is the pseudo-rapidity;. 4D coordinate system classes:. - **`ROOT::Math::PxPyPzE4D`**, based on based on (`px,py,pz,E`);. - **`ROOT::Math::PxPyPzM4D`**, based on based on (`px,py,pz,M`);. - **`ROOT::Math::PtEtaPhiE4D`**, based on based on (`pt,eta,phi,E`);. - **`ROOT::Math::PtEtaPhiM4D`**, based on based on (`pt,eta,phi,M`);. Users can define the vectors according to the coordinate type, which is; the most efficient for their use. Transformations between the various; coordinate systems are available through copy constructors or the; assignment (=) operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for user",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:431,Integrability,integrat,integrated,431,"# Math Libraries in ROOT. The aim of Math libraries in ROOT is to provide and to support a; coherent set of mathematical and statistical functions. The latest; developments have been concentrated in providing first versions of the; `MathCore` and `MathMore` libraries, included in ROOT v5.08. Other; recent developments include the new version of `MINUIT`, which has been; re-designed and re-implemented in the C++ language. It is integrated in; ROOT. In addition, an optimized package for describing small matrices; and vector with fixed sizes and their operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1400,Integrability,interface,interfaces,1400," operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides t",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1574,Integrability,interface,interfaces,1574," operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides t",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1768,Integrability,wrap,wrapper,1768,"sic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1831,Integrability,wrap,wrapping,1831,"sic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1867,Integrability,interface,interface,1867,"sic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1972,Integrability,interface,interfaces,1972,"d in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2043,Integrability,integrat,integration,2043,"d in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2223,Integrability,interface,interface,2223,"d in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2576,Integrability,depend,depending,2576,"unction interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probabili",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3288,Integrability,wrap,wrapping,3288,"a sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolati",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3834,Integrability,integrat,integration,3834,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3871,Integrability,interface,interface,3871,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3942,Integrability,integrat,integration,3942,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4102,Integrability,interface,interface,4102,"nced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; Lice",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4206,Integrability,interface,interface,4206,"nctionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is fou",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4898,Integrability,wrap,wrapping,4898,"or`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7732,Integrability,wrap,wrapper,7732," form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfa",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:8664,Integrability,interface,interfaces,8664," standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that receives two iterators to it. ```{.cpp}; // Size of the array; const int n = 100;. // Vector v with random values; vector<double> v(n);; std::generate(v.begin(), v.end(), rand);. // Weight vector w; vector<double> w(n);; std::fill(w.begin(), w.end, 1);. double mean;. // Calculate the mean of the vector; // with iterators; mean = TMath::Mean(v.begin(), v.end());. // old-style; mean = TMath::Mean(n, &v[0]);. // Calculate the mean with a weight vector; // with iterators; mean = TMath::Mean(v.begin(), v.end(), w.begin());. // old-style; mean = TMath::Mean(n, &v[0], &w[0]);; ```. ### Special and Statistical Functions. `TMath` also provides special functions like Bessel, Error functions, Gamma or similar plus statistical mathematical functions, including probability density functions, cumulative distrib",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:8816,Integrability,interface,interface,8816,"less, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that receives two iterators to it. ```{.cpp}; // Size of the array; const int n = 100;. // Vector v with random values; vector<double> v(n);; std::generate(v.begin(), v.end(), rand);. // Weight vector w; vector<double> w(n);; std::fill(w.begin(), w.end, 1);. double mean;. // Calculate the mean of the vector; // with iterators; mean = TMath::Mean(v.begin(), v.end());. // old-style; mean = TMath::Mean(n, &v[0]);. // Calculate the mean with a weight vector; // with iterators; mean = TMath::Mean(v.begin(), v.end(), w.begin());. // old-style; mean = TMath::Mean(n, &v[0], &w[0]);; ```. ### Special and Statistical Functions. `TMath` also provides special functions like Bessel, Error functions, Gamma or similar plus statistical mathematical functions, including probability density functions, cumulative distribution and their inverse. The majority of the special functions and the statistical distributions are provided also as free functi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18284,Integrability,interface,interface,18284,"ndom numbers |; | | |; | `Double_t PoissonD(Double_t mean)` | |; +-------------------------------------------+--------------------------------+; | `Int_t Binomial(Int_t ntot,Double_t prob | Binomial Random numbers |; | )` | |; +-------------------------------------------+--------------------------------+; | `Circle(Double_t &x,Double_t &y,Double_t | Generate a random 2D point |; | r)` | `(x,y)` in |; | | |; | | a circle of radius `r` |; +-------------------------------------------+--------------------------------+; | `Sphere(Double_t &x,Double_t &y,` | Generate a random 3D point |; | | `(x,y,z)` in |; | ` Double_t &z,Double_t r)` | |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" meth",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18943,Integrability,interface,interface,18943," |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For continuous 1D distribution object via the class; **`TUnuranContDist`** that can be created for example from a; **`TF1`** function providing the pdf (probability density function); . The user can optionally provide additional information via; `TUnuranContDist::SetDomain(min,max)` like the `domain()` for; generating numbers in a restricted region. ``` {.cpp}; // 1D case: create a distribution from two TF1 object; // pointers pdfFunc; TUnuranContDist dist( pdfFunc);;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:22047,Integrability,interface,interface,22047,"dist, ""method=dgt"");; // sample N times (generate N random numbers); for (int i = 0; i < N; ++i); int k = unr.SampleDiscr();; ```. - For empirical distribution via the class **`TUnuranEmpDist`**. In; this case one can generate random numbers from a set of un-bin or; bin data. In the first case the parent distribution is estimated by; UNU.RAN using a gaussian kernel smoothing algorithm. The; **`TUnuranEmpDist`** distribution class can be created from a vector; of data or from **`TH1`** (using the bins or from its buffer for; un-binned data). ``` {.cpp}; // Create distribution from a set of data; // vdata is an std::vector containing the data; TUnuranEmpDist dist(vdata.begin(),vdata.end());; unr.Init(dist);; // sample N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For some predefined distributions, like `Poisson` and `Binomial`,; one can use directly a function in the **`TUnuran`** class. This is; more convenient in passing distribution parameters than using; directly the string interface. ``` {.cpp}; TUnuran unr;; // Initialize unuran to generate normal random numbers from the; // Poisson distribution with parameter mu; unr.InitPoisson(mu);; ...; // Sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); int k = unr.SampleDiscr();; ```. Functionality is also provided via the C++ classes for using a different; random number generator by passing a TRandom pointer when constructing; the **`TUnuran`** class (by default the ROOT ***`gRandom`*** is passed; to UNURAN). ### Performances of Random Numbers. Here are the CPU times obtained using the four random classes on an; `lxplus` machine with an Intel 64 bit architecture and compiled using gcc; 3.4:. +--------------------+---------------+----------------+----------------+----------------+; | | **`TRandom`** | **`TRandom1`** | **`TRandom2`** | **`TRandom3`** |; | | (ns/call) | (ns/call) | (ns/call) | (ns/call) |; +--------------------+------------",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:24633,Integrability,integrat,integrating,24633,"|; +--------------------+---------------+----------------+----------------+----------------+. ## Mathematical Functions. The mathematical functions are present in both `MathCore` and `MathMore`; libraries. All mathematical functions are implemented as free functions; in the namespace **`ROOT::Math`**. The most used functions are in the; `MathCore` library while the others are in the `MathMore` library. The; functions in `MathMore` are all using the implementation of the GNU; Scientific Library (GSL). The naming of the special functions is the; same defined in the C++; [Technical Report on Standard Library extensions](Technical Report on; Standard Library extensions).; The special functions are defined in the header file `Math/SpecFunc.h`. ### Special Functions in MathCore. - `ROOT::Math::beta(double x,double y) - `evaluates the beta function:; $$B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}$$. - `double ROOT::Math::erf(double x)` - evaluates the error function; encountered in integrating the normal; distribution:; $$erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt$$. - `double ROOT::Math::erfc(double x)` - evaluates the complementary; error function:; $$erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt$$. - `double ROOT::Math::tgamma(double x)` - calculates the gamma; function:; $$\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt$$. ### Special Functions in MathMore. - `double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -`computes; the associated Legendre polynomials (with `m>=0`, `l>=m` and; `|x|<1)`:; $$P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)$$. - `double ROOT::Math::comp_ellint_1(double k)` - calculates the; complete elliptic integral of the first kind (with $0 \le k^2 \le 1$:; $$; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; $$. - `double ROOT::Math::comp_ellint_2(double k)` - calculates the; complete elliptic integral of the second kind (with $0 \le k^2 \le 1",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34718,Integrability,interface,interfaces,34718,"ension; `_quantile` calculate the inverse of the cumulative distribution; function (lower tail integral of the probability density function),; while those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34753,Integrability,interface,interfaces,34753,"mulative distribution; function (lower tail integral of the probability density function),; while those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplemen",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34849,Integrability,interface,interfaces,34849,"ile those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35101,Integrability,interface,interface,35101,"ure illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; doubl",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35203,Integrability,interface,interfaces,35203,"f the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradien",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:36467,Integrability,interface,interface,36467,"s the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradientFunctionOneDim`: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The class; inherit by the user will have to implement the abstract method `double DoDerivative(double x)`, leaving the rest of the class untouched. Example for implementing a gradient one-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the prev",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:37422,Integrability,interface,interfaces,37422,"the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The class; inherit by the user will have to implement the abstract method `double DoDerivative(double x)`, leaving the rest of the class untouched. Example for implementing a gradient one-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; pu",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:37733,Integrability,interface,interface,37733,"nt the abstract method `double DoDerivative(double x)`, leaving the rest of the class untouched. Example for implementing a gradient one-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same func",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:37788,Integrability,interface,interface,37788,"ction:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38654,Integrability,interface,interface,38654,"ti-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the he",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:39565,Integrability,interface,interfaces,39565,"; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric function. Similarly to the one dimensional version, the user needs to provide the; method `void SetParameters(double* p)` as well as the getter methods `const double * Parameters()` and `uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const dou",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:39648,Integrability,interface,interfaces,39648,"ame functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric function. Similarly to the one dimensional version, the user needs to provide the; method `void SetParameters(double* p)` as well as the getter methods `const double * Parameters()` and `uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double*",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:40818,Integrability,interface,interface,40818," * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric function. Similarly to the one dimensional version, the user needs to provide the; method `void SetParameters(double* p)` as well as the getter methods `const double * Parameters()` and `uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }; };; ```. * **`ROOT::Math::IParametricGradFunctionMultiDim`**:; Provides an interface for parametric gradient multi-dimensional functions. In addition to function evaluation it provides the gradient with respect to the parameters,; via the method `ParameterGradient()`. This interface is only used in case of some dedicated fitting algorithms, when is required or more efficient to provide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoP",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:41017,Integrability,interface,interface,41017,"uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }; };; ```. * **`ROOT::Math::IParametricGradFunctionMultiDim`**:; Provides an interface for parametric gradient multi-dimensional functions. In addition to function evaluation it provides the gradient with respect to the parameters,; via the method `ParameterGradient()`. This interface is only used in case of some dedicated fitting algorithms, when is required or more efficient to provide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42114,Integrability,interface,interface,42114,"ovide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42141,Integrability,wrap,wrapping,42141,"ovide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42159,Integrability,interface,interface,42159,"ovide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42199,Integrability,interface,interfaces,42199,"ovide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42377,Integrability,wrap,wrapper,42377,"c:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42395,Integrability,interface,interface,42395,"c:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42475,Integrability,wrap,wrapper,42475,"* x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42910,Integrability,wrap,wrapper,42910,"[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43047,Integrability,wrap,wrap,43047,"tion in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43085,Integrability,wrap,wrap,43085,"tion in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43672,Integrability,wrap,wrapping,43672,"th::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or bo",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43765,Integrability,wrap,wrapping,43765,":Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional F",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43853,Integrability,wrap,wrapping,43853,"|. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44131,Integrability,wrap,wrap,44131," function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member func",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44858,Integrability,wrap,wrap,44858,"er function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test fro",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44942,Integrability,wrap,wrap,44942,"t << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; c",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
